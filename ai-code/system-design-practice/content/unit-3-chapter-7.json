{
  "unit": 3,
  "unitTitle": "API Design",
  "chapter": 7,
  "chapterTitle": "GraphQL & Alternatives",
  "chapterDescription": "GraphQL queries and schemas, gRPC and Protocol Buffers, WebSockets, SSE, webhooks, and choosing the right paradigm.",
  "problems": [
    {
      "id": "gql-001",
      "type": "multiple-choice",
      "question": "What is the primary problem GraphQL was designed to solve?",
      "options": [
        "Over-fetching and under-fetching of data in REST APIs",
        "Slow database queries",
        "Authentication complexity",
        "Server-side rendering"
      ],
      "correct": 0,
      "explanation": "GraphQL lets clients request exactly the data they need, avoiding over-fetching (getting too much data) and under-fetching (needing multiple requests to get all required data).",
      "detailedExplanation": "GraphQL lets clients request exactly the data they need, avoiding over-fetching (getting too much data) and under-fetching (needing multiple requests to get all required data). Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-002",
      "type": "multiple-choice",
      "question": "In GraphQL, what are the three root operation types?",
      "options": [
        "Query, Mutation, Subscription",
        "GET, POST, DELETE",
        "Read, Write, Stream",
        "Select, Insert, Update"
      ],
      "correct": 0,
      "explanation": "GraphQL defines Query for reads, Mutation for writes, and Subscription for real-time updates. All GraphQL operations use these three types.",
      "detailedExplanation": "GraphQL defines Query for reads, Mutation for writes, and Subscription for real-time updates. All GraphQL operations use these three types. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-003",
      "type": "multiple-choice",
      "question": "What HTTP method do GraphQL APIs typically use for all operations?",
      "options": [
        "POST",
        "GET for queries, POST for mutations",
        "Varies by operation type",
        "PUT"
      ],
      "correct": 0,
      "explanation": "GraphQL typically uses POST for all operations because the query/mutation is sent in the request body. Some implementations support GET for queries via query parameters.",
      "detailedExplanation": "GraphQL typically uses POST for all operations because the query/mutation is sent in the request body. Some implementations support GET for queries via query parameters. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-004",
      "type": "multiple-choice",
      "question": "What is a GraphQL schema?",
      "options": [
        "A type system that defines the API's capabilities",
        "A database schema",
        "A JSON configuration file",
        "A REST endpoint mapping"
      ],
      "correct": 0,
      "explanation": "The GraphQL schema defines all types, queries, mutations, and subscriptions available in the API. It serves as a contract between client and server.",
      "detailedExplanation": "The GraphQL schema defines all types, queries, mutations, and subscriptions available in the API. It serves as a contract between client and server. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-005",
      "type": "multiple-choice",
      "question": "What language is used to define GraphQL schemas?",
      "options": [
        "Schema Definition Language (SDL)",
        "JSON Schema",
        "YAML",
        "Protocol Buffers"
      ],
      "correct": 0,
      "explanation": "GraphQL uses SDL (Schema Definition Language) to define types and operations. It's a human-readable syntax specific to GraphQL.",
      "detailedExplanation": "GraphQL uses SDL (Schema Definition Language) to define types and operations. It's a human-readable syntax specific to GraphQL. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-006",
      "type": "two-stage",
      "question": "Consider this GraphQL type definition:",
      "context": "type User {\n  id: ID!\n  name: String!\n  email: String\n  posts: [Post!]!\n}",
      "stages": [
        {
          "question": "What does the '!' after 'ID' mean?",
          "options": [
            "The field is non-nullable (required)",
            "The field is unique",
            "The field is indexed",
            "The field is the primary key"
          ],
          "correct": 0,
          "explanation": "In GraphQL SDL, '!' means the field is non-nullable—it will never be null in responses.",
          "detailedExplanation": "In GraphQL SDL, '!' means the field is non-nullable—it will never be null in responses. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "What does '[Post!]!' mean for the posts field?",
          "options": [
            "Non-null array of non-null Post objects",
            "Optional array of optional Posts",
            "Exactly one Post",
            "Array that may contain nulls"
          ],
          "correct": 0,
          "explanation": "[Post!]! means the array itself is non-null AND each element in the array is non-null. You'll get an array (possibly empty), never null.",
          "detailedExplanation": "[Post!]! means the array itself is non-null AND each element in the array is non-null. You'll get an array (possibly empty), never null. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-007",
      "type": "multiple-choice",
      "question": "What is a resolver in GraphQL?",
      "options": [
        "A function that fetches data for a specific field",
        "A query optimizer",
        "A caching layer",
        "A schema validator"
      ],
      "correct": 0,
      "explanation": "Resolvers are functions that return data for each field in the schema. When a query requests a field, its resolver is called to fetch the actual data.",
      "detailedExplanation": "Resolvers are functions that return data for each field in the schema. When a query requests a field, its resolver is called to fetch the actual data. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-008",
      "type": "multiple-choice",
      "question": "What is the N+1 problem in GraphQL?",
      "options": [
        "Fetching related data requires N additional database queries for N items",
        "Schema requires N+1 types",
        "Clients must make N+1 requests",
        "Pagination returns N+1 items"
      ],
      "correct": 0,
      "explanation": "The N+1 problem occurs when fetching a list of N items, then making N separate queries to fetch related data for each item. It's a common performance issue.",
      "detailedExplanation": "The N+1 problem occurs when fetching a list of N items, then making N separate queries to fetch related data for each item. It's a common performance issue. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-009",
      "type": "multiple-choice",
      "question": "What tool is commonly used to solve the N+1 problem in GraphQL?",
      "options": ["DataLoader", "GraphQL Shield", "Apollo Cache", "Prisma"],
      "correct": 0,
      "explanation": "DataLoader batches and caches requests within a single request cycle, combining multiple individual fetches into a single batched query.",
      "detailedExplanation": "DataLoader batches and caches requests within a single request cycle, combining multiple individual fetches into a single batched query. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-010",
      "type": "two-stage",
      "question": "A GraphQL query fetches 50 users, each with their posts.",
      "stages": [
        {
          "question": "Without optimization, how many database queries might this cause?",
          "options": [
            "51 queries (1 for users + 50 for posts)",
            "1 query",
            "2 queries",
            "100 queries"
          ],
          "correct": 0,
          "explanation": "One query fetches users, then 50 individual queries fetch posts for each user—the classic N+1 pattern.",
          "detailedExplanation": "One query fetches users, then 50 individual queries fetch posts for each user—the classic N+1 pattern. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "With DataLoader, how many queries would this typically require?",
          "options": [
            "2 queries (users + batched posts)",
            "1 query with joins",
            "51 queries",
            "50 queries"
          ],
          "correct": 0,
          "explanation": "DataLoader batches the 50 post requests into a single query, reducing total queries from 51 to 2.",
          "detailedExplanation": "DataLoader batches the 50 post requests into a single query, reducing total queries from 51 to 2. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-011",
      "type": "multiple-choice",
      "question": "What is a GraphQL fragment?",
      "options": [
        "A reusable set of fields that can be included in queries",
        "A partial response",
        "A schema subset",
        "A query parameter"
      ],
      "correct": 0,
      "explanation": "Fragments define reusable sets of fields that can be spread into multiple queries, reducing duplication when the same fields are needed in different places.",
      "detailedExplanation": "Fragments define reusable sets of fields that can be spread into multiple queries, reducing duplication when the same fields are needed in different places. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-012",
      "type": "multiple-choice",
      "question": "What are GraphQL variables used for?",
      "options": [
        "Passing dynamic values to queries without string interpolation",
        "Defining schema types",
        "Creating fragments",
        "Setting server configuration"
      ],
      "correct": 0,
      "explanation": "Variables let clients pass dynamic values (like IDs, filters) separately from the query string, improving security and enabling query caching.",
      "detailedExplanation": "Variables let clients pass dynamic values (like IDs, filters) separately from the query string, improving security and enabling query caching. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-013",
      "type": "multi-select",
      "question": "Which are advantages of GraphQL over REST?",
      "options": [
        "Single endpoint for all operations",
        "Client specifies exact data needed",
        "Strongly typed schema",
        "Built-in caching via HTTP"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "GraphQL uses a single endpoint, lets clients request specific fields, and has a strong type system. HTTP caching is actually harder with GraphQL since it uses POST.",
      "detailedExplanation": "GraphQL uses a single endpoint, lets clients request specific fields, and has a strong type system. HTTP caching is actually harder with GraphQL since it uses POST. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-014",
      "type": "multi-select",
      "question": "Which are disadvantages of GraphQL compared to REST?",
      "options": [
        "HTTP caching is harder",
        "More complex to implement",
        "Query complexity can cause performance issues",
        "Every request returns 200 OK"
      ],
      "correctIndices": [0, 1, 2, 3],
      "explanation": "GraphQL loses HTTP caching benefits, requires more setup, needs query complexity limits, and returns 200 even for errors (with errors in the response body).",
      "detailedExplanation": "GraphQL loses HTTP caching benefits, requires more setup, needs query complexity limits, and returns 200 even for errors (with errors in the response body). Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-015",
      "type": "multiple-choice",
      "question": "Why does GraphQL typically return HTTP 200 even when there are errors?",
      "options": [
        "GraphQL handles errors in the response body, not HTTP status",
        "To simplify client implementation",
        "HTTP errors are deprecated",
        "For backwards compatibility"
      ],
      "correct": 0,
      "explanation": "GraphQL responses include an 'errors' array alongside 'data'. A request can partially succeed, returning some data plus some errors, so HTTP status doesn't capture this.",
      "detailedExplanation": "GraphQL responses include an 'errors' array alongside 'data'. A request can partially succeed, returning some data plus some errors, so HTTP status doesn't capture this. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-016",
      "type": "multiple-choice",
      "question": "What is GraphQL introspection?",
      "options": [
        "The ability to query the schema itself",
        "Query performance analysis",
        "Automatic documentation generation",
        "Type checking at runtime"
      ],
      "correct": 0,
      "explanation": "Introspection lets clients query the schema to discover available types, fields, and operations. This powers GraphQL tooling like GraphiQL and schema explorers.",
      "detailedExplanation": "Introspection lets clients query the schema to discover available types, fields, and operations. This powers GraphQL tooling like GraphiQL and schema explorers. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-017",
      "type": "multiple-choice",
      "question": "Why might you disable GraphQL introspection in production?",
      "options": [
        "To hide schema details from potential attackers",
        "To improve query performance",
        "Introspection uses too much memory",
        "It conflicts with caching"
      ],
      "correct": 0,
      "explanation": "Introspection exposes your entire API structure. In production, disabling it prevents attackers from easily discovering all available operations and types.",
      "detailedExplanation": "Introspection exposes your entire API structure. In production, disabling it prevents attackers from easily discovering all available operations and types. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-018",
      "type": "multiple-choice",
      "question": "What is query depth limiting in GraphQL?",
      "options": [
        "Restricting how deeply nested a query can be",
        "Limiting query string length",
        "Capping the number of fields",
        "Restricting query frequency"
      ],
      "correct": 0,
      "explanation": "Depth limiting prevents deeply nested queries that could cause performance issues or denial of service. It restricts how many levels of relationships can be traversed.",
      "detailedExplanation": "Depth limiting prevents deeply nested queries that could cause performance issues or denial of service. It restricts how many levels of relationships can be traversed. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-019",
      "type": "two-stage",
      "question": "A malicious client sends this query to a social media GraphQL API:",
      "context": "query {\n  user(id: 1) {\n    friends {\n      friends {\n        friends {\n          friends {\n            name\n          }\n        }\n      }\n    }\n  }\n}",
      "stages": [
        {
          "question": "What attack does this represent?",
          "options": [
            "Query complexity/depth attack",
            "SQL injection",
            "Authentication bypass",
            "Rate limiting evasion"
          ],
          "correct": 0,
          "explanation": "This deeply nested query could cause exponential data fetching (each level multiplies the results), potentially overwhelming the server.",
          "detailedExplanation": "This deeply nested query could cause exponential data fetching (each level multiplies the results), potentially overwhelming the server. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "What's the best defense?",
          "options": [
            "Query depth and complexity limits",
            "Input validation",
            "Rate limiting only",
            "Disable the friends field"
          ],
          "correct": 0,
          "explanation": "Depth limits prevent excessively nested queries. Complexity analysis can also assign costs to fields and reject queries exceeding a threshold.",
          "detailedExplanation": "Depth limits prevent excessively nested queries. Complexity analysis can also assign costs to fields and reject queries exceeding a threshold. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-020",
      "type": "multiple-choice",
      "question": "What is query complexity analysis in GraphQL?",
      "options": [
        "Assigning costs to fields and limiting total query cost",
        "Measuring query execution time",
        "Counting database joins",
        "Analyzing query syntax"
      ],
      "correct": 0,
      "explanation": "Complexity analysis assigns point values to fields (e.g., list fields cost more) and rejects queries exceeding a maximum total cost.",
      "detailedExplanation": "Complexity analysis assigns point values to fields (e.g., list fields cost more) and rejects queries exceeding a maximum total cost. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-021",
      "type": "multiple-choice",
      "question": "What are persisted queries in GraphQL?",
      "options": [
        "Pre-registered queries identified by hash/ID instead of sending full query text",
        "Queries stored in a database",
        "Cached query results",
        "Queries that survive server restarts"
      ],
      "correct": 0,
      "explanation": "Persisted queries store query text on the server. Clients send only a query ID, reducing payload size and preventing arbitrary query execution.",
      "detailedExplanation": "Persisted queries store query text on the server. Clients send only a query ID, reducing payload size and preventing arbitrary query execution. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-022",
      "type": "multi-select",
      "question": "What are benefits of GraphQL persisted queries?",
      "options": [
        "Smaller request payloads",
        "Prevents arbitrary query execution",
        "Enables query whitelisting",
        "Automatic schema generation"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "Persisted queries reduce payload size, allow only pre-approved queries (security), and enable whitelisting. They don't affect schema generation.",
      "detailedExplanation": "Persisted queries reduce payload size, allow only pre-approved queries (security), and enable whitelisting. They don't affect schema generation. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-023",
      "type": "multiple-choice",
      "question": "What is a GraphQL subscription?",
      "options": [
        "A way to receive real-time updates from the server",
        "A paid API tier",
        "A query that runs periodically",
        "A mutation that triggers on events"
      ],
      "correct": 0,
      "explanation": "Subscriptions enable real-time data by establishing a persistent connection (usually WebSocket). The server pushes updates when relevant data changes.",
      "detailedExplanation": "Subscriptions enable real-time data by establishing a persistent connection (usually WebSocket). The server pushes updates when relevant data changes. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "RFC 6455: The WebSocket Protocol",
          "url": "https://www.rfc-editor.org/rfc/rfc6455"
        }
      ]
    },
    {
      "id": "gql-024",
      "type": "multiple-choice",
      "question": "What transport protocol do GraphQL subscriptions typically use?",
      "options": [
        "WebSocket",
        "HTTP long polling",
        "Server-Sent Events",
        "gRPC streaming"
      ],
      "correct": 0,
      "explanation": "WebSocket is the most common transport for GraphQL subscriptions, providing bidirectional communication for real-time updates.",
      "detailedExplanation": "WebSocket is the most common transport for GraphQL subscriptions, providing bidirectional communication for real-time updates. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "RFC 6455: The WebSocket Protocol",
          "url": "https://www.rfc-editor.org/rfc/rfc6455"
        }
      ]
    },
    {
      "id": "gql-025",
      "type": "multiple-choice",
      "question": "What is Apollo Federation?",
      "options": [
        "A way to compose multiple GraphQL services into a unified graph",
        "Apollo's caching strategy",
        "A GraphQL testing framework",
        "A schema validation tool"
      ],
      "correct": 0,
      "explanation": "Apollo Federation lets you split a GraphQL schema across multiple services, each owning part of the graph, while presenting a unified API to clients.",
      "detailedExplanation": "Apollo Federation lets you split a GraphQL schema across multiple services, each owning part of the graph, while presenting a unified API to clients. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-026",
      "type": "ordering",
      "question": "Order these GraphQL request processing steps:",
      "items": [
        "Parse query string",
        "Validate against schema",
        "Execute resolvers",
        "Format response"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "The server parses the query text, validates it against the schema (types, fields exist), executes resolvers to fetch data, and formats the final response.",
      "detailedExplanation": "The server parses the query text, validates it against the schema (types, fields exist), executes resolvers to fetch data, and formats the final response. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-027",
      "type": "multiple-choice",
      "question": "What is the purpose of the @deprecated directive in GraphQL?",
      "options": [
        "Mark fields as deprecated while keeping them functional",
        "Remove fields from the schema",
        "Hide fields from introspection",
        "Disable field resolvers"
      ],
      "correct": 0,
      "explanation": "@deprecated marks fields as deprecated with an optional reason. The field still works but tooling warns clients, enabling gradual migration.",
      "detailedExplanation": "@deprecated marks fields as deprecated with an optional reason. The field still works but tooling warns clients, enabling gradual migration. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-028",
      "type": "multiple-choice",
      "question": "How does GraphQL handle API versioning?",
      "options": [
        "Typically uses schema evolution instead of versions",
        "URL path versioning like REST",
        "Query parameter versioning",
        "Header-based versioning"
      ],
      "correct": 0,
      "explanation": "GraphQL typically avoids versioning by evolving the schema: adding new fields, deprecating old ones, and eventually removing them. Clients request only fields they need.",
      "detailedExplanation": "GraphQL typically avoids versioning by evolving the schema: adding new fields, deprecating old ones, and eventually removing them. Clients request only fields they need. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-029",
      "type": "two-stage",
      "question": "You need to rename a GraphQL field from 'userName' to 'name'.",
      "stages": [
        {
          "question": "What's the recommended migration approach?",
          "options": [
            "Add 'name', deprecate 'userName', remove later",
            "Rename immediately and update all clients",
            "Create a v2 schema",
            "Use an alias at the server level"
          ],
          "correct": 0,
          "explanation": "Add the new field, mark the old one @deprecated, give clients time to migrate, then remove the old field once usage drops.",
          "detailedExplanation": "Add the new field, mark the old one @deprecated, give clients time to migrate, then remove the old field once usage drops. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "How long should deprecated fields typically remain?",
          "options": [
            "Until client usage drops to acceptable levels",
            "Exactly 6 months",
            "One release cycle",
            "Indefinitely"
          ],
          "correct": 0,
          "explanation": "Monitor deprecated field usage and remove when most/all clients have migrated. The timeline depends on your client ecosystem and communication.",
          "detailedExplanation": "Monitor deprecated field usage and remove when most/all clients have migrated. The timeline depends on your client ecosystem and communication. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-030",
      "type": "multiple-choice",
      "question": "What is gRPC?",
      "options": [
        "A high-performance RPC framework using Protocol Buffers",
        "A GraphQL extension",
        "A REST alternative using JSON",
        "A WebSocket protocol"
      ],
      "correct": 0,
      "explanation": "gRPC is Google's RPC framework that uses Protocol Buffers for serialization. It's designed for high-performance, low-latency communication between services.",
      "detailedExplanation": "gRPC is Google's RPC framework that uses Protocol Buffers for serialization. It's designed for high-performance, low-latency communication between services. Convert targets into concrete counts and time budgets first, then reason about whether incident frequency and recovery time can satisfy them.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-031",
      "type": "multiple-choice",
      "question": "What are Protocol Buffers (protobuf)?",
      "options": [
        "A binary serialization format with schema definition",
        "A network protocol",
        "A GraphQL alternative",
        "A JSON compression algorithm"
      ],
      "correct": 0,
      "explanation": "Protocol Buffers is Google's language-neutral, platform-neutral mechanism for serializing structured data. It's smaller and faster than JSON.",
      "detailedExplanation": "Protocol Buffers is Google's language-neutral, platform-neutral mechanism for serializing structured data. It's smaller and faster than JSON. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-032",
      "type": "multi-select",
      "question": "What are advantages of gRPC over REST?",
      "options": [
        "Smaller payload size (binary)",
        "Strong typing via protobuf schemas",
        "Built-in streaming support",
        "Works in browsers without special handling"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "gRPC uses efficient binary encoding, has strong schemas, and supports streaming. Browser support requires gRPC-Web, a proxy layer.",
      "detailedExplanation": "gRPC uses efficient binary encoding, has strong schemas, and supports streaming. Browser support requires gRPC-Web, a proxy layer. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-033",
      "type": "multiple-choice",
      "question": "What transport protocol does gRPC use?",
      "options": ["HTTP/2", "HTTP/1.1", "WebSocket", "Custom TCP protocol"],
      "correct": 0,
      "explanation": "gRPC is built on HTTP/2, leveraging its multiplexing, header compression, and bidirectional streaming capabilities.",
      "detailedExplanation": "gRPC is built on HTTP/2, leveraging its multiplexing, header compression, and bidirectional streaming capabilities. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-034",
      "type": "multi-select",
      "question": "Which streaming modes does gRPC support?",
      "options": [
        "Unary (request-response)",
        "Server streaming",
        "Client streaming",
        "Bidirectional streaming"
      ],
      "correctIndices": [0, 1, 2, 3],
      "explanation": "gRPC supports all four: unary (simple RPC), server streaming (server sends multiple responses), client streaming (client sends multiple requests), and bidirectional.",
      "detailedExplanation": "gRPC supports all four: unary (simple RPC), server streaming (server sends multiple responses), client streaming (client sends multiple requests), and bidirectional. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-035",
      "type": "two-stage",
      "question": "You're building a chat application backend.",
      "stages": [
        {
          "question": "Which gRPC streaming mode is most appropriate for real-time messages?",
          "options": [
            "Bidirectional streaming",
            "Server streaming only",
            "Client streaming only",
            "Unary calls"
          ],
          "correct": 0,
          "explanation": "Chat requires both sending and receiving messages in real-time—bidirectional streaming allows both client and server to send messages independently.",
          "detailedExplanation": "Chat requires both sending and receiving messages in real-time—bidirectional streaming allows both client and server to send messages independently. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "What's a key advantage of gRPC streaming over WebSocket for this use case?",
          "options": [
            "Strong typing and code generation from protobuf",
            "Better browser support",
            "Simpler implementation",
            "Lower latency"
          ],
          "correct": 0,
          "explanation": "gRPC provides strongly-typed messages and generates client/server code from protobuf definitions, reducing bugs and development time.",
          "detailedExplanation": "gRPC provides strongly-typed messages and generates client/server code from protobuf definitions, reducing bugs and development time. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-036",
      "type": "multiple-choice",
      "question": "What is the main limitation of gRPC in web browsers?",
      "options": [
        "Browsers don't support HTTP/2 trailers required by gRPC",
        "Binary data can't be sent from browsers",
        "Browsers don't support HTTP/2",
        "JavaScript can't parse protobuf"
      ],
      "correct": 0,
      "explanation": "gRPC relies on HTTP/2 trailers for metadata, which browsers don't expose to JavaScript. gRPC-Web works around this with a proxy.",
      "detailedExplanation": "gRPC relies on HTTP/2 trailers for metadata, which browsers don't expose to JavaScript. gRPC-Web works around this with a proxy. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-037",
      "type": "multiple-choice",
      "question": "When is gRPC most commonly used?",
      "options": [
        "Service-to-service communication in microservices",
        "Public-facing web APIs",
        "Mobile app to server communication",
        "Browser to server communication"
      ],
      "correct": 0,
      "explanation": "gRPC excels at internal microservice communication where performance matters and both ends can use generated clients. It's less common for public APIs.",
      "detailedExplanation": "gRPC excels at internal microservice communication where performance matters and both ends can use generated clients. It's less common for public APIs. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-038",
      "type": "ordering",
      "question": "Order these API paradigms by typical payload size (smallest to largest):",
      "items": [
        "gRPC (Protocol Buffers)",
        "REST (JSON)",
        "SOAP (XML)",
        "GraphQL (JSON with query)"
      ],
      "correctOrder": [0, 1, 3, 2],
      "explanation": "Protobuf binary is smallest. JSON is compact. GraphQL adds query overhead. SOAP/XML is verbose with tags and namespaces.",
      "detailedExplanation": "Protobuf binary is smallest. JSON is compact. GraphQL adds query overhead. SOAP/XML is verbose with tags and namespaces. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-039",
      "type": "multiple-choice",
      "question": "What is WebSocket?",
      "options": [
        "A protocol for full-duplex communication over a single TCP connection",
        "A REST extension for real-time data",
        "A GraphQL transport",
        "An HTTP/2 feature"
      ],
      "correct": 0,
      "explanation": "WebSocket provides persistent, bidirectional communication between client and server over a single TCP connection, ideal for real-time applications.",
      "detailedExplanation": "WebSocket provides persistent, bidirectional communication between client and server over a single TCP connection, ideal for real-time applications. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "RFC 6455: The WebSocket Protocol",
          "url": "https://www.rfc-editor.org/rfc/rfc6455"
        }
      ]
    },
    {
      "id": "gql-040",
      "type": "multiple-choice",
      "question": "How is a WebSocket connection established?",
      "options": [
        "HTTP upgrade request from HTTP/1.1",
        "Direct TCP connection",
        "Special WebSocket port",
        "HTTP/2 stream"
      ],
      "correct": 0,
      "explanation": "WebSocket starts as an HTTP/1.1 request with an Upgrade header. If the server agrees, the connection upgrades to WebSocket protocol.",
      "detailedExplanation": "WebSocket starts as an HTTP/1.1 request with an Upgrade header. If the server agrees, the connection upgrades to WebSocket protocol. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "RFC 6455: The WebSocket Protocol",
          "url": "https://www.rfc-editor.org/rfc/rfc6455"
        }
      ]
    },
    {
      "id": "gql-041",
      "type": "multi-select",
      "question": "What are good use cases for WebSocket?",
      "options": [
        "Real-time chat",
        "Live sports scores",
        "Collaborative editing",
        "Static content delivery"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "WebSocket is ideal for real-time, bidirectional communication: chat, live updates, collaboration. Static content is better served via HTTP with caching.",
      "detailedExplanation": "WebSocket is ideal for real-time, bidirectional communication: chat, live updates, collaboration. Static content is better served via HTTP with caching. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "RFC 6455: The WebSocket Protocol",
          "url": "https://www.rfc-editor.org/rfc/rfc6455"
        }
      ]
    },
    {
      "id": "gql-042",
      "type": "multiple-choice",
      "question": "What is a disadvantage of WebSocket compared to HTTP?",
      "options": [
        "Harder to scale due to persistent connections",
        "Higher latency",
        "Can't send binary data",
        "No browser support"
      ],
      "correct": 0,
      "explanation": "WebSocket connections are persistent, consuming server resources. Scaling requires connection management, load balancer affinity, and more complex infrastructure.",
      "detailedExplanation": "WebSocket connections are persistent, consuming server resources. Scaling requires connection management, load balancer affinity, and more complex infrastructure. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ]
    },
    {
      "id": "gql-043",
      "type": "two-stage",
      "question": "Your real-time dashboard shows stock prices updating every second.",
      "stages": [
        {
          "question": "Is WebSocket the best choice?",
          "options": [
            "Yes, for continuous bidirectional updates",
            "No, Server-Sent Events would be simpler",
            "No, polling is better",
            "No, gRPC is required"
          ],
          "correct": 1,
          "explanation": "If clients only receive updates (no bidirectional communication needed), SSE is simpler—server pushes updates over a single HTTP connection.",
          "detailedExplanation": "If clients only receive updates (no bidirectional communication needed), SSE is simpler—server pushes updates over a single HTTP connection. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "When would WebSocket be preferred over SSE for this dashboard?",
          "options": [
            "If users can place trades (need to send data back)",
            "If updates are more frequent",
            "If using HTTP/2",
            "Never—SSE is always better for dashboards"
          ],
          "correct": 0,
          "explanation": "If users need to interact (place orders, set alerts), WebSocket's bidirectional nature makes it the better choice.",
          "detailedExplanation": "If users need to interact (place orders, set alerts), WebSocket's bidirectional nature makes it the better choice. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-044",
      "type": "multiple-choice",
      "question": "What is Server-Sent Events (SSE)?",
      "options": [
        "A standard for servers to push updates to clients over HTTP",
        "A WebSocket alternative requiring binary data",
        "A GraphQL subscription protocol",
        "An HTTP/2 push mechanism"
      ],
      "correct": 0,
      "explanation": "SSE is a standard for servers to push text-based updates to clients over a persistent HTTP connection. It's simpler than WebSocket for server-to-client streaming.",
      "detailedExplanation": "SSE is a standard for servers to push text-based updates to clients over a persistent HTTP connection. It's simpler than WebSocket for server-to-client streaming. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "RFC 6455: The WebSocket Protocol",
          "url": "https://www.rfc-editor.org/rfc/rfc6455"
        }
      ]
    },
    {
      "id": "gql-045",
      "type": "multi-select",
      "question": "What are advantages of SSE over WebSocket?",
      "options": [
        "Simpler to implement",
        "Works over standard HTTP",
        "Automatic reconnection built-in",
        "Supports binary data"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "SSE is simpler, uses standard HTTP (works with existing infrastructure), and has built-in reconnection. It only supports text, not binary data.",
      "detailedExplanation": "SSE is simpler, uses standard HTTP (works with existing infrastructure), and has built-in reconnection. It only supports text, not binary data. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "RFC 6455: The WebSocket Protocol",
          "url": "https://www.rfc-editor.org/rfc/rfc6455"
        }
      ]
    },
    {
      "id": "gql-046",
      "type": "multiple-choice",
      "question": "What is the main limitation of Server-Sent Events?",
      "options": [
        "Unidirectional (server to client only)",
        "No browser support",
        "Can't handle multiple event types",
        "Maximum connection time of 30 seconds"
      ],
      "correct": 0,
      "explanation": "SSE only supports server-to-client communication. If clients need to send data back, they must use separate HTTP requests or switch to WebSocket.",
      "detailedExplanation": "SSE only supports server-to-client communication. If clients need to send data back, they must use separate HTTP requests or switch to WebSocket. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "RFC 6455: The WebSocket Protocol",
          "url": "https://www.rfc-editor.org/rfc/rfc6455"
        }
      ]
    },
    {
      "id": "gql-047",
      "type": "ordering",
      "question": "Order these technologies by connection overhead (lowest to highest for frequent small updates):",
      "items": [
        "WebSocket (persistent connection)",
        "SSE (persistent connection)",
        "HTTP polling",
        "HTTP long polling"
      ],
      "correctOrder": [0, 1, 3, 2],
      "explanation": "WebSocket and SSE have lowest overhead (persistent connections). Long polling reopens less often than regular polling, which creates a new connection each time.",
      "detailedExplanation": "WebSocket and SSE have lowest overhead (persistent connections). Long polling reopens less often than regular polling, which creates a new connection each time. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "RFC 6455: The WebSocket Protocol",
          "url": "https://www.rfc-editor.org/rfc/rfc6455"
        }
      ]
    },
    {
      "id": "gql-048",
      "type": "multiple-choice",
      "question": "What is a webhook?",
      "options": [
        "A callback URL that receives HTTP requests when events occur",
        "A WebSocket endpoint",
        "A GraphQL subscription",
        "A scheduled API call"
      ],
      "correct": 0,
      "explanation": "Webhooks are user-defined HTTP callbacks. When an event occurs, the source makes an HTTP request to your specified URL, pushing data to you.",
      "detailedExplanation": "Webhooks are user-defined HTTP callbacks. When an event occurs, the source makes an HTTP request to your specified URL, pushing data to you. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ]
    },
    {
      "id": "gql-049",
      "type": "two-stage",
      "question": "You're integrating with a payment provider that offers both polling and webhooks.",
      "stages": [
        {
          "question": "Which approach is more efficient for detecting payment completion?",
          "options": [
            "Webhooks—provider pushes notification when payment completes",
            "Polling—check status every few seconds",
            "Long polling—wait for response",
            "WebSocket connection to provider"
          ],
          "correct": 0,
          "explanation": "Webhooks eliminate unnecessary polling requests. The provider notifies you immediately when the payment status changes.",
          "detailedExplanation": "Webhooks eliminate unnecessary polling requests. The provider notifies you immediately when the payment status changes. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "Why might you still implement polling as a backup?",
          "options": [
            "Webhooks can fail or be missed",
            "Webhooks are slower",
            "Polling is more secure",
            "Providers require both"
          ],
          "correct": 0,
          "explanation": "Webhooks can fail due to network issues, your server being down, or provider problems. Polling provides a fallback to catch missed events.",
          "detailedExplanation": "Webhooks can fail due to network issues, your server being down, or provider problems. Polling provides a fallback to catch missed events. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-050",
      "type": "multi-select",
      "question": "What security considerations apply to webhook endpoints?",
      "options": [
        "Verify webhook signatures",
        "Use HTTPS",
        "Validate payload structure",
        "Allow any source IP"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "Verify signatures to confirm the sender, use HTTPS for encryption, validate payloads to prevent attacks. Don't allow arbitrary IPs—validate the source.",
      "detailedExplanation": "Verify signatures to confirm the sender, use HTTPS for encryption, validate payloads to prevent attacks. Don't allow arbitrary IPs—validate the source. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-051",
      "type": "multiple-choice",
      "question": "How do webhook providers typically authenticate their requests?",
      "options": [
        "HMAC signature in headers using a shared secret",
        "OAuth tokens",
        "API keys in the URL",
        "Client certificates"
      ],
      "correct": 0,
      "explanation": "Most providers sign webhooks with HMAC using a shared secret. You verify the signature matches the payload to confirm it's authentic.",
      "detailedExplanation": "Most providers sign webhooks with HMAC using a shared secret. You verify the signature matches the payload to confirm it's authentic. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-052",
      "type": "ordering",
      "question": "Order these webhook processing steps:",
      "items": [
        "Receive HTTP request",
        "Verify signature",
        "Return 200 OK quickly",
        "Process payload asynchronously"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Receive the request, verify authenticity, return 200 quickly (before timeout), then process asynchronously. Slow processing can cause retries.",
      "detailedExplanation": "Receive the request, verify authenticity, return 200 quickly (before timeout), then process asynchronously. Slow processing can cause retries. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-053",
      "type": "multiple-choice",
      "question": "Why should webhook handlers return 200 OK quickly?",
      "options": [
        "Providers retry on timeout, causing duplicate processing",
        "HTTP connections time out",
        "It's required by the webhook specification",
        "To free up server resources"
      ],
      "correct": 0,
      "explanation": "If your handler takes too long, the provider may time out and retry, causing duplicate webhook deliveries. Acknowledge quickly, process asynchronously.",
      "detailedExplanation": "If your handler takes too long, the provider may time out and retry, causing duplicate webhook deliveries. Acknowledge quickly, process asynchronously. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ]
    },
    {
      "id": "gql-054",
      "type": "multi-select",
      "question": "How should you handle webhook failures on your end?",
      "options": [
        "Implement idempotent processing",
        "Store events for replay",
        "Log all received webhooks",
        "Ignore duplicates silently"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "Idempotency handles retries safely, storing events enables replay after fixes, logging aids debugging. Don't silently ignore—log duplicates for visibility.",
      "detailedExplanation": "Idempotency handles retries safely, storing events enables replay after fixes, logging aids debugging. Don't silently ignore—log duplicates for visibility. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-055",
      "type": "multiple-choice",
      "question": "What is JSON-RPC?",
      "options": [
        "A stateless, lightweight remote procedure call protocol using JSON",
        "A JSON-based REST alternative",
        "A GraphQL transport",
        "A WebSocket subprotocol"
      ],
      "correct": 0,
      "explanation": "JSON-RPC is a simple RPC protocol that uses JSON for encoding. Requests specify method names and parameters; responses contain results or errors.",
      "detailedExplanation": "JSON-RPC is a simple RPC protocol that uses JSON for encoding. Requests specify method names and parameters; responses contain results or errors. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-056",
      "type": "multiple-choice",
      "question": "How does JSON-RPC differ from REST?",
      "options": [
        "JSON-RPC uses method names instead of HTTP verbs and URLs",
        "JSON-RPC uses XML instead of JSON",
        "REST is for internal APIs only",
        "JSON-RPC requires WebSocket"
      ],
      "correct": 0,
      "explanation": "REST uses HTTP methods and resource URLs. JSON-RPC uses a single endpoint where the method name is in the request body, similar to function calls.",
      "detailedExplanation": "REST uses HTTP methods and resource URLs. JSON-RPC uses a single endpoint where the method name is in the request body, similar to function calls. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-057",
      "type": "two-stage",
      "question": "Consider this JSON-RPC request:",
      "context": "{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"getUser\",\n  \"params\": {\"id\": 123},\n  \"id\": 1\n}",
      "stages": [
        {
          "question": "What does the 'id' field represent?",
          "options": [
            "Request identifier for matching responses",
            "User ID being requested",
            "API version",
            "Session identifier"
          ],
          "correct": 0,
          "explanation": "The 'id' field identifies the request so responses can be matched to requests, especially important for batch requests.",
          "detailedExplanation": "The 'id' field identifies the request so responses can be matched to requests, especially important for batch requests. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "What happens if 'id' is omitted?",
          "options": [
            "It becomes a notification (no response expected)",
            "The request fails",
            "Server assigns an ID",
            "Default ID of 0 is used"
          ],
          "correct": 0,
          "explanation": "Omitting 'id' makes it a notification—the server processes it but doesn't send a response. Useful for fire-and-forget operations.",
          "detailedExplanation": "Omitting 'id' makes it a notification—the server processes it but doesn't send a response. Useful for fire-and-forget operations. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-058",
      "type": "multiple-choice",
      "question": "What API paradigm is commonly used for blockchain/Ethereum nodes?",
      "options": ["JSON-RPC", "GraphQL", "gRPC", "REST"],
      "correct": 0,
      "explanation": "Ethereum and many blockchain nodes use JSON-RPC for their APIs, allowing clients to call methods like eth_getBalance, eth_sendTransaction, etc.",
      "detailedExplanation": "Ethereum and many blockchain nodes use JSON-RPC for their APIs, allowing clients to call methods like eth_getBalance, eth_sendTransaction, etc. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-059",
      "type": "ordering",
      "question": "Order these API styles from most to least structured/typed:",
      "items": [
        "gRPC with Protocol Buffers",
        "GraphQL with SDL",
        "REST with OpenAPI spec",
        "REST without formal schema"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "gRPC has the strictest typing (compiled protobuf). GraphQL SDL is strongly typed. OpenAPI adds structure to REST. Unspecified REST has no formal contract.",
      "detailedExplanation": "gRPC has the strictest typing (compiled protobuf). GraphQL SDL is strongly typed. OpenAPI adds structure to REST. Unspecified REST has no formal contract. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-060",
      "type": "two-stage",
      "question": "You're building a public API for third-party developers.",
      "stages": [
        {
          "question": "Which API style is typically easiest for developers to get started with?",
          "options": ["REST with JSON", "GraphQL", "gRPC", "JSON-RPC"],
          "correct": 0,
          "explanation": "REST with JSON is ubiquitous—developers can test with curl, Postman, or any HTTP client without special tooling or learning new concepts.",
          "detailedExplanation": "REST with JSON is ubiquitous—developers can test with curl, Postman, or any HTTP client without special tooling or learning new concepts. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "When might GraphQL be a better choice for a public API?",
          "options": [
            "When clients need flexibility in data fetching",
            "When you need maximum performance",
            "When clients are all mobile apps",
            "When simplicity is the top priority"
          ],
          "correct": 0,
          "explanation": "GraphQL shines when different clients need different data shapes. Mobile might need minimal data; web dashboards might need comprehensive data.",
          "detailedExplanation": "GraphQL shines when different clients need different data shapes. Mobile might need minimal data; web dashboards might need comprehensive data. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-061",
      "type": "multi-select",
      "question": "When is gRPC a better choice than REST?",
      "options": [
        "High-performance internal services",
        "Strict typing is critical",
        "Bidirectional streaming is needed",
        "Public API for web browsers"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "gRPC excels at internal service communication, strong typing, and streaming. Browser support requires gRPC-Web proxy, making REST simpler for web APIs.",
      "detailedExplanation": "gRPC excels at internal service communication, strong typing, and streaming. Browser support requires gRPC-Web proxy, making REST simpler for web APIs. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-062",
      "type": "multiple-choice",
      "question": "What is HATEOAS in REST?",
      "options": [
        "Hypermedia links in responses that guide clients to related actions",
        "A security framework",
        "An HTTP header standard",
        "A caching strategy"
      ],
      "correct": 0,
      "explanation": "HATEOAS (Hypermedia as the Engine of Application State) means responses include links to related resources/actions, allowing clients to discover the API dynamically.",
      "detailedExplanation": "HATEOAS (Hypermedia as the Engine of Application State) means responses include links to related resources/actions, allowing clients to discover the API dynamically. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-063",
      "type": "multiple-choice",
      "question": "Why is HATEOAS rarely implemented in practice?",
      "options": [
        "Adds complexity with limited practical benefit for most APIs",
        "Browser don't support it",
        "It's deprecated",
        "Performance overhead is too high"
      ],
      "correct": 0,
      "explanation": "HATEOAS adds response complexity and most clients don't use dynamic link discovery—they hardcode endpoints. The theoretical benefits rarely justify the overhead.",
      "detailedExplanation": "HATEOAS adds response complexity and most clients don't use dynamic link discovery—they hardcode endpoints. The theoretical benefits rarely justify the overhead. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-064",
      "type": "two-stage",
      "question": "You're designing an API for IoT devices with limited bandwidth and processing power.",
      "stages": [
        {
          "question": "Which API style would be most efficient?",
          "options": [
            "gRPC with Protocol Buffers",
            "REST with JSON",
            "GraphQL",
            "SOAP"
          ],
          "correct": 0,
          "explanation": "gRPC's binary protocol (protobuf) has minimal overhead—smaller payloads and faster parsing than text-based formats, ideal for constrained devices.",
          "detailedExplanation": "gRPC's binary protocol (protobuf) has minimal overhead—smaller payloads and faster parsing than text-based formats, ideal for constrained devices. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "What if the devices can only use HTTP/1.1?",
          "options": [
            "REST with compressed JSON would be more practical",
            "gRPC still works fine",
            "WebSocket is required",
            "Use MQTT instead"
          ],
          "correct": 0,
          "explanation": "gRPC requires HTTP/2. If limited to HTTP/1.1, REST with gzip compression is a practical alternative. MQTT is also worth considering for IoT.",
          "detailedExplanation": "gRPC requires HTTP/2. If limited to HTTP/1.1, REST with gzip compression is a practical alternative. MQTT is also worth considering for IoT. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        }
      ]
    },
    {
      "id": "gql-065",
      "type": "multiple-choice",
      "question": "What is MQTT commonly used for?",
      "options": [
        "Lightweight messaging for IoT devices",
        "Microservice communication",
        "Browser real-time updates",
        "Database replication"
      ],
      "correct": 0,
      "explanation": "MQTT is a lightweight publish-subscribe messaging protocol designed for constrained devices and unreliable networks, common in IoT applications.",
      "detailedExplanation": "MQTT is a lightweight publish-subscribe messaging protocol designed for constrained devices and unreliable networks, common in IoT applications. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-066",
      "type": "ordering",
      "question": "Order these protocols by typical bandwidth efficiency (most to least efficient):",
      "items": [
        "MQTT",
        "gRPC/Protobuf",
        "WebSocket with JSON",
        "REST with JSON"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "MQTT is designed for minimal overhead. Protobuf is compact binary. WebSocket avoids HTTP overhead per message. REST has full HTTP headers per request.",
      "detailedExplanation": "MQTT is designed for minimal overhead. Protobuf is compact binary. WebSocket avoids HTTP overhead per message. REST has full HTTP headers per request. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        }
      ]
    },
    {
      "id": "gql-067",
      "type": "multiple-choice",
      "question": "What is OpenAPI (formerly Swagger)?",
      "options": [
        "A specification for describing REST APIs",
        "A GraphQL alternative",
        "An API gateway",
        "A testing framework"
      ],
      "correct": 0,
      "explanation": "OpenAPI is a specification language for describing REST APIs—endpoints, parameters, responses, authentication. It enables documentation and code generation.",
      "detailedExplanation": "OpenAPI is a specification language for describing REST APIs—endpoints, parameters, responses, authentication. It enables documentation and code generation. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-068",
      "type": "multi-select",
      "question": "What can be generated from an OpenAPI specification?",
      "options": [
        "API documentation",
        "Client SDKs",
        "Server stubs",
        "Database schemas"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "OpenAPI specs can generate interactive docs, client libraries in various languages, and server code stubs. Database schemas require separate tools.",
      "detailedExplanation": "OpenAPI specs can generate interactive docs, client libraries in various languages, and server code stubs. Database schemas require separate tools. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-069",
      "type": "two-stage",
      "question": "Your team debates between GraphQL and REST for a new API.",
      "stages": [
        {
          "question": "GraphQL would be advantageous if:",
          "options": [
            "Clients have varying data requirements",
            "The API is very simple with few resources",
            "HTTP caching is critical",
            "Team has no GraphQL experience"
          ],
          "correct": 0,
          "explanation": "GraphQL's flexibility benefits scenarios where different clients (mobile, web, third-party) need different data shapes from the same backend.",
          "detailedExplanation": "GraphQL's flexibility benefits scenarios where different clients (mobile, web, third-party) need different data shapes from the same backend. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "REST would be advantageous if:",
          "options": [
            "HTTP caching and simplicity are priorities",
            "Complex nested data is common",
            "Real-time updates are needed",
            "Clients need maximum flexibility"
          ],
          "correct": 0,
          "explanation": "REST leverages HTTP caching naturally, has a gentler learning curve, and is simpler when data access patterns are predictable.",
          "detailedExplanation": "REST leverages HTTP caching naturally, has a gentler learning curve, and is simpler when data access patterns are predictable. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-070",
      "type": "multiple-choice",
      "question": "What is a BFF (Backend for Frontend)?",
      "options": [
        "A backend service tailored to a specific client's needs",
        "A firewall for APIs",
        "A frontend testing tool",
        "A browser caching mechanism"
      ],
      "correct": 0,
      "explanation": "BFF is an architectural pattern where each client type (web, iOS, Android) has its own backend service that aggregates and shapes data specifically for that client.",
      "detailedExplanation": "BFF is an architectural pattern where each client type (web, iOS, Android) has its own backend service that aggregates and shapes data specifically for that client. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-071",
      "type": "two-stage",
      "question": "Your company has REST APIs but mobile clients complain about over-fetching.",
      "stages": [
        {
          "question": "What architectural approach could help?",
          "options": [
            "Add a GraphQL layer in front of REST services",
            "Rewrite all APIs in gRPC",
            "Add more REST endpoints",
            "Use WebSocket instead"
          ],
          "correct": 0,
          "explanation": "A GraphQL gateway can sit in front of existing REST services, giving clients flexible queries while keeping existing backend services unchanged.",
          "detailedExplanation": "A GraphQL gateway can sit in front of existing REST services, giving clients flexible queries while keeping existing backend services unchanged. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "What's this pattern called?",
          "options": [
            "GraphQL as API gateway / federation",
            "Microservice mesh",
            "REST aggregation",
            "Service proxy"
          ],
          "correct": 0,
          "explanation": "Using GraphQL as a unified API layer over existing services is a common adoption pattern, sometimes called GraphQL federation or API gateway.",
          "detailedExplanation": "Using GraphQL as a unified API layer over existing services is a common adoption pattern, sometimes called GraphQL federation or API gateway. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-072",
      "type": "multi-select",
      "question": "Which scenarios favor real-time push (WebSocket/SSE) over polling?",
      "options": [
        "Updates occur frequently",
        "Immediate notification is important",
        "Many clients are connected",
        "Updates are rare and unpredictable"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Push is better for frequent updates, time-sensitive notifications, and unpredictable events. With many clients, push scales better than all polling simultaneously.",
      "detailedExplanation": "Push is better for frequent updates, time-sensitive notifications, and unpredictable events. With many clients, push scales better than all polling simultaneously. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "RFC 6455: The WebSocket Protocol",
          "url": "https://www.rfc-editor.org/rfc/rfc6455"
        }
      ]
    },
    {
      "id": "gql-073",
      "type": "multiple-choice",
      "question": "When might polling be preferred over WebSocket?",
      "options": [
        "When updates are infrequent and latency isn't critical",
        "When real-time updates are essential",
        "When bandwidth is limited",
        "When the client is a mobile app"
      ],
      "correct": 0,
      "explanation": "For infrequent updates where a few seconds delay is acceptable, polling is simpler—no connection management, works with standard HTTP infrastructure.",
      "detailedExplanation": "For infrequent updates where a few seconds delay is acceptable, polling is simpler—no connection management, works with standard HTTP infrastructure. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "RFC 6455: The WebSocket Protocol",
          "url": "https://www.rfc-editor.org/rfc/rfc6455"
        }
      ]
    },
    {
      "id": "gql-074",
      "type": "two-stage",
      "question": "Your notification service needs to support 1 million connected users.",
      "stages": [
        {
          "question": "What's the main scaling challenge with WebSocket?",
          "options": [
            "Each connection consumes server memory/resources",
            "WebSocket has a connection limit of 65535",
            "Browsers limit WebSocket connections",
            "WebSocket doesn't support clustering"
          ],
          "correct": 0,
          "explanation": "Each persistent WebSocket connection uses server memory and file descriptors. A million connections requires significant infrastructure.",
          "detailedExplanation": "Each persistent WebSocket connection uses server memory and file descriptors. A million connections requires significant infrastructure. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "What architectural pattern helps scale WebSocket servers?",
          "options": [
            "Pub/sub with message broker (Redis, Kafka)",
            "Increase server memory",
            "Use HTTP/3 instead",
            "Client-side connection pooling"
          ],
          "correct": 0,
          "explanation": "A pub/sub system lets multiple WebSocket servers subscribe to events. When a notification occurs, it's published to all servers that have relevant connected clients.",
          "detailedExplanation": "A pub/sub system lets multiple WebSocket servers subscribe to events. When a notification occurs, it's published to all servers that have relevant connected clients. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-075",
      "type": "multiple-choice",
      "question": "What does 'API-first' design mean?",
      "options": [
        "Designing the API contract before implementation",
        "APIs are more important than the UI",
        "Using APIs instead of direct database access",
        "Building APIs before the frontend"
      ],
      "correct": 0,
      "explanation": "API-first means defining the API contract (endpoints, schemas, behaviors) before writing code. This enables parallel frontend/backend development and better design.",
      "detailedExplanation": "API-first means defining the API contract (endpoints, schemas, behaviors) before writing code. This enables parallel frontend/backend development and better design. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-076",
      "type": "ordering",
      "question": "Order these API design approaches from most to least formal contract:",
      "items": [
        "Design-first with OpenAPI/protobuf",
        "Code-first with generated docs",
        "Informal documentation",
        "No documentation"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Design-first creates contracts before code. Code-first generates specs from implementation. Informal docs are manual. No docs means no contract.",
      "detailedExplanation": "Design-first creates contracts before code. Code-first generates specs from implementation. Informal docs are manual. No docs means no contract. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-077",
      "type": "multiple-choice",
      "question": "What is contract testing for APIs?",
      "options": [
        "Verifying that client and server agree on the API contract",
        "Testing API performance under load",
        "Validating request/response formats",
        "Testing authentication mechanisms"
      ],
      "correct": 0,
      "explanation": "Contract testing verifies both consumer and provider implementations match the agreed API contract, catching integration issues before deployment.",
      "detailedExplanation": "Contract testing verifies both consumer and provider implementations match the agreed API contract, catching integration issues before deployment. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ]
    },
    {
      "id": "gql-078",
      "type": "multi-select",
      "question": "What tools are commonly used for API contract testing?",
      "options": [
        "Pact",
        "Postman contract tests",
        "OpenAPI validators",
        "Jest"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "Pact is purpose-built for contract testing. Postman supports contract tests. OpenAPI validators check compliance. Jest is a general testing framework, not contract-specific.",
      "detailedExplanation": "Pact is purpose-built for contract testing. Postman supports contract tests. OpenAPI validators check compliance. Jest is a general testing framework, not contract-specific. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-079",
      "type": "two-stage",
      "question": "Team A's service calls Team B's API. Team B wants to change a response field.",
      "stages": [
        {
          "question": "How can contract testing help?",
          "options": [
            "Team A's tests would fail, alerting to the breaking change",
            "It automatically updates Team A's code",
            "It prevents Team B from deploying",
            "It notifies Team A via email"
          ],
          "correct": 0,
          "explanation": "Contract tests run against both provider and consumer. If Team B's change breaks the contract, tests fail before the change reaches production.",
          "detailedExplanation": "Contract tests run against both provider and consumer. If Team B's change breaks the contract, tests fail before the change reaches production. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "What's the recommended workflow?",
          "options": [
            "Team B updates contract, both teams update implementations, then deploy",
            "Team B deploys, Team A adapts",
            "Teams never change contracts",
            "Use feature flags to toggle behavior"
          ],
          "correct": 0,
          "explanation": "Coordinate contract changes: update the contract spec, both teams implement changes, verify with contract tests, then deploy in appropriate order.",
          "detailedExplanation": "Coordinate contract changes: update the contract spec, both teams implement changes, verify with contract tests, then deploy in appropriate order. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-080",
      "type": "multiple-choice",
      "question": "What is an API gateway?",
      "options": [
        "A server that acts as a single entry point for multiple backend services",
        "A database for storing API definitions",
        "A tool for generating API documentation",
        "A testing framework for APIs"
      ],
      "correct": 0,
      "explanation": "An API gateway routes requests to appropriate backend services, handling cross-cutting concerns like authentication, rate limiting, and request transformation.",
      "detailedExplanation": "An API gateway routes requests to appropriate backend services, handling cross-cutting concerns like authentication, rate limiting, and request transformation. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-081",
      "type": "multi-select",
      "question": "What responsibilities do API gateways commonly handle?",
      "options": [
        "Authentication and authorization",
        "Rate limiting",
        "Request routing",
        "Business logic execution"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "Gateways handle auth, rate limiting, routing, logging, and transformation. Business logic should remain in backend services, not the gateway.",
      "detailedExplanation": "Gateways handle auth, rate limiting, routing, logging, and transformation. Business logic should remain in backend services, not the gateway. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-082",
      "type": "two-stage",
      "question": "You're adding a GraphQL layer to existing microservices.",
      "stages": [
        {
          "question": "Where should the GraphQL server sit architecturally?",
          "options": [
            "As an API gateway/aggregation layer",
            "Inside each microservice",
            "In the client application",
            "In the database layer"
          ],
          "correct": 0,
          "explanation": "GraphQL typically acts as an aggregation layer, sitting between clients and microservices, combining data from multiple services into unified responses.",
          "detailedExplanation": "GraphQL typically acts as an aggregation layer, sitting between clients and microservices, combining data from multiple services into unified responses. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "What's a risk of this approach?",
          "options": [
            "GraphQL layer becomes a bottleneck/single point of failure",
            "Microservices must be rewritten",
            "Clients can't use REST anymore",
            "Database queries become slower"
          ],
          "correct": 0,
          "explanation": "The GraphQL layer handles all requests, making it a potential bottleneck. It needs proper scaling, caching, and fault tolerance.",
          "detailedExplanation": "The GraphQL layer handles all requests, making it a potential bottleneck. It needs proper scaling, caching, and fault tolerance. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-083",
      "type": "multiple-choice",
      "question": "What is schema stitching in GraphQL?",
      "options": [
        "Combining multiple GraphQL schemas into one",
        "Validating schema syntax",
        "Converting REST to GraphQL schemas",
        "Versioning GraphQL schemas"
      ],
      "correct": 0,
      "explanation": "Schema stitching combines multiple GraphQL schemas (from different services) into a single unified schema that clients can query as one API.",
      "detailedExplanation": "Schema stitching combines multiple GraphQL schemas (from different services) into a single unified schema that clients can query as one API. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-084",
      "type": "multiple-choice",
      "question": "How does Apollo Federation differ from schema stitching?",
      "options": [
        "Federation is declarative; services define how they extend the graph",
        "Federation is older technology",
        "Schema stitching supports subscriptions, Federation doesn't",
        "They are the same thing"
      ],
      "correct": 0,
      "explanation": "Federation lets each service declare which types it owns and how it extends other types. Schema stitching requires central configuration. Federation is more scalable.",
      "detailedExplanation": "Federation lets each service declare which types it owns and how it extends other types. Schema stitching requires central configuration. Federation is more scalable. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-085",
      "type": "multi-select",
      "question": "What are benefits of Apollo Federation?",
      "options": [
        "Services can be deployed independently",
        "Each team owns their part of the schema",
        "Unified schema for clients",
        "Eliminates need for API versioning"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "Federation enables independent deployment, team ownership, and unified schemas. Versioning is still needed for breaking changes, though less often with schema evolution.",
      "detailedExplanation": "Federation enables independent deployment, team ownership, and unified schemas. Versioning is still needed for breaking changes, though less often with schema evolution. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-086",
      "type": "ordering",
      "question": "Order these from simplest to most sophisticated GraphQL architecture:",
      "items": [
        "Single GraphQL server",
        "GraphQL as BFF",
        "Schema stitching",
        "Apollo Federation"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Single server is simplest. BFF adds client-specific layers. Schema stitching combines schemas centrally. Federation is fully distributed with declarative composition.",
      "detailedExplanation": "Single server is simplest. BFF adds client-specific layers. Schema stitching combines schemas centrally. Federation is fully distributed with declarative composition. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-087",
      "type": "two-stage",
      "question": "Your GraphQL API is experiencing slow response times for complex queries.",
      "stages": [
        {
          "question": "What's a likely cause?",
          "options": [
            "N+1 query problem in resolvers",
            "GraphQL parsing overhead",
            "Network latency",
            "Schema too large"
          ],
          "correct": 0,
          "explanation": "Complex queries with nested relationships often trigger N+1 database queries when resolvers fetch related data individually.",
          "detailedExplanation": "Complex queries with nested relationships often trigger N+1 database queries when resolvers fetch related data individually. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "After implementing DataLoader, queries are still slow. What else should you check?",
          "options": [
            "Query complexity and depth limits",
            "Use more fragments",
            "Increase server memory",
            "Switch to REST"
          ],
          "correct": 0,
          "explanation": "Even with batching, deeply nested or overly complex queries can be expensive. Implement complexity analysis and depth limits.",
          "detailedExplanation": "Even with batching, deeply nested or overly complex queries can be expensive. Implement complexity analysis and depth limits. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-088",
      "type": "multiple-choice",
      "question": "How do you implement pagination in GraphQL?",
      "options": [
        "Cursor-based pagination with connections spec",
        "Page numbers in query",
        "Limit/offset arguments",
        "Any approach—GraphQL doesn't specify"
      ],
      "correct": 3,
      "explanation": "GraphQL doesn't mandate pagination style. Cursor-based (Relay connection spec) is recommended for consistency, but limit/offset works. Choose based on needs.",
      "detailedExplanation": "GraphQL doesn't mandate pagination style. Cursor-based (Relay connection spec) is recommended for consistency, but limit/offset works. Choose based on needs. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "gql-089",
      "type": "multi-select",
      "question": "What does the Relay connection specification define?",
      "options": [
        "edges and nodes for list items",
        "pageInfo for pagination metadata",
        "cursor field for position",
        "totalCount (optional)"
      ],
      "correctIndices": [0, 1, 2, 3],
      "explanation": "Relay spec defines edges (containing nodes and cursors), pageInfo (hasNextPage, etc.), and optionally totalCount for standardized pagination.",
      "detailedExplanation": "Relay spec defines edges (containing nodes and cursors), pageInfo (hasNextPage, etc.), and optionally totalCount for standardized pagination. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-090",
      "type": "two-stage",
      "question": "You need to add file upload support to your GraphQL API.",
      "stages": [
        {
          "question": "What's the standard approach?",
          "options": [
            "GraphQL multipart request specification",
            "Base64 encode files in mutations",
            "Separate REST endpoint for uploads",
            "WebSocket file transfer"
          ],
          "correct": 0,
          "explanation": "The GraphQL multipart request spec allows file uploads via multipart/form-data with the GraphQL operation, supported by Apollo and other libraries.",
          "detailedExplanation": "The GraphQL multipart request spec allows file uploads via multipart/form-data with the GraphQL operation, supported by Apollo and other libraries. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "When might a separate upload endpoint be better?",
          "options": [
            "Very large files or need for upload progress",
            "Small image uploads",
            "When using Apollo Client",
            "File uploads are always fine via GraphQL"
          ],
          "correct": 0,
          "explanation": "Large files benefit from dedicated upload endpoints with chunking, progress tracking, and resumability. GraphQL multipart works for smaller files.",
          "detailedExplanation": "Large files benefit from dedicated upload endpoints with chunking, progress tracking, and resumability. GraphQL multipart works for smaller files. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-091",
      "type": "multiple-choice",
      "question": "What is the purpose of GraphQL directives?",
      "options": [
        "Modify query execution or schema behavior",
        "Define custom scalar types",
        "Implement authentication",
        "Create database indexes"
      ],
      "correct": 0,
      "explanation": "Directives (@include, @skip, @deprecated, custom ones) modify how the server processes queries or how schema elements behave.",
      "detailedExplanation": "Directives (@include, @skip, @deprecated, custom ones) modify how the server processes queries or how schema elements behave. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-092",
      "type": "multi-select",
      "question": "What are built-in GraphQL directives?",
      "options": ["@include", "@skip", "@deprecated", "@auth"],
      "correctIndices": [0, 1, 2],
      "explanation": "@include and @skip conditionally include fields. @deprecated marks fields as deprecated. @auth would be a custom directive, not built-in.",
      "detailedExplanation": "@include and @skip conditionally include fields. @deprecated marks fields as deprecated. @auth would be a custom directive, not built-in. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-093",
      "type": "two-stage",
      "question": "You want to implement field-level authorization in GraphQL.",
      "stages": [
        {
          "question": "What's a common approach?",
          "options": [
            "Custom directive like @auth or @hasRole",
            "Check permissions in every resolver",
            "Use HTTP headers only",
            "GraphQL doesn't support authorization"
          ],
          "correct": 0,
          "explanation": "Custom directives provide declarative, reusable authorization. @auth(role: ADMIN) on a field is cleaner than checking in every resolver.",
          "detailedExplanation": "Custom directives provide declarative, reusable authorization. @auth(role: ADMIN) on a field is cleaner than checking in every resolver. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "What library is commonly used for GraphQL authorization?",
          "options": [
            "GraphQL Shield",
            "Passport.js",
            "Auth0 SDK",
            "JWT library"
          ],
          "correct": 0,
          "explanation": "GraphQL Shield provides a permissions layer for GraphQL, letting you define rules declaratively and apply them to your schema.",
          "detailedExplanation": "GraphQL Shield provides a permissions layer for GraphQL, letting you define rules declaratively and apply them to your schema. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-094",
      "type": "ordering",
      "question": "Order these GraphQL client features from basic to advanced:",
      "items": [
        "Simple fetch requests",
        "Dedicated client library",
        "Normalized caching",
        "Optimistic updates"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "You can use fetch directly. Client libraries add conveniences. Normalized caching dedupes data. Optimistic updates show results before server confirms.",
      "detailedExplanation": "You can use fetch directly. Client libraries add conveniences. Normalized caching dedupes data. Optimistic updates show results before server confirms. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-095",
      "type": "multiple-choice",
      "question": "What is normalized caching in GraphQL clients?",
      "options": [
        "Storing entities by ID so updates propagate across queries",
        "Compressing cached responses",
        "LRU cache eviction",
        "Caching at the HTTP level"
      ],
      "correct": 0,
      "explanation": "Normalized caching stores each entity once by its ID. When data updates, all queries referencing that entity automatically see the new data.",
      "detailedExplanation": "Normalized caching stores each entity once by its ID. When data updates, all queries referencing that entity automatically see the new data. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-096",
      "type": "multi-select",
      "question": "Which GraphQL client libraries support normalized caching?",
      "options": ["Apollo Client", "urql", "Relay", "graphql-request"],
      "correctIndices": [0, 1, 2],
      "explanation": "Apollo, urql, and Relay all support normalized caching. graphql-request is a minimal client without caching—just fetch wrapper.",
      "detailedExplanation": "Apollo, urql, and Relay all support normalized caching. graphql-request is a minimal client without caching—just fetch wrapper. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-097",
      "type": "two-stage",
      "question": "Your team is choosing between REST and GraphQL for a new project.",
      "stages": [
        {
          "question": "The project has simple CRUD operations with predictable data needs. Which is better?",
          "options": [
            "REST—simpler for straightforward use cases",
            "GraphQL—always better",
            "gRPC—for any new project",
            "Depends on team experience only"
          ],
          "correct": 0,
          "explanation": "For simple, predictable data access patterns, REST's simplicity, HTTP caching, and lower learning curve make it a pragmatic choice.",
          "detailedExplanation": "For simple, predictable data access patterns, REST's simplicity, HTTP caching, and lower learning curve make it a pragmatic choice. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "What would tip the decision toward GraphQL?",
          "options": [
            "Multiple client platforms with different data needs",
            "Need for HTTP caching",
            "Team is new to GraphQL",
            "Simple read-heavy API"
          ],
          "correct": 0,
          "explanation": "GraphQL shines when web, mobile, and other clients need different data shapes. The flexibility outweighs added complexity.",
          "detailedExplanation": "GraphQL shines when web, mobile, and other clients need different data shapes. The flexibility outweighs added complexity. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-098",
      "type": "multi-select",
      "question": "What factors should influence API paradigm choice?",
      "options": [
        "Client requirements and diversity",
        "Team expertise",
        "Performance requirements",
        "Existing infrastructure"
      ],
      "correctIndices": [0, 1, 2, 3],
      "explanation": "All these matter: client needs drive data access patterns, team skills affect productivity, performance needs may favor gRPC, and existing infrastructure may constrain choices.",
      "detailedExplanation": "All these matter: client needs drive data access patterns, team skills affect productivity, performance needs may favor gRPC, and existing infrastructure may constrain choices. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "gql-099",
      "type": "ordering",
      "question": "For a mobile app needing minimal data transfer, order these by typical efficiency:",
      "items": [
        "gRPC with selective fields",
        "GraphQL requesting only needed fields",
        "REST with sparse fieldsets",
        "REST fetching full resources"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "gRPC's binary format is most compact. GraphQL fetches exact fields. REST sparse fieldsets help but still use JSON. Full REST resources waste bandwidth.",
      "detailedExplanation": "gRPC's binary format is most compact. GraphQL fetches exact fields. REST sparse fieldsets help but still use JSON. Full REST resources waste bandwidth. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        }
      ]
    },
    {
      "id": "gql-100",
      "type": "two-stage",
      "question": "You're designing a system with both public API and internal microservices.",
      "stages": [
        {
          "question": "What's a common pattern for the communication layers?",
          "options": [
            "REST/GraphQL for public API, gRPC for internal services",
            "gRPC everywhere",
            "REST everywhere",
            "GraphQL everywhere"
          ],
          "correct": 0,
          "explanation": "Public APIs often use REST/GraphQL for accessibility. Internal services benefit from gRPC's performance and strong typing.",
          "detailedExplanation": "Public APIs often use REST/GraphQL for accessibility. Internal services benefit from gRPC's performance and strong typing. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "Why use different paradigms for internal vs external?",
          "options": [
            "Different priorities: accessibility vs performance",
            "Security requirements differ",
            "Internal services can't use HTTP",
            "External clients require JSON"
          ],
          "correct": 0,
          "explanation": "External APIs prioritize developer experience and accessibility. Internal APIs can optimize for performance since you control both ends.",
          "detailedExplanation": "External APIs prioritize developer experience and accessibility. Internal APIs can optimize for performance since you control both ends. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    }
  ]
}
