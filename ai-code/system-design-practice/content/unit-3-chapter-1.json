{
  "unit": 3,
  "unitTitle": "API Design",
  "chapter": 1,
  "chapterTitle": "REST Fundamentals",
  "chapterDescription": "HTTP methods, status codes, resource naming, and idempotency.",
  "problems": [
    {
      "id": "rest-001",
      "type": "multiple-choice",
      "question": "Which HTTP method should you use to create a new resource when the server assigns the ID?",
      "options": ["GET", "POST", "PUT", "PATCH"],
      "correct": 1,
      "explanation": "POST is used to create a resource when the server determines the URI. PUT is used when the client specifies the full URI of the resource being created or replaced.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-002",
      "type": "multiple-choice",
      "question": "Which HTTP method is idempotent but NOT safe?",
      "options": ["GET", "POST", "PUT", "HEAD"],
      "correct": 2,
      "explanation": "PUT is idempotent (repeating it produces the same result) but not safe (it modifies server state). GET and HEAD are both safe and idempotent. POST is neither safe nor idempotent.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Discard options that weaken contract clarity or compatibility over time. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-003",
      "type": "multi-select",
      "question": "Which HTTP methods are idempotent?",
      "options": ["GET", "POST", "PUT", "DELETE"],
      "correctIndices": [0, 2, 3],
      "explanation": "GET, PUT, and DELETE are idempotent — repeating them has the same effect as a single call. POST is not idempotent; each call may create a new resource.",
      "detailedExplanation": "In interviews and real systems work, begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Anchor decisions in explicit constraints, invariants, and observable failure signals rather than intuition. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-004",
      "type": "multiple-choice",
      "question": "A client sends DELETE /users/42 twice. What should the second response be?",
      "options": [
        "200 OK with the deleted user",
        "204 No Content",
        "404 Not Found",
        "Either 204 or 404 — both are valid"
      ],
      "correct": 3,
      "explanation": "Both are valid REST implementations. Some APIs return 204 on repeated deletes (emphasizing idempotency of effect), others return 404 (the resource no longer exists). The key is that server state is the same either way.",
      "detailedExplanation": "In interviews and real systems work, anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Discard options that weaken contract clarity or compatibility over time. Prioritize explicit semantics and upgrade safety, not just short-term convenience. If values like 42 and 204 appear, convert them into one unit basis before comparison. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-005",
      "type": "multiple-choice",
      "question": "What's the difference between PUT and PATCH?",
      "options": [
        "PUT creates, PATCH updates",
        "PUT replaces the entire resource, PATCH applies a partial update",
        "PUT is idempotent, PATCH is not",
        "There is no practical difference"
      ],
      "correct": 1,
      "explanation": "PUT replaces the entire resource representation. PATCH applies a partial modification. Both can be used for updates, but PUT requires sending the complete resource while PATCH only requires the changed fields.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Prefer the approach that keeps client behavior explicit while preserving evolvability. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-007",
      "type": "multiple-choice",
      "question": "A POST request kicks off a long-running job. Which status code is most appropriate?",
      "options": ["200 OK", "201 Created", "202 Accepted", "204 No Content"],
      "correct": 2,
      "explanation": "202 Accepted means the request has been accepted for processing but is not yet complete. The client can poll for status later. 201 would imply the resource is already created.",
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Discard options that weaken contract clarity or compatibility over time. Good API choices balance client ergonomics, compatibility, and long-term evolvability. If values like 202 and 201 appear, convert them into one unit basis before comparison. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-008",
      "type": "ordering",
      "question": "Rank these status codes from most to least specific for a 'validation error on input data':",
      "items": [
        "400 Bad Request",
        "422 Unprocessable Entity",
        "500 Internal Server Error"
      ],
      "correctOrder": [1, 0, 2],
      "explanation": "422 is most specific (syntactically valid but semantically invalid input). 400 is broader (malformed request). 500 is wrong — validation errors are client errors, not server errors.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Build the rank from biggest differences first, then refine with adjacent checks. Interface decisions should be justified by contract stability and client impact over time. Keep quantities like 422 and 400 in aligned units before deciding on an implementation approach. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-009",
      "type": "multiple-choice",
      "question": "A request arrives without valid auth credentials. Which HTTP status should the API return?",
      "options": [
        "The resource doesn't exist",
        "The request is forbidden",
        "Authentication is required",
        "The method is not allowed"
      ],
      "correct": 2,
      "explanation": "401 Unauthorized actually means 'unauthenticated' — the client hasn't provided valid credentials. 403 Forbidden means authenticated but not authorized. The naming is a well-known misnomer in HTTP.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Discard options that weaken contract clarity or compatibility over time. Good API choices balance client ergonomics, compatibility, and long-term evolvability. If values like 401 and 403 appear, convert them into one unit basis before comparison. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-010",
      "type": "multiple-choice",
      "question": "What's the difference between 401 and 403?",
      "options": [
        "401 is for GET, 403 is for POST",
        "401 means not authenticated, 403 means authenticated but not authorized",
        "401 is temporary, 403 is permanent",
        "They are interchangeable"
      ],
      "correct": 1,
      "explanation": "401 means the server doesn't know who you are (missing or invalid credentials). 403 means the server knows who you are but you don't have permission. Logging in can fix a 401; a 403 requires different permissions.",
      "detailedExplanation": "In interviews and real systems work, begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Keep quantities like 401 and 403 in aligned units before deciding on an implementation approach. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-011",
      "type": "multi-select",
      "question": "Which are client error status codes (4xx)?",
      "options": [
        "400 Bad Request",
        "404 Not Found",
        "409 Conflict",
        "503 Service Unavailable"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "400, 404, and 409 are all 4xx client errors. 503 is a 5xx server error indicating the server is temporarily unavailable.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Validate each proposed control independently and avoid partially true claims that fail under realistic load. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Keep quantities like 400 and 404 in aligned units before deciding on an implementation approach. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-012",
      "type": "multiple-choice",
      "question": "Which status code is most appropriate when a client tries to create a resource that already exists?",
      "options": [
        "400 Bad Request",
        "403 Forbidden",
        "409 Conflict",
        "422 Unprocessable Entity"
      ],
      "correct": 2,
      "explanation": "409 Conflict indicates the request conflicts with the current state of the server — a duplicate resource is a state conflict. 400 is too vague, 422 is for validation errors, 403 is for permissions.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Numbers such as 409 and 400 should be normalized first so downstream reasoning stays consistent. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-013",
      "type": "multiple-choice",
      "question": "Which URI follows REST naming conventions?",
      "options": [
        "GET /getUsers",
        "GET /users",
        "GET /user/list",
        "GET /api/fetchAllUsers"
      ],
      "correct": 1,
      "explanation": "REST uses nouns (not verbs) for resource URIs, and plural forms for collections. The HTTP method (GET) already implies the action, so 'getUsers' and 'fetchAllUsers' are redundant.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Discard options that weaken contract clarity or compatibility over time. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-014",
      "type": "multiple-choice",
      "question": "Which URI best represents a specific user's orders?",
      "options": [
        "/orders?userId=42",
        "/users/42/orders",
        "/getUserOrders/42",
        "/users/orders/42"
      ],
      "correct": 1,
      "explanation": "Nested resources use the pattern /parent/{id}/child. /users/42/orders clearly expresses 'orders belonging to user 42'. Query params work but don't express the hierarchy as cleanly.",
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Good API choices balance client ergonomics, compatibility, and long-term evolvability. If values like 42 appear, convert them into one unit basis before comparison. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-015",
      "type": "multi-select",
      "question": "Which URIs follow REST naming conventions?",
      "options": [
        "GET /users/42",
        "POST /users/create",
        "DELETE /users/42",
        "PUT /users/42/update"
      ],
      "correctIndices": [0, 2],
      "explanation": "GET /users/42 and DELETE /users/42 follow REST conventions — the HTTP method implies the action. /users/create and /users/42/update embed verbs in the URI, which is an RPC pattern, not REST.",
      "detailedExplanation": "Generalize from uRIs follow REST naming conventions to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Evaluate each candidate approach independently under the same constraints. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Numbers such as 42 should be normalized first so downstream reasoning stays consistent. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-016",
      "type": "multiple-choice",
      "question": "Should REST URIs use plural or singular nouns?",
      "options": [
        "Always singular (/user/42)",
        "Always plural (/users/42)",
        "Plural for collections, singular for items",
        "It doesn't matter as long as you're consistent"
      ],
      "correct": 1,
      "explanation": "Convention is to always use plural nouns: /users for the collection and /users/42 for a specific item. This keeps URIs consistent — you don't need to know whether you're addressing a collection or item to know the base path.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Discard options that weaken contract clarity or compatibility over time. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Numbers such as 42 should be normalized first so downstream reasoning stays consistent. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-017",
      "type": "multiple-choice",
      "question": "A client needs to transfer funds between two bank accounts. Which approach is most RESTful?",
      "options": [
        "POST /transfer with from/to/amount in the body",
        "PUT /accounts/42/balance with the new balance",
        "POST /transactions with from/to/amount in the body",
        "PATCH /accounts/42 and PATCH /accounts/43 in sequence"
      ],
      "correct": 2,
      "explanation": "POST /transactions models the transfer as creating a new resource (a transaction). This is RESTful — it treats the action as a noun. Two separate PATCHes aren't atomic, and PUT on balance ignores the other account.",
      "detailedExplanation": "In interviews and real systems work, anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Prefer the approach that keeps client behavior explicit while preserving evolvability. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-018",
      "type": "multiple-choice",
      "question": "Which HTTP header tells the server what format the client wants in the response?",
      "options": [
        "Content-Type",
        "Accept",
        "Authorization",
        "X-Response-Format"
      ],
      "correct": 1,
      "explanation": "The Accept header specifies the media types the client can handle (e.g., application/json). Content-Type describes the format of the request body, not the desired response format.",
      "detailedExplanation": "In interviews and real systems work, begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Discard options that weaken contract clarity or compatibility over time. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-019",
      "type": "multiple-choice",
      "question": "Which HTTP header describes the format of the request body?",
      "options": [
        "Accept",
        "Content-Type",
        "Content-Length",
        "Transfer-Encoding"
      ],
      "correct": 1,
      "explanation": "Content-Type tells the server the media type of the request body (e.g., application/json). Accept is what the client wants back. Content-Length is the size in bytes.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Discard options that weaken contract clarity or compatibility over time. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-020",
      "type": "two-stage",
      "stages": [
        {
          "question": "A client sends PUT /users/42 with a complete user object, but user 42 doesn't exist yet. What should happen?",
          "options": [
            "Return 404 Not Found",
            "Create the resource and return 201 Created",
            "Return 400 Bad Request",
            "Return 409 Conflict"
          ],
          "correct": 1,
          "explanation": "PUT is defined as 'create or replace.' If the resource doesn't exist at the given URI, the server should create it and return 201. This is the key difference from PATCH, which only updates existing resources.",
          "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Solve this as chained reasoning where stage two must respect stage one assumptions. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Keep quantities like 42 and 201 in aligned units before deciding on an implementation approach. Common pitfall: ambiguous contracts that hide behavior changes."
        },
        {
          "question": "Now the client sends the same PUT /users/42 again with identical data. What should the response be?",
          "options": [
            "201 Created again",
            "200 OK (resource unchanged)",
            "409 Conflict",
            "304 Not Modified"
          ],
          "correct": 1,
          "explanation": "The resource already exists and the data is the same, so 200 OK is appropriate. This demonstrates PUT's idempotency — the first call creates (201), subsequent identical calls have no additional effect (200).",
          "detailedExplanation": "In interviews and real systems work, begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Solve this as chained reasoning where stage two must respect stage one assumptions. Interface decisions should be justified by contract stability and client impact over time. Numbers such as 42 and 200 should be normalized first so downstream reasoning stays consistent. Common pitfall: ambiguous contracts that hide behavior changes."
        }
      ],
      "detailedExplanation": "Generalize from rEST Fundamentals to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Solve this as chained reasoning where stage two must respect stage one assumptions. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-021",
      "type": "multiple-choice",
      "question": "Which HTTP method should NOT have a request body?",
      "options": ["POST", "PUT", "GET", "PATCH"],
      "correct": 2,
      "explanation": "GET requests should not have a body — semantics of a GET body are undefined in HTTP, and many intermediaries (proxies, CDNs) will strip or ignore it. Use query parameters instead.",
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Discard options that weaken contract clarity or compatibility over time. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-022",
      "type": "ordering",
      "question": "Rank these HTTP methods from safest to least safe (in terms of side effects):",
      "items": ["GET", "DELETE", "POST", "PUT"],
      "correctOrder": [0, 3, 1, 2],
      "explanation": "GET is safe (no side effects). PUT and DELETE are unsafe but idempotent (repeatable). POST is the least safe — it's neither safe nor idempotent. PUT before DELETE because PUT's replace semantics are more predictable.",
      "detailedExplanation": "In interviews and real systems work, anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Place obvious extremes first, then sort the middle by pairwise comparison. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-023",
      "type": "multiple-choice",
      "question": "Your GET endpoint must be callable by crawlers/cache warmers without mutating data. Which HTTP property describes that requirement?",
      "options": [
        "It uses HTTPS",
        "It doesn't modify server state",
        "It's idempotent",
        "It requires authentication"
      ],
      "correct": 1,
      "explanation": "A 'safe' HTTP method doesn't modify server state. GET and HEAD are safe — they only retrieve data. Safe methods can still have side effects (like logging), but they must not change resources.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-024",
      "type": "multiple-choice",
      "question": "A mobile app needs to check if a resource exists without downloading its body. Which method?",
      "options": ["GET", "HEAD", "OPTIONS", "TRACE"],
      "correct": 1,
      "explanation": "HEAD is identical to GET but returns only headers, no body. It's useful for checking existence (via status code) or metadata (Content-Length, Last-Modified) without transferring the full response.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Prefer the approach that keeps client behavior explicit while preserving evolvability. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-025",
      "type": "multiple-choice",
      "question": "Before sending a cross-origin request, the browser performs a CORS preflight. Which HTTP method is used for that preflight?",
      "options": [
        "Setting configuration options on a resource",
        "Describing the communication options for the target resource",
        "Listing available resources",
        "Checking if the server is alive"
      ],
      "correct": 1,
      "explanation": "OPTIONS returns the allowed HTTP methods and other communication options for a resource. Browsers send OPTIONS as a CORS preflight request to check if a cross-origin request is permitted.",
      "detailedExplanation": "In interviews and real systems work, begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Discard options that weaken contract clarity or compatibility over time. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-026",
      "type": "multiple-choice",
      "question": "What status code indicates the server understood the request but refuses to fulfill it, and authentication won't help?",
      "options": [
        "401 Unauthorized",
        "403 Forbidden",
        "405 Method Not Allowed",
        "406 Not Acceptable"
      ],
      "correct": 1,
      "explanation": "403 Forbidden means the server understood the request and the client's identity, but the client doesn't have permission. Re-authenticating won't change the outcome — different authorization is needed.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Discard options that weaken contract clarity or compatibility over time. Good API choices balance client ergonomics, compatibility, and long-term evolvability. If values like 403 appear, convert them into one unit basis before comparison. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-027",
      "type": "multiple-choice",
      "question": "A client sends PATCH to an endpoint that supports only GET and POST. Which status code should the server return?",
      "options": [
        "400 Bad Request",
        "404 Not Found",
        "405 Method Not Allowed",
        "501 Not Implemented"
      ],
      "correct": 2,
      "explanation": "405 Method Not Allowed means the resource exists but doesn't support the HTTP method used. The response should include an Allow header listing valid methods. 501 means the server doesn't recognize the method at all.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Prefer the approach that keeps client behavior explicit while preserving evolvability. Interface decisions should be justified by contract stability and client impact over time. If values like 405 and 501 appear, convert them into one unit basis before comparison. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-028",
      "type": "multiple-choice",
      "question": "Which status code is correct for a successful DELETE that returns no body?",
      "options": ["200 OK", "201 Created", "204 No Content", "202 Accepted"],
      "correct": 2,
      "explanation": "204 No Content means the action succeeded and there's nothing to return in the body. 200 OK is also valid if you include a response body (like the deleted resource or a confirmation message).",
      "detailedExplanation": "Generalize from status code is correct for a successful DELETE that returns no body to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Prefer the approach that keeps client behavior explicit while preserving evolvability. Good API choices balance client ergonomics, compatibility, and long-term evolvability. If values like 204 and 200 appear, convert them into one unit basis before comparison. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-029",
      "type": "two-stage",
      "stages": [
        {
          "question": "An API has POST /orders to create an order. A network failure occurs after the server processes the request but before the client receives the response. The client retries. What happens?",
          "options": [
            "The server rejects the duplicate",
            "A duplicate order is created",
            "The server returns the original order",
            "Depends on the implementation"
          ],
          "correct": 3,
          "explanation": "POST is not idempotent by default. Without additional safeguards, a retry could create a duplicate. The behavior depends entirely on whether the server implements duplicate detection.",
          "detailedExplanation": "In interviews and real systems work, begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Solve this as chained reasoning where stage two must respect stage one assumptions. Map the approach to measurable reliability impact such as error-budget burn and recovery behavior. Common pitfall: retry storms during partial failure."
        },
        {
          "question": "What's the standard mechanism to make this POST idempotent?",
          "options": [
            "Use PUT instead",
            "Send an Idempotency-Key header with a client-generated unique ID",
            "Include a timestamp in the body",
            "Use HTTPS to prevent network failures"
          ],
          "correct": 1,
          "explanation": "An Idempotency-Key header (popularized by Stripe) lets the server detect retries. The server stores the key and returns the original response for duplicate requests. PUT would work if the client knows the URI, but POST with idempotency keys is more flexible.",
          "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Solve this as chained reasoning where stage two must respect stage one assumptions. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: interface design coupled too tightly to internal implementation."
        }
      ],
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Do not reset assumptions between stages; carry forward prior constraints directly. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-030",
      "type": "multiple-choice",
      "question": "Why is POST not considered idempotent?",
      "options": [
        "It always modifies server state",
        "Sending the same POST request twice may produce different results (e.g., two resources created)",
        "It can't be cached",
        "It requires a request body"
      ],
      "correct": 1,
      "explanation": "Idempotency means repeated identical requests produce the same server state. POST /orders with the same data could create two separate orders, so the server state differs. That's why POST is not idempotent.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-031",
      "type": "multi-select",
      "question": "Which are safe HTTP methods?",
      "options": ["GET", "HEAD", "OPTIONS", "DELETE"],
      "correctIndices": [0, 1, 2],
      "explanation": "GET, HEAD, and OPTIONS are safe — they don't modify server state. DELETE is unsafe (it removes a resource) even though it's idempotent.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Anchor decisions in explicit constraints, invariants, and observable failure signals rather than intuition. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-032",
      "type": "multiple-choice",
      "question": "Which URI pattern is correct for getting all comments on post 7?",
      "options": [
        "/comments?post=7",
        "/posts/7/comments",
        "/posts/comments/7",
        "/getCommentsByPost/7"
      ],
      "correct": 1,
      "explanation": "Nested resource pattern: /posts/7/comments expresses the parent-child relationship clearly. Query params work but don't convey hierarchy. Verbs in URIs break REST conventions.",
      "detailedExplanation": "In interviews and real systems work, begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Discard options that weaken contract clarity or compatibility over time. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Keep quantities like 7 in aligned units before deciding on an implementation approach. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-033",
      "type": "multiple-choice",
      "question": "How should you name a REST endpoint that searches for users?",
      "options": [
        "GET /users/search?q=john",
        "POST /users/search with body",
        "GET /users?q=john",
        "GET /searchUsers?q=john"
      ],
      "correct": 2,
      "explanation": "Searching is a filtered GET on the collection: GET /users?q=john. Query parameters are the standard way to filter collections. Adding /search as a sub-resource or using verbs in URIs are less RESTful.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-034",
      "type": "multiple-choice",
      "question": "Which URI convention is preferred for multi-word resource names?",
      "options": [
        "camelCase: /userProfiles",
        "snake_case: /user_profiles",
        "kebab-case: /user-profiles",
        "No convention exists"
      ],
      "correct": 2,
      "explanation": "Kebab-case (hyphens) is the convention for URIs because URIs are case-insensitive by convention, making camelCase unreliable. Hyphens are also more readable in URLs than underscores.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Discard options that weaken contract clarity or compatibility over time. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-035",
      "type": "multiple-choice",
      "question": "A REST API returns a newly created resource. Which header should point to its canonical URI?",
      "options": ["Content-Location", "Location", "Link", "Referer"],
      "correct": 1,
      "explanation": "The Location header in a 201 Created response provides the URI of the newly created resource. This lets the client immediately know how to access it.",
      "detailedExplanation": "In interviews and real systems work, anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Interface decisions should be justified by contract stability and client impact over time. Numbers such as 201 should be normalized first so downstream reasoning stays consistent. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-036",
      "type": "multiple-choice",
      "question": "What's the REST term for including related resources in a response to reduce round trips?",
      "options": [
        "Eager loading",
        "Resource embedding",
        "Compound documents",
        "All of these describe the same concept"
      ],
      "correct": 3,
      "explanation": "All of these terms describe including related resources in a single response. JSON:API calls them 'compound documents,' HAL calls it 'embedding,' and ORMs call it 'eager loading.' The goal is reducing N+1 HTTP requests.",
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Prefer the approach that keeps client behavior explicit while preserving evolvability. Prioritize explicit semantics and upgrade safety, not just short-term convenience. If values like 1 appear, convert them into one unit basis before comparison. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-038",
      "type": "multiple-choice",
      "question": "Which 3xx status code indicates the resource has permanently moved to a new URI?",
      "options": [
        "301 Moved Permanently",
        "302 Found",
        "304 Not Modified",
        "307 Temporary Redirect"
      ],
      "correct": 0,
      "explanation": "301 Moved Permanently tells the client (and search engines) to use the new URI from now on. 302/307 are temporary redirects. 304 is a conditional response, not a redirect.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Interface decisions should be justified by contract stability and client impact over time. If values like 301 and 302 appear, convert them into one unit basis before comparison. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-039",
      "type": "multiple-choice",
      "question": "When should you use 304 Not Modified?",
      "options": [
        "When a PATCH request doesn't change anything",
        "When the client's cached version is still current",
        "When the server hasn't been updated recently",
        "When the request is a duplicate"
      ],
      "correct": 1,
      "explanation": "304 Not Modified is used with conditional requests (If-None-Match, If-Modified-Since). The server tells the client its cached version is still valid, saving bandwidth by not resending the body.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Prefer the approach that keeps client behavior explicit while preserving evolvability. Interface decisions should be justified by contract stability and client impact over time. If values like 304 appear, convert them into one unit basis before comparison. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-040",
      "type": "two-stage",
      "stages": [
        {
          "question": "A client sends GET /users/42 with an If-None-Match header containing the current ETag. What should the server return?",
          "options": [
            "200 OK with the full user object",
            "304 Not Modified with no body",
            "204 No Content",
            "400 Bad Request"
          ],
          "correct": 1,
          "explanation": "If the ETag matches (resource hasn't changed), the server returns 304 Not Modified with no body. The client uses its cached version. This saves bandwidth and reduces server load.",
          "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Do not reset assumptions between stages; carry forward prior constraints directly. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Numbers such as 42 and 304 should be normalized first so downstream reasoning stays consistent. Common pitfall: breaking clients during version evolution."
        },
        {
          "question": "Another client sends the same GET /users/42 with an outdated ETag. What should the server return?",
          "options": [
            "304 Not Modified",
            "200 OK with the full user object and the new ETag",
            "409 Conflict",
            "412 Precondition Failed"
          ],
          "correct": 1,
          "explanation": "The ETag doesn't match, so the resource has changed. The server returns 200 OK with the full body and the new ETag. 412 would apply to conditional writes (If-Match), not reads.",
          "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Solve this as chained reasoning where stage two must respect stage one assumptions. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Numbers such as 42 and 200 should be normalized first so downstream reasoning stays consistent. Common pitfall: ambiguous contracts that hide behavior changes."
        }
      ],
      "detailedExplanation": "In interviews and real systems work, anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-041",
      "type": "multiple-choice",
      "question": "A service is temporarily overloaded and asks clients to retry later. Which status code best communicates this?",
      "options": [
        "500 Internal Server Error",
        "502 Bad Gateway",
        "503 Service Unavailable",
        "504 Gateway Timeout"
      ],
      "correct": 2,
      "explanation": "503 Service Unavailable indicates a temporary condition — the server is overloaded or down for maintenance. It should include a Retry-After header. 500 is a generic server error, not specifically about capacity.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Prioritize the approach that best protects reliability objectives under stated failure conditions. Tie decisions to concrete operational outcomes, not abstract reliability language. If values like 503 and 500 appear, convert them into one unit basis before comparison. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-042",
      "type": "multiple-choice",
      "question": "What's the difference between 502 and 504?",
      "options": [
        "502 is permanent, 504 is temporary",
        "502 means the upstream server gave an invalid response, 504 means it didn't respond in time",
        "502 is for proxies, 504 is for origin servers",
        "They are interchangeable"
      ],
      "correct": 1,
      "explanation": "Both involve a gateway/proxy. 502 Bad Gateway means the proxy received an invalid response from the upstream server. 504 Gateway Timeout means the upstream server didn't respond at all within the time limit.",
      "detailedExplanation": "Generalize from what's the difference between 502 and 504 to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Prefer approaches that directly address failure mode, recovery path, and blast radius. A strong real-world approach explains how failure mode, mitigation speed, and blast radius interact. If values like 502 and 504 appear, convert them into one unit basis before comparison. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-043",
      "type": "multiple-choice",
      "question": "Which status code should a rate limiter return when a client exceeds their quota?",
      "options": [
        "400 Bad Request",
        "403 Forbidden",
        "429 Too Many Requests",
        "503 Service Unavailable"
      ],
      "correct": 2,
      "explanation": "429 Too Many Requests is specifically designed for rate limiting. It should include a Retry-After header. 503 implies the entire service is overloaded, not just this client. 403 suggests a permanent authorization issue.",
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Reject approaches that sound good in general but do not reduce concrete reliability risk. Map the approach to measurable reliability impact such as error-budget burn and recovery behavior. Keep quantities like 429 and 503 in aligned units before deciding on an implementation approach. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-044",
      "type": "multi-select",
      "question": "Which headers are commonly included in a 429 response?",
      "options": [
        "Retry-After",
        "X-RateLimit-Remaining",
        "X-RateLimit-Reset",
        "Content-Encoding"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "Retry-After tells the client when to retry. X-RateLimit-Remaining and X-RateLimit-Reset (non-standard but widely used) tell the client their remaining quota and when it resets. Content-Encoding is unrelated to rate limiting.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Validate each proposed control independently and avoid partially true claims that fail under realistic load. Map the approach to measurable reliability impact such as error-budget burn and recovery behavior. Keep quantities like 429 in aligned units before deciding on an implementation approach. Common pitfall: meeting average goals while missing tail-risk.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-045",
      "type": "multiple-choice",
      "question": "Which constraint is NOT part of the REST architectural style?",
      "options": [
        "Statelessness",
        "Uniform interface",
        "Strongly-typed schemas",
        "Layered system"
      ],
      "correct": 2,
      "explanation": "REST's six constraints are: client-server, stateless, cacheable, uniform interface, layered system, and (optional) code on demand. Strongly-typed schemas are a feature of gRPC/GraphQL, not a REST constraint.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Discard options that weaken contract clarity or compatibility over time. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-046",
      "type": "multiple-choice",
      "question": "In API design review, you reject sticky server-side sessions and require each request to be self-contained. Which REST principle is this?",
      "options": [
        "The server stores no data at all",
        "Each request contains all information needed to process it — the server stores no client session state",
        "The API has no side effects",
        "Resources never change"
      ],
      "correct": 1,
      "explanation": "Stateless means the server doesn't store session state between requests. Each request is self-contained. The server still stores resource state (database) — it just doesn't store 'client X is on step 3 of checkout.'",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Discard options that weaken contract clarity or compatibility over time. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Keep quantities like 3 in aligned units before deciding on an implementation approach. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-047",
      "type": "two-stage",
      "stages": [
        {
          "question": "An API stores a 'shopping cart' in a server-side session tied to a cookie. Does this violate REST's statelessness constraint?",
          "options": [
            "No, cookies are part of HTTP",
            "Yes, the server is storing client session state",
            "Only if the cart is in memory, not if it's in a database",
            "It depends on the session timeout"
          ],
          "correct": 1,
          "explanation": "A server-side session is client state stored on the server — the next request depends on previous requests having set up that session. This violates REST's statelessness constraint.",
          "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Do not reset assumptions between stages; carry forward prior constraints directly. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: ambiguous contracts that hide behavior changes."
        },
        {
          "question": "How would you redesign this to be stateless?",
          "options": [
            "Store the cart as a proper resource: POST /carts, GET /carts/{id}",
            "Store the cart in a JWT token",
            "Use WebSockets instead of HTTP",
            "Increase the session timeout"
          ],
          "correct": 0,
          "explanation": "Model the cart as a first-class resource with its own URI. The client stores the cart ID and sends it with each request. Server-side, the cart is resource state (like any database record), not session state.",
          "detailedExplanation": "In interviews and real systems work, anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Solve this as chained reasoning where stage two must respect stage one assumptions. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: breaking clients during version evolution."
        }
      ],
      "detailedExplanation": "In interviews and real systems work, begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Solve this as chained reasoning where stage two must respect stage one assumptions. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-049",
      "type": "multiple-choice",
      "question": "In practice, what does HATEOAS look like in an API response?",
      "options": [
        "XML instead of JSON",
        "Links in the response body pointing to related resources and available actions",
        "A separate documentation endpoint",
        "Version numbers in every response"
      ],
      "correct": 1,
      "explanation": "HATEOAS responses include hypermedia links like {\"self\": \"/orders/42\", \"cancel\": \"/orders/42/cancel\", \"items\": \"/orders/42/items\"}. The client discovers available actions from the response rather than hardcoding them.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Discard options that weaken contract clarity or compatibility over time. Interface decisions should be justified by contract stability and client impact over time. Keep quantities like 42 in aligned units before deciding on an implementation approach. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-050",
      "type": "multiple-choice",
      "question": "How many REST APIs in the wild truly implement HATEOAS?",
      "options": [
        "Most of them",
        "About half",
        "Very few — it's the most commonly ignored REST constraint",
        "None — it's purely theoretical"
      ],
      "correct": 2,
      "explanation": "HATEOAS is the most commonly ignored REST constraint. Most APIs described as 'REST' are really 'HTTP APIs with JSON.' True HATEOAS requires clients to be link-following state machines, which adds complexity most teams don't need.",
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Prefer the approach that keeps client behavior explicit while preserving evolvability. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-051",
      "type": "ordering",
      "question": "Rank these from least RESTful to most RESTful (Richardson Maturity Model):",
      "items": [
        "Plain RPC over HTTP (one endpoint)",
        "Resources with proper URIs",
        "HTTP verbs used correctly",
        "HATEOAS"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "The Richardson Maturity Model: Level 0 (one endpoint, RPC), Level 1 (resources), Level 2 (HTTP verbs), Level 3 (HATEOAS). Each level adds more REST constraints. Most production APIs reach Level 2.",
      "detailedExplanation": "Generalize from rank these from least RESTful to most RESTful (Richardson Maturity Model): to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Place obvious extremes first, then sort the middle by pairwise comparison. Interface decisions should be justified by contract stability and client impact over time. Numbers such as 0 and 1 should be normalized first so downstream reasoning stays consistent. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-052",
      "type": "multiple-choice",
      "question": "You need to model an action that doesn't map cleanly to CRUD — e.g., 'lock an account.' What's the most RESTful approach?",
      "options": [
        "POST /accounts/42/lock",
        "PATCH /accounts/42 with {\"status\": \"locked\"}",
        "PUT /accounts/42/lock with empty body",
        "POST /account-locks with {\"accountId\": 42}"
      ],
      "correct": 1,
      "explanation": "PATCH to update the account's status field models this as a state change on an existing resource. Alternatively, POST /account-locks models it as creating a new resource. Both are valid, but PATCH is simpler when the action maps to a field change.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Prefer the approach that keeps client behavior explicit while preserving evolvability. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-054",
      "type": "multiple-choice",
      "question": "A PATCH request sends {\"email\": \"new@example.com\"} for a user who also has name, age, and address fields. What should happen to the other fields?",
      "options": [
        "They should be set to null",
        "They should remain unchanged",
        "The server should return 400 because the request is incomplete",
        "It depends on whether you use JSON Merge Patch or JSON Patch"
      ],
      "correct": 3,
      "explanation": "With JSON Merge Patch (RFC 7396), omitted fields are unchanged and null means delete. With JSON Patch (RFC 6902), you send explicit operations. Most APIs use Merge Patch semantics (omitted = unchanged), but the spec matters.",
      "detailedExplanation": "In interviews and real systems work, begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Numbers such as 7396 and 6902 should be normalized first so downstream reasoning stays consistent. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-055",
      "type": "multiple-choice",
      "question": "Which header enables CORS preflight requests?",
      "options": [
        "Access-Control-Allow-Origin",
        "Origin",
        "X-Requested-With",
        "Access-Control-Allow-Methods"
      ],
      "correct": 0,
      "explanation": "Access-Control-Allow-Origin in the response tells the browser which origins can access the resource. The browser's preflight OPTIONS request checks for this header before sending the actual request.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Prefer the approach that keeps client behavior explicit while preserving evolvability. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-056",
      "type": "two-stage",
      "stages": [
        {
          "question": "A browser JavaScript app on app.example.com calls fetch('https://api.example.com/users'). Before the GET request, the browser sends an OPTIONS request. Why?",
          "options": [
            "To check if the server is available",
            "CORS preflight — the browser checks if cross-origin requests are allowed",
            "To negotiate the response format",
            "To establish a persistent connection"
          ],
          "correct": 1,
          "explanation": "Different subdomains are different origins. The browser sends a preflight OPTIONS request to check CORS headers before allowing the cross-origin request. This protects users from malicious cross-site requests.",
          "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Solve this as chained reasoning where stage two must respect stage one assumptions. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: breaking clients during version evolution."
        },
        {
          "question": "The OPTIONS response includes Access-Control-Allow-Origin: *. Is this a security concern for a public API?",
          "options": [
            "Yes — it allows any website to make requests",
            "No — CORS only controls browser requests, and a public API wants broad access",
            "Yes — it exposes internal endpoints",
            "No — the * only applies to GET requests"
          ],
          "correct": 1,
          "explanation": "For a public API, Access-Control-Allow-Origin: * is appropriate. CORS is a browser security feature — it doesn't affect server-to-server calls, curl, or mobile apps. A public API intentionally allows broad access. For private APIs, you'd restrict the origin.",
          "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: breaking clients during version evolution."
        }
      ],
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Solve this as chained reasoning where stage two must respect stage one assumptions. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-057",
      "type": "multiple-choice",
      "question": "An API can return JSON or XML based on the request headers. What is this mechanism called in HTTP/REST?",
      "options": [
        "Negotiating the price of API access",
        "The client and server agree on the representation format via Accept and Content-Type headers",
        "Choosing between REST and GraphQL",
        "Compressing the response body"
      ],
      "correct": 1,
      "explanation": "Content negotiation lets the client request a specific format (JSON, XML, etc.) via the Accept header, and the server responds in that format. This decouples resources from their representations.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Discard options that weaken contract clarity or compatibility over time. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-058",
      "type": "multiple-choice",
      "question": "A GET /users endpoint returns 10,000 users. What's the main problem?",
      "options": [
        "GET can't handle that many results",
        "The response is too large — it wastes bandwidth, memory, and time",
        "GET requests are limited to 1,000 results by HTTP",
        "The server will time out"
      ],
      "correct": 1,
      "explanation": "No HTTP limit exists on response size, but returning 10,000 records is impractical — slow response, high memory usage on client and server, wasted bandwidth for clients who need a few records. Pagination solves this.",
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Numbers such as 10,000 should be normalized first so downstream reasoning stays consistent. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-059",
      "type": "multiple-choice",
      "question": "What status code should you return for a request with a valid JSON body but an unsupported media type?",
      "options": [
        "400 Bad Request",
        "406 Not Acceptable",
        "415 Unsupported Media Type",
        "422 Unprocessable Entity"
      ],
      "correct": 2,
      "explanation": "415 Unsupported Media Type means the server can't process the request's Content-Type. For example, if the server only accepts JSON and receives XML. 406 is about the Accept header (response format), not the request format.",
      "detailedExplanation": "Generalize from status code should you return for a request with a valid JSON body but an unsupported to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Prefer the approach that keeps client behavior explicit while preserving evolvability. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Keep quantities like 415 and 406 in aligned units before deciding on an implementation approach. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-060",
      "type": "multi-select",
      "question": "Which are benefits of REST's statelessness constraint?",
      "options": [
        "Horizontal scaling — any server can handle any request",
        "Simpler server implementation — no session management",
        "Reduced network traffic",
        "Better fault tolerance — server restarts don't lose client state"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Statelessness enables horizontal scaling (no sticky sessions), simplifies servers (no session stores), and improves fault tolerance (server crashes don't lose session state). It actually increases network traffic since each request must carry full context.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Validate each proposed control independently and avoid partially true claims that fail under realistic load. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-061",
      "type": "multiple-choice",
      "question": "Which best describes a 'resource' in REST?",
      "options": [
        "A database table",
        "An API endpoint",
        "Any information that can be named — a document, image, service, collection, etc.",
        "A JSON object"
      ],
      "correct": 2,
      "explanation": "In REST, a resource is any concept that can be named and addressed. It could be a single document, a collection, a computed result, or even a non-virtual object. Resources are identified by URIs and can have multiple representations.",
      "detailedExplanation": "In interviews and real systems work, begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-062",
      "type": "multiple-choice",
      "question": "Should a DELETE endpoint return the deleted resource in the response body?",
      "options": [
        "Yes, always — the client needs confirmation",
        "No, never — 204 No Content is the only correct response",
        "Either is valid — 200 with body or 204 without",
        "Only if the client sends an Accept header"
      ],
      "correct": 2,
      "explanation": "Both approaches are valid REST. 204 No Content is clean and minimal. 200 OK with the deleted resource lets clients confirm what was deleted or use the data without an extra GET. Choose based on your API's conventions.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Discard options that weaken contract clarity or compatibility over time. Prioritize explicit semantics and upgrade safety, not just short-term convenience. If values like 204 and 200 appear, convert them into one unit basis before comparison. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-063",
      "type": "multiple-choice",
      "question": "What's the purpose of the Allow header?",
      "options": [
        "Listing which origins can access the resource",
        "Listing which HTTP methods are valid for a resource",
        "Listing which content types are accepted",
        "Listing which authentication methods are supported"
      ],
      "correct": 1,
      "explanation": "The Allow header lists valid HTTP methods for a resource (e.g., Allow: GET, POST, DELETE). It's required in 405 Method Not Allowed responses and useful in OPTIONS responses.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Prefer the approach that keeps client behavior explicit while preserving evolvability. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Numbers such as 405 should be normalized first so downstream reasoning stays consistent. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-064",
      "type": "two-stage",
      "stages": [
        {
          "question": "A client updates a user's email with PATCH /users/42. Meanwhile, another client also patches user 42's address. The second PATCH overwrites the first client's email change. What's this problem called?",
          "options": [
            "Race condition",
            "Lost update problem",
            "Dirty read",
            "Phantom read"
          ],
          "correct": 1,
          "explanation": "The lost update problem: two clients read the same state, both modify it, and the second write overwrites the first without incorporating its changes. This is a classic concurrency issue in APIs.",
          "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Do not reset assumptions between stages; carry forward prior constraints directly. Good API choices balance client ergonomics, compatibility, and long-term evolvability. If values like 42 appear, convert them into one unit basis before comparison. Common pitfall: breaking clients during version evolution."
        },
        {
          "question": "Which HTTP mechanism prevents lost updates?",
          "options": [
            "Using PUT instead of PATCH",
            "Optimistic concurrency with ETags and If-Match",
            "Requiring sequential request IDs",
            "Using transactions in the database"
          ],
          "correct": 1,
          "explanation": "Optimistic concurrency: each response includes an ETag. Updates send If-Match with their ETag. If the resource changed since the client's last read, the server returns 412 Precondition Failed and the client must re-read and retry.",
          "detailedExplanation": "In interviews and real systems work, begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. A strong real-world approach explains how failure mode, mitigation speed, and blast radius interact. Keep quantities like 412 in aligned units before deciding on an implementation approach. Common pitfall: meeting average goals while missing tail-risk."
        }
      ],
      "detailedExplanation": "Generalize from rEST Fundamentals to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Solve this as chained reasoning where stage two must respect stage one assumptions. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-065",
      "type": "multiple-choice",
      "question": "What status code does the server return when an If-Match precondition fails?",
      "options": [
        "400 Bad Request",
        "409 Conflict",
        "412 Precondition Failed",
        "428 Precondition Required"
      ],
      "correct": 2,
      "explanation": "412 Precondition Failed means the condition in If-Match (or If-Unmodified-Since) was not met — the resource has changed since the client last fetched it. 428 means the server requires a precondition header but the client didn't send one.",
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Keep quantities like 412 and 428 in aligned units before deciding on an implementation approach. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-066",
      "type": "multiple-choice",
      "question": "What's an ETag?",
      "options": [
        "An encryption tag for secure responses",
        "An error tracking identifier",
        "An opaque identifier representing a specific version of a resource",
        "An HTML element tag"
      ],
      "correct": 2,
      "explanation": "An ETag (entity tag) is a version identifier for a resource — typically a hash of the content or a version number. Clients use it with If-None-Match (caching) and If-Match (concurrency control).",
      "detailedExplanation": "In interviews and real systems work, anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Discard options that weaken contract clarity or compatibility over time. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-067",
      "type": "multi-select",
      "question": "Which are valid uses of ETags?",
      "options": [
        "Conditional GET requests to avoid re-downloading unchanged resources",
        "Optimistic concurrency control for updates",
        "Authentication",
        "Cache validation"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "ETags serve caching (conditional GETs with If-None-Match → 304), concurrency control (conditional writes with If-Match → 412), and cache validation. They have nothing to do with authentication.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Anchor decisions in explicit constraints, invariants, and observable failure signals rather than intuition. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Keep quantities like 304 and 412 in aligned units before deciding on an implementation approach. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Redis Documentation",
          "url": "https://redis.io/docs/latest/"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-068",
      "type": "multiple-choice",
      "question": "Which is NOT a common REST API authentication mechanism?",
      "options": [
        "Bearer tokens (OAuth 2.0)",
        "API keys in headers",
        "HTTP Basic authentication",
        "REST-Auth handshake"
      ],
      "correct": 3,
      "explanation": "There's no such thing as a 'REST-Auth handshake.' Common REST API auth mechanisms include Bearer tokens (OAuth 2.0), API keys (in headers or query params), and HTTP Basic auth (username:password base64-encoded).",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Discard options that weaken contract clarity or compatibility over time. Good API choices balance client ergonomics, compatibility, and long-term evolvability. If values like 2.0 appear, convert them into one unit basis before comparison. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-069",
      "type": "multiple-choice",
      "question": "Where should API keys be sent in a REST request?",
      "options": [
        "Always in the URL query string",
        "Always in the request body",
        "In a header (preferred) or query string",
        "In a cookie"
      ],
      "correct": 2,
      "explanation": "Headers are preferred (e.g., X-API-Key or Authorization) because URLs get logged in server access logs, browser history, and referrer headers. Query strings work but risk exposing the key.",
      "detailedExplanation": "In interviews and real systems work, begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-070",
      "type": "multiple-choice",
      "question": "What happens if a REST API stores client-specific 'step' state on the server (e.g., 'user is on step 3 of a wizard')?",
      "options": [
        "Nothing — this is normal REST",
        "It breaks statelessness, making horizontal scaling harder",
        "The API becomes faster",
        "It improves security"
      ],
      "correct": 1,
      "explanation": "Storing client state on the server violates REST's statelessness constraint. This creates 'sticky sessions' — requests must route to the same server. It complicates scaling, failover, and load balancing.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Prefer approaches that directly address failure mode, recovery path, and blast radius. A strong real-world approach explains how failure mode, mitigation speed, and blast radius interact. Keep quantities like 3 in aligned units before deciding on an implementation approach. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-071",
      "type": "ordering",
      "question": "Rank these API design qualities from most to least important for a public-facing API:",
      "items": [
        "Consistency",
        "Clever URI design",
        "Good error messages",
        "Comprehensive documentation"
      ],
      "correctOrder": [0, 3, 2, 1],
      "explanation": "Consistency is paramount — predictable patterns reduce learning curve. Documentation is essential for adoption. Good errors help debugging. Clever URIs are nice but least critical — a consistent, well-documented API with mediocre URIs beats an inconsistent one with beautiful URIs.",
      "detailedExplanation": "In interviews and real systems work, anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Place obvious extremes first, then sort the middle by pairwise comparison. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-072",
      "type": "multiple-choice",
      "question": "A client sends a valid request but the server fails internally. Which status code?",
      "options": [
        "400 Bad Request",
        "404 Not Found",
        "500 Internal Server Error",
        "503 Service Unavailable"
      ],
      "correct": 2,
      "explanation": "500 Internal Server Error means the server encountered an unexpected condition. The request was valid (not 4xx) but the server failed to fulfill it. Don't expose implementation details — log them server-side.",
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Prioritize explicit semantics and upgrade safety, not just short-term convenience. If values like 500 appear, convert them into one unit basis before comparison. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-073",
      "type": "multiple-choice",
      "question": "Should REST API endpoints include the action in the URL (e.g., /users/42/activate)?",
      "options": [
        "Yes, it makes the API self-documenting",
        "Never — it's always wrong",
        "It's acceptable for non-CRUD actions that don't map to a resource state change",
        "Only for POST requests"
      ],
      "correct": 2,
      "explanation": "Purists model everything as resource state (PATCH status to 'active'), but for complex actions (restart, validate, import), a verb sub-resource like POST /servers/42/restart is pragmatic and widely accepted.",
      "detailedExplanation": "Generalize from should REST API endpoints include the action in the URL (e to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Discard options that weaken contract clarity or compatibility over time. Interface decisions should be justified by contract stability and client impact over time. Keep quantities like 42 in aligned units before deciding on an implementation approach. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-074",
      "type": "multi-select",
      "question": "Which response headers help with caching?",
      "options": ["Cache-Control", "ETag", "Last-Modified", "X-Request-Id"],
      "correctIndices": [0, 1, 2],
      "explanation": "Cache-Control defines caching rules (max-age, no-cache, etc.). ETag enables conditional requests. Last-Modified enables time-based conditional requests. X-Request-Id is for request tracing, not caching.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Evaluate each candidate approach independently under the same constraints. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Redis Documentation",
          "url": "https://redis.io/docs/latest/"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-075",
      "type": "multiple-choice",
      "question": "A response contains highly sensitive data and must never be persisted by browser/proxy caches. Which Cache-Control directive is correct?",
      "options": [
        "The response can be cached but must be revalidated each time",
        "The response must not be stored in any cache, ever",
        "The cache should be cleared",
        "Caching is optional"
      ],
      "correct": 1,
      "explanation": "no-store means no cache (browser, CDN, proxy) should store the response at all. This is the strictest caching directive. no-cache means 'cache it but revalidate every time' — a confusing name.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Prefer the approach that keeps client behavior explicit while preserving evolvability. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Redis Documentation",
          "url": "https://redis.io/docs/latest/"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-076",
      "type": "multiple-choice",
      "question": "What's the difference between Cache-Control: no-cache and no-store?",
      "options": [
        "They're the same thing",
        "no-cache prevents caching entirely; no-store allows it with revalidation",
        "no-cache allows caching but requires revalidation; no-store prevents caching entirely",
        "no-cache is for browsers; no-store is for CDNs"
      ],
      "correct": 2,
      "explanation": "Despite the name, no-cache does NOT prevent caching — it means 'cache it but revalidate with the server before every use.' no-store prevents any caching whatsoever. For truly sensitive data, use no-store.",
      "detailedExplanation": "In interviews and real systems work, begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Prefer the approach that keeps client behavior explicit while preserving evolvability. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Redis Documentation",
          "url": "https://redis.io/docs/latest/"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-077",
      "type": "multiple-choice",
      "question": "A REST API needs to perform a bulk operation — deleting 100 users. What's the most practical approach?",
      "options": [
        "100 individual DELETE /users/{id} requests",
        "DELETE /users with a list of IDs in the body",
        "POST /users/bulk-delete with a list of IDs",
        "Any of these work, but POST with a body is the most practical"
      ],
      "correct": 3,
      "explanation": "100 individual requests are wasteful. DELETE with a body is technically allowed but poorly supported. POST /users/bulk-delete with a body is pragmatic — it's clear, supports a body naturally, and is widely used. Purity matters less than practicality for bulk operations.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Prefer the approach that keeps client behavior explicit while preserving evolvability. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Keep quantities like 100 in aligned units before deciding on an implementation approach. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-078",
      "type": "two-stage",
      "stages": [
        {
          "question": "You design POST /users which returns 201 Created. Six months later, you need to add email verification. Users shouldn't be fully active until verified. What's the best approach?",
          "options": [
            "Change POST /users to return 200 instead of 201",
            "POST /users still returns 201, but the user resource includes a 'status: pending_verification' field",
            "Create a separate POST /user-registrations endpoint",
            "Return 202 Accepted instead of 201"
          ],
          "correct": 1,
          "explanation": "The user resource is still created (201 is correct), but now includes a status field. This models verification as a state on the resource rather than changing the creation semantics. The alternative — a separate /user-registrations resource — is also valid but more disruptive.",
          "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Numbers such as 201 should be normalized first so downstream reasoning stays consistent. Common pitfall: breaking clients during version evolution."
        },
        {
          "question": "A client hits GET /users/42 for a user who exists but hasn't verified their email. What should the response be?",
          "options": [
            "404 Not Found — they're not a 'real' user yet",
            "200 OK with the user data, including status: pending_verification",
            "403 Forbidden — unverified users can't be accessed",
            "202 Accepted — the user is being processed"
          ],
          "correct": 1,
          "explanation": "The user resource exists, so 200 OK is correct. The status field tells the client the user's state. 404 would be incorrect — the resource exists. Application-level status belongs in the resource representation, not HTTP status codes.",
          "detailedExplanation": "Generalize from client hits GET /users/42 for a user who exists but hasn't verified their email to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Solve this as chained reasoning where stage two must respect stage one assumptions. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Numbers such as 42 and 200 should be normalized first so downstream reasoning stays consistent. Common pitfall: ambiguous contracts that hide behavior changes."
        }
      ],
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Solve this as chained reasoning where stage two must respect stage one assumptions. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-079",
      "type": "multiple-choice",
      "question": "Which is the best URI for getting the currently authenticated user's profile?",
      "options": [
        "GET /users/{userId} (client must know their ID)",
        "GET /me",
        "GET /users/current",
        "Either /me or /users/me — both are common conventions"
      ],
      "correct": 3,
      "explanation": "Both /me and /users/me are widely used conventions for 'the current user.' They avoid making the client store and manage their own user ID. The server resolves the identity from the authentication token.",
      "detailedExplanation": "In interviews and real systems work, anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "RFC 7519: JSON Web Token (JWT)",
          "url": "https://www.rfc-editor.org/rfc/rfc7519"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-080",
      "type": "multiple-choice",
      "question": "Should query parameters be included in cache keys?",
      "options": [
        "No — only the path matters for caching",
        "Yes — /users?page=1 and /users?page=2 are different resources",
        "Only for GET requests",
        "Only if the Vary header is set"
      ],
      "correct": 1,
      "explanation": "Query parameters change the response, so they must be part of the cache key. /users?page=1 and /users?page=2 return different data. Caches (browsers, CDNs) do include query strings by default.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Discard options that weaken contract clarity or compatibility over time. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Numbers such as 1 and 2 should be normalized first so downstream reasoning stays consistent. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Redis Documentation",
          "url": "https://redis.io/docs/latest/"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-081",
      "type": "multiple-choice",
      "question": "Your response varies by `Accept-Language`. Which header tells caches that this request header must be part of the cache key?",
      "options": [
        "Indicates the response varies by server",
        "Tells caches which request headers affect the response, so they should be part of the cache key",
        "Varies the response format randomly",
        "Lists alternative URIs for the resource"
      ],
      "correct": 1,
      "explanation": "Vary: Accept means the response depends on the Accept header — a cache should store separate versions for clients requesting JSON vs XML. Vary: Authorization means each user gets a different response.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Prefer the approach that keeps client behavior explicit while preserving evolvability. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Redis Documentation",
          "url": "https://redis.io/docs/latest/"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-083",
      "type": "ordering",
      "question": "Rank these approaches for handling partial failures in a batch API, from simplest to most robust:",
      "items": [
        "Fail the entire batch if any item fails",
        "Return 207 Multi-Status with per-item results",
        "Process each item independently, return mixed results"
      ],
      "correctOrder": [0, 2, 1],
      "explanation": "All-or-nothing is simplest to implement and reason about. Independent processing is moderate — just process each and report. 207 Multi-Status is the most robust — it gives per-item status codes, letting clients handle each failure individually.",
      "detailedExplanation": "In interviews and real systems work, begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Order by relative scale and bottleneck effect, then validate neighboring items. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Numbers such as 207 should be normalized first so downstream reasoning stays consistent. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-084",
      "type": "multiple-choice",
      "question": "What's the purpose of the Link header in HTTP?",
      "options": [
        "Linking to the API documentation",
        "Providing relationships between resources (pagination, related resources)",
        "Linking stylesheets",
        "Creating hyperlinks in JSON"
      ],
      "correct": 1,
      "explanation": "The Link header provides relationships between the current resource and others. Common use: pagination links (Link: </users?page=2>; rel=\"next\"). It's a lightweight alternative to putting links in the response body.",
      "detailedExplanation": "In interviews and real systems work, anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Prefer the approach that keeps client behavior explicit while preserving evolvability. Interface decisions should be justified by contract stability and client impact over time. Numbers such as 2 should be normalized first so downstream reasoning stays consistent. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-085",
      "type": "multi-select",
      "question": "Which are good reasons to use PATCH instead of PUT for updates?",
      "options": [
        "The client only knows which fields changed",
        "The resource is large and sending the whole thing wastes bandwidth",
        "You want the update to be idempotent",
        "Concurrent partial updates are less likely to conflict"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "PATCH is better when clients know only the delta, when resources are large, and for reducing conflict surface (two patches to different fields don't overwrite each other). PUT is actually more idempotent than PATCH, so that's not a reason to choose PATCH.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Evaluate each candidate approach independently under the same constraints. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-086",
      "type": "multiple-choice",
      "question": "An endpoint GET /reports/monthly returns a different report depending on the current date. Is this RESTful?",
      "options": [
        "Yes — the resource representation changes over time, which is fine",
        "No — REST resources must be immutable",
        "Only if Cache-Control is set correctly",
        "Only if the report has a unique URI like /reports/2024-01"
      ],
      "correct": 0,
      "explanation": "REST resources can have representations that change over time. 'The current monthly report' is a valid resource. It's RESTful as long as the same URI consistently identifies the same concept. Consider also providing stable URIs like /reports/2024-01 for historical access.",
      "detailedExplanation": "Generalize from endpoint GET /reports/monthly returns a different report depending on the current date to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Numbers such as 2024 and 01 should be normalized first so downstream reasoning stays consistent. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Compound annual growth rate",
          "url": "https://www.investopedia.com/terms/c/cagr.asp"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-087",
      "type": "multiple-choice",
      "question": "What's the maximum practical length for a URL?",
      "options": [
        "256 characters (HTTP spec)",
        "~2,000 characters (browser/server limits)",
        "Unlimited in HTTP, but 8KB is a common server limit",
        "It depends on the HTTP method"
      ],
      "correct": 1,
      "explanation": "HTTP itself doesn't limit URL length, but browsers (especially older IE at 2,083 chars) and servers (Apache defaults to 8KB) impose practical limits. Keep URLs under ~2,000 characters to be safe. If you need more, use POST with a body.",
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Interface decisions should be justified by contract stability and client impact over time. If values like 2,083 and 8KB appear, convert them into one unit basis before comparison. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-088",
      "type": "multiple-choice",
      "question": "A REST API returns user data. Which response is better designed?",
      "options": [
        "{\"data\": {\"id\": 42, \"name\": \"Alice\"}}",
        "{\"id\": 42, \"name\": \"Alice\"}",
        "Both are valid — envelope vs. bare resource is a style choice",
        "{\"status\": \"success\", \"data\": {\"id\": 42, \"name\": \"Alice\"}}"
      ],
      "correct": 2,
      "explanation": "Both are valid. Bare resource is simpler and more direct. Enveloped ({data: ...}) reserves space for metadata (pagination, errors). Choose one and be consistent. Avoid redundant fields like 'status: success' — that's what HTTP status codes are for.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-089",
      "type": "multiple-choice",
      "question": "What HTTP status code should an API return if the endpoint exists but the specific resource ID doesn't?",
      "options": [
        "400 Bad Request",
        "404 Not Found",
        "410 Gone",
        "204 No Content"
      ],
      "correct": 1,
      "explanation": "404 Not Found — the URI is valid but no resource exists at that location. 410 Gone would mean it used to exist and has been intentionally removed (useful for SEO/caching). 400 would mean the request itself was malformed.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Good API choices balance client ergonomics, compatibility, and long-term evolvability. If values like 404 and 410 appear, convert them into one unit basis before comparison. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-090",
      "type": "multiple-choice",
      "question": "When should you use 410 Gone instead of 404 Not Found?",
      "options": [
        "Always, for deleted resources",
        "When the resource was intentionally deleted and will never return",
        "When the server is shutting down",
        "Never — 404 is always sufficient"
      ],
      "correct": 1,
      "explanation": "410 Gone means the resource existed, has been intentionally removed, and the URI won't be reused. This tells search engines to deindex, caches to purge, and clients to stop retrying. 404 is more ambiguous — the resource might appear later.",
      "detailedExplanation": "In interviews and real systems work, begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Discard options that weaken contract clarity or compatibility over time. Prioritize explicit semantics and upgrade safety, not just short-term convenience. If values like 410 and 404 appear, convert them into one unit basis before comparison. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-091",
      "type": "two-stage",
      "stages": [
        {
          "question": "You expose a REST API for managing a queue of tasks. Clients should be able to take the next available task. What's the most RESTful way to model 'take next task'?",
          "options": [
            "GET /tasks/next",
            "POST /tasks/next/claim",
            "POST /task-assignments with no body (server picks the next task)",
            "DELETE /tasks/queue/front"
          ],
          "correct": 2,
          "explanation": "POST /task-assignments models the action as creating a resource (an assignment). The server selects the next task and returns the assignment with the task details. This is RESTful — it's a noun (assignment) created via POST.",
          "detailedExplanation": "In interviews and real systems work, anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Solve this as chained reasoning where stage two must respect stage one assumptions. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: interface design coupled too tightly to internal implementation."
        },
        {
          "question": "What should the response include?",
          "options": [
            "Just 201 Created with no body",
            "201 Created with the assignment resource (including task details and a Location header)",
            "200 OK with the task that was assigned",
            "202 Accepted with a polling URL"
          ],
          "correct": 1,
          "explanation": "201 Created with the full assignment resource (who, what task, when) and a Location header pointing to the assignment. This gives the client everything it needs: what task to work on and a URI to update when done.",
          "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Good API choices balance client ergonomics, compatibility, and long-term evolvability. If values like 201 appear, convert them into one unit basis before comparison. Common pitfall: breaking clients during version evolution."
        }
      ],
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Solve this as chained reasoning where stage two must respect stage one assumptions. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-092",
      "type": "multi-select",
      "question": "Which are valid ways to represent sub-resources in REST?",
      "options": [
        "/users/42/avatar (a user's avatar)",
        "/users/42/posts (a user's posts)",
        "/users/42.json (format suffix)",
        "/users/42/posts/7/comments (deeply nested)"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Sub-resources like /users/42/avatar, /users/42/posts, and deeper nesting /users/42/posts/7/comments are all valid REST patterns. Format suffixes (.json) are not sub-resources — they're an alternative to content negotiation via Accept headers.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Validate each proposed control independently and avoid partially true claims that fail under realistic load. Interface decisions should be justified by contract stability and client impact over time. Numbers such as 42 and 7 should be normalized first so downstream reasoning stays consistent. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-093",
      "type": "multiple-choice",
      "question": "How deep should REST URI nesting go?",
      "options": [
        "No limit — nest as deep as the data model requires",
        "Maximum 1 level (/users/42)",
        "Practical limit of 2-3 levels — deeper nesting becomes unwieldy",
        "Exactly 2 levels always"
      ],
      "correct": 2,
      "explanation": "2-3 levels is a practical guideline. /users/42/posts/7/comments is fine; /users/42/posts/7/comments/99/reactions/likes is too deep. For deeply nested resources, promote them to top-level with query filters: /comments?postId=7.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Prefer the approach that keeps client behavior explicit while preserving evolvability. Prioritize explicit semantics and upgrade safety, not just short-term convenience. If values like 2 and 3 appear, convert them into one unit basis before comparison. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-094",
      "type": "multiple-choice",
      "question": "What's the problem with this URI: GET /users/42/posts/7?",
      "options": [
        "Nothing — it's correctly nested",
        "If post 7 has a unique ID regardless of user, the user prefix is redundant",
        "It should be a POST request",
        "The IDs should be UUIDs, not integers"
      ],
      "correct": 1,
      "explanation": "If posts have globally unique IDs, GET /posts/7 is sufficient and simpler. The /users/42 prefix adds no information and forces clients to know the user ID. Nesting is useful when the child's identity depends on the parent (like /users/42/preferences).",
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Prefer the approach that keeps client behavior explicit while preserving evolvability. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Keep quantities like 42 and 7 in aligned units before deciding on an implementation approach. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-095",
      "type": "multiple-choice",
      "question": "Should REST APIs return null fields or omit them entirely?",
      "options": [
        "Always include null fields for consistency",
        "Always omit null fields to reduce payload size",
        "Either is fine, but be consistent across the API",
        "Use a separate endpoint for null-checking"
      ],
      "correct": 2,
      "explanation": "Both approaches have tradeoffs. Including nulls is explicit and consistent (clients always know the shape). Omitting saves bandwidth. The key is consistency — don't include nulls for some fields and omit others arbitrarily.",
      "detailedExplanation": "Generalize from should REST APIs return null fields or omit them entirely to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Discard options that weaken contract clarity or compatibility over time. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-096",
      "type": "multiple-choice",
      "question": "Which naming convention is standard for JSON field names in REST APIs?",
      "options": [
        "snake_case (user_name)",
        "camelCase (userName)",
        "PascalCase (UserName)",
        "No universal standard — match your ecosystem"
      ],
      "correct": 3,
      "explanation": "No universal standard exists. JavaScript ecosystems favor camelCase, Ruby/Python favor snake_case, .NET favors PascalCase. Google's JSON style guide uses camelCase. The most important thing is consistency within your API.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-098",
      "type": "ordering",
      "question": "Rank these from most commonly used to least commonly used in typical REST APIs:",
      "items": ["GET", "TRACE", "POST", "DELETE"],
      "correctOrder": [0, 2, 3, 1],
      "explanation": "GET is by far the most common (reads). POST is next (creates, actions). DELETE is common but less frequent. TRACE is almost never used in APIs — it's a debugging method that echoes the request back, and is often disabled for security.",
      "detailedExplanation": "In interviews and real systems work, begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Place obvious extremes first, then sort the middle by pairwise comparison. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-099",
      "type": "multiple-choice",
      "question": "An HTTPS client must tunnel through an HTTP proxy to reach the origin server. Which HTTP method establishes the tunnel?",
      "options": [
        "Connecting to a database",
        "Establishing a tunnel through a proxy (e.g., for HTTPS)",
        "Opening a WebSocket connection",
        "Testing connectivity to the server"
      ],
      "correct": 1,
      "explanation": "CONNECT establishes a tunnel through an HTTP proxy, typically for HTTPS connections. The client asks the proxy to relay raw TCP to the target server. It's not used directly in REST API design.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Prefer the approach that keeps client behavior explicit while preserving evolvability. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "rest-100",
      "type": "two-stage",
      "stages": [
        {
          "question": "Your REST API uses sequential integer IDs (/users/1, /users/2, ...). A competitor starts scraping all your users by incrementing the ID. What's the vulnerability?",
          "options": [
            "SQL injection",
            "Insecure Direct Object Reference (IDOR) — predictable IDs enable enumeration",
            "Cross-site scripting",
            "Man-in-the-middle attack"
          ],
          "correct": 1,
          "explanation": "Sequential IDs let attackers enumerate all resources by incrementing the ID. This is an IDOR vulnerability. Even with authentication, users might access other users' resources if authorization checks are missing.",
          "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Solve this as chained reasoning where stage two must respect stage one assumptions. Interface decisions should be justified by contract stability and client impact over time. Numbers such as 1 and 2 should be normalized first so downstream reasoning stays consistent. Common pitfall: breaking clients during version evolution."
        },
        {
          "question": "Which mitigation addresses enumeration while keeping the REST pattern?",
          "options": [
            "Use UUIDs instead of sequential IDs",
            "Rate limit all requests",
            "Require authentication",
            "Obfuscate IDs with a reversible cipher"
          ],
          "correct": 0,
          "explanation": "UUIDs make IDs unguessable, preventing enumeration. Rate limiting slows attacks but doesn't prevent them. Authentication doesn't help if authorization checks are missing. Obfuscation through obscurity is fragile. UUIDs plus proper authorization checks is the robust solution.",
          "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: interface design coupled too tightly to internal implementation."
        }
      ],
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "rest-fundamentals"],
      "difficulty": "senior"
    }
  ]
}
