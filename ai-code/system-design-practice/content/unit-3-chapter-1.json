{
  "unit": 3,
  "unitTitle": "API Design",
  "chapter": 1,
  "chapterTitle": "REST Fundamentals",
  "chapterDescription": "HTTP methods, status codes, resource naming, and idempotency.",
  "problems": [
    {
      "id": "rest-001",
      "type": "multiple-choice",
      "question": "Which HTTP method should you use to create a new resource when the server assigns the ID?",
      "options": ["GET", "POST", "PUT", "PATCH"],
      "correct": 1,
      "explanation": "POST is used to create a resource when the server determines the URI. PUT is used when the client specifies the full URI of the resource being created or replaced.",
      "detailedExplanation": "POST is used to create a resource when the server determines the URI. PUT is used when the client specifies the full URI of the resource being created or replaced. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-002",
      "type": "multiple-choice",
      "question": "Which HTTP method is idempotent but NOT safe?",
      "options": ["GET", "POST", "PUT", "HEAD"],
      "correct": 2,
      "explanation": "PUT is idempotent (repeating it produces the same result) but not safe (it modifies server state). GET and HEAD are both safe and idempotent. POST is neither safe nor idempotent.",
      "detailedExplanation": "PUT is idempotent (repeating it produces the same result) but not safe (it modifies server state). GET and HEAD are both safe and idempotent. POST is neither safe nor idempotent. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-003",
      "type": "multi-select",
      "question": "Which HTTP methods are idempotent?",
      "options": ["GET", "POST", "PUT", "DELETE"],
      "correctIndices": [0, 2, 3],
      "explanation": "GET, PUT, and DELETE are idempotent — repeating them has the same effect as a single call. POST is not idempotent; each call may create a new resource.",
      "detailedExplanation": "GET, PUT, and DELETE are idempotent — repeating them has the same effect as a single call. POST is not idempotent; each call may create a new resource. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-004",
      "type": "multiple-choice",
      "question": "A client sends DELETE /users/42 twice. What should the second response be?",
      "options": [
        "200 OK with the deleted user",
        "204 No Content",
        "404 Not Found",
        "Either 204 or 404 — both are valid"
      ],
      "correct": 3,
      "explanation": "Both are valid REST implementations. Some APIs return 204 on repeated deletes (emphasizing idempotency of effect), others return 404 (the resource no longer exists). The key is that server state is the same either way.",
      "detailedExplanation": "Both are valid REST implementations. Some APIs return 204 on repeated deletes (emphasizing idempotency of effect), others return 404 (the resource no longer exists). The key is that server state is the same either way. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-005",
      "type": "multiple-choice",
      "question": "What's the difference between PUT and PATCH?",
      "options": [
        "PUT creates, PATCH updates",
        "PUT replaces the entire resource, PATCH applies a partial update",
        "PUT is idempotent, PATCH is not",
        "There is no practical difference"
      ],
      "correct": 1,
      "explanation": "PUT replaces the entire resource representation. PATCH applies a partial modification. Both can be used for updates, but PUT requires sending the complete resource while PATCH only requires the changed fields.",
      "detailedExplanation": "PUT replaces the entire resource representation. PATCH applies a partial modification. Both can be used for updates, but PUT requires sending the complete resource while PATCH only requires the changed fields. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-007",
      "type": "multiple-choice",
      "question": "A POST request kicks off a long-running job. Which status code is most appropriate?",
      "options": ["200 OK", "201 Created", "202 Accepted", "204 No Content"],
      "correct": 2,
      "explanation": "202 Accepted means the request has been accepted for processing but is not yet complete. The client can poll for status later. 201 would imply the resource is already created.",
      "detailedExplanation": "202 Accepted means the request has been accepted for processing but is not yet complete. The client can poll for status later. 201 would imply the resource is already created. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-008",
      "type": "ordering",
      "question": "Rank these status codes from most to least specific for a 'validation error on input data':",
      "items": [
        "400 Bad Request",
        "422 Unprocessable Entity",
        "500 Internal Server Error"
      ],
      "correctOrder": [1, 0, 2],
      "explanation": "422 is most specific (syntactically valid but semantically invalid input). 400 is broader (malformed request). 500 is wrong — validation errors are client errors, not server errors.",
      "detailedExplanation": "422 is most specific (syntactically valid but semantically invalid input). 400 is broader (malformed request). 500 is wrong — validation errors are client errors, not server errors. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-009",
      "type": "multiple-choice",
      "question": "What does a 401 status code mean?",
      "options": [
        "The resource doesn't exist",
        "The request is forbidden",
        "Authentication is required",
        "The method is not allowed"
      ],
      "correct": 2,
      "explanation": "401 Unauthorized actually means 'unauthenticated' — the client hasn't provided valid credentials. 403 Forbidden means authenticated but not authorized. The naming is a well-known misnomer in HTTP.",
      "detailedExplanation": "401 Unauthorized actually means 'unauthenticated' — the client hasn't provided valid credentials. 403 Forbidden means authenticated but not authorized. The naming is a well-known misnomer in HTTP. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-010",
      "type": "multiple-choice",
      "question": "What's the difference between 401 and 403?",
      "options": [
        "401 is for GET, 403 is for POST",
        "401 means not authenticated, 403 means authenticated but not authorized",
        "401 is temporary, 403 is permanent",
        "They are interchangeable"
      ],
      "correct": 1,
      "explanation": "401 means the server doesn't know who you are (missing or invalid credentials). 403 means the server knows who you are but you don't have permission. Logging in can fix a 401; a 403 requires different permissions.",
      "detailedExplanation": "401 means the server doesn't know who you are (missing or invalid credentials). 403 means the server knows who you are but you don't have permission. Logging in can fix a 401; a 403 requires different permissions. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-011",
      "type": "multi-select",
      "question": "Which are client error status codes (4xx)?",
      "options": [
        "400 Bad Request",
        "404 Not Found",
        "409 Conflict",
        "503 Service Unavailable"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "400, 404, and 409 are all 4xx client errors. 503 is a 5xx server error indicating the server is temporarily unavailable.",
      "detailedExplanation": "400, 404, and 409 are all 4xx client errors. 503 is a 5xx server error indicating the server is temporarily unavailable. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-012",
      "type": "multiple-choice",
      "question": "Which status code is most appropriate when a client tries to create a resource that already exists?",
      "options": [
        "400 Bad Request",
        "403 Forbidden",
        "409 Conflict",
        "422 Unprocessable Entity"
      ],
      "correct": 2,
      "explanation": "409 Conflict indicates the request conflicts with the current state of the server — a duplicate resource is a state conflict. 400 is too vague, 422 is for validation errors, 403 is for permissions.",
      "detailedExplanation": "409 Conflict indicates the request conflicts with the current state of the server — a duplicate resource is a state conflict. 400 is too vague, 422 is for validation errors, 403 is for permissions. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-013",
      "type": "multiple-choice",
      "question": "Which URI follows REST naming conventions?",
      "options": [
        "GET /getUsers",
        "GET /users",
        "GET /user/list",
        "GET /api/fetchAllUsers"
      ],
      "correct": 1,
      "explanation": "REST uses nouns (not verbs) for resource URIs, and plural forms for collections. The HTTP method (GET) already implies the action, so 'getUsers' and 'fetchAllUsers' are redundant.",
      "detailedExplanation": "REST uses nouns (not verbs) for resource URIs, and plural forms for collections. The HTTP method (GET) already implies the action, so 'getUsers' and 'fetchAllUsers' are redundant. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-014",
      "type": "multiple-choice",
      "question": "Which URI best represents a specific user's orders?",
      "options": [
        "/orders?userId=42",
        "/users/42/orders",
        "/getUserOrders/42",
        "/users/orders/42"
      ],
      "correct": 1,
      "explanation": "Nested resources use the pattern /parent/{id}/child. /users/42/orders clearly expresses 'orders belonging to user 42'. Query params work but don't express the hierarchy as cleanly.",
      "detailedExplanation": "Nested resources use the pattern /parent/{id}/child. /users/42/orders clearly expresses 'orders belonging to user 42'. Query params work but don't express the hierarchy as cleanly. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-015",
      "type": "multi-select",
      "question": "Which URIs follow REST naming conventions?",
      "options": [
        "GET /users/42",
        "POST /users/create",
        "DELETE /users/42",
        "PUT /users/42/update"
      ],
      "correctIndices": [0, 2],
      "explanation": "GET /users/42 and DELETE /users/42 follow REST conventions — the HTTP method implies the action. /users/create and /users/42/update embed verbs in the URI, which is an RPC pattern, not REST.",
      "detailedExplanation": "GET /users/42 and DELETE /users/42 follow REST conventions — the HTTP method implies the action. /users/create and /users/42/update embed verbs in the URI, which is an RPC pattern, not REST. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-016",
      "type": "multiple-choice",
      "question": "Should REST URIs use plural or singular nouns?",
      "options": [
        "Always singular (/user/42)",
        "Always plural (/users/42)",
        "Plural for collections, singular for items",
        "It doesn't matter as long as you're consistent"
      ],
      "correct": 1,
      "explanation": "Convention is to always use plural nouns: /users for the collection and /users/42 for a specific item. This keeps URIs consistent — you don't need to know whether you're addressing a collection or item to know the base path.",
      "detailedExplanation": "Convention is to always use plural nouns: /users for the collection and /users/42 for a specific item. This keeps URIs consistent — you don't need to know whether you're addressing a collection or item to know the base path. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-017",
      "type": "multiple-choice",
      "question": "A client needs to transfer funds between two bank accounts. Which approach is most RESTful?",
      "options": [
        "POST /transfer with from/to/amount in the body",
        "PUT /accounts/42/balance with the new balance",
        "POST /transactions with from/to/amount in the body",
        "PATCH /accounts/42 and PATCH /accounts/43 in sequence"
      ],
      "correct": 2,
      "explanation": "POST /transactions models the transfer as creating a new resource (a transaction). This is RESTful — it treats the action as a noun. Two separate PATCHes aren't atomic, and PUT on balance ignores the other account.",
      "detailedExplanation": "POST /transactions models the transfer as creating a new resource (a transaction). This is RESTful — it treats the action as a noun. Two separate PATCHes aren't atomic, and PUT on balance ignores the other account. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-018",
      "type": "multiple-choice",
      "question": "Which HTTP header tells the server what format the client wants in the response?",
      "options": [
        "Content-Type",
        "Accept",
        "Authorization",
        "X-Response-Format"
      ],
      "correct": 1,
      "explanation": "The Accept header specifies the media types the client can handle (e.g., application/json). Content-Type describes the format of the request body, not the desired response format.",
      "detailedExplanation": "The Accept header specifies the media types the client can handle (e.g., application/json). Content-Type describes the format of the request body, not the desired response format. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-019",
      "type": "multiple-choice",
      "question": "Which HTTP header describes the format of the request body?",
      "options": [
        "Accept",
        "Content-Type",
        "Content-Length",
        "Transfer-Encoding"
      ],
      "correct": 1,
      "explanation": "Content-Type tells the server the media type of the request body (e.g., application/json). Accept is what the client wants back. Content-Length is the size in bytes.",
      "detailedExplanation": "Content-Type tells the server the media type of the request body (e.g., application/json). Accept is what the client wants back. Content-Length is the size in bytes. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-020",
      "type": "two-stage",
      "stages": [
        {
          "question": "A client sends PUT /users/42 with a complete user object, but user 42 doesn't exist yet. What should happen?",
          "options": [
            "Return 404 Not Found",
            "Create the resource and return 201 Created",
            "Return 400 Bad Request",
            "Return 409 Conflict"
          ],
          "correct": 1,
          "explanation": "PUT is defined as 'create or replace.' If the resource doesn't exist at the given URI, the server should create it and return 201. This is the key difference from PATCH, which only updates existing resources.",
          "detailedExplanation": "PUT is defined as 'create or replace.' If the resource doesn't exist at the given URI, the server should create it and return 201. This is the key difference from PATCH, which only updates existing resources. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "Now the client sends the same PUT /users/42 again with identical data. What should the response be?",
          "options": [
            "201 Created again",
            "200 OK (resource unchanged)",
            "409 Conflict",
            "304 Not Modified"
          ],
          "correct": 1,
          "explanation": "The resource already exists and the data is the same, so 200 OK is appropriate. This demonstrates PUT's idempotency — the first call creates (201), subsequent identical calls have no additional effect (200).",
          "detailedExplanation": "The resource already exists and the data is the same, so 200 OK is appropriate. This demonstrates PUT's idempotency — the first call creates (201), subsequent identical calls have no additional effect (200). Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-021",
      "type": "multiple-choice",
      "question": "Which HTTP method should NOT have a request body?",
      "options": ["POST", "PUT", "GET", "PATCH"],
      "correct": 2,
      "explanation": "GET requests should not have a body — semantics of a GET body are undefined in HTTP, and many intermediaries (proxies, CDNs) will strip or ignore it. Use query parameters instead.",
      "detailedExplanation": "GET requests should not have a body — semantics of a GET body are undefined in HTTP, and many intermediaries (proxies, CDNs) will strip or ignore it. Use query parameters instead. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-022",
      "type": "ordering",
      "question": "Rank these HTTP methods from safest to least safe (in terms of side effects):",
      "items": ["GET", "DELETE", "POST", "PUT"],
      "correctOrder": [0, 3, 1, 2],
      "explanation": "GET is safe (no side effects). PUT and DELETE are unsafe but idempotent (repeatable). POST is the least safe — it's neither safe nor idempotent. PUT before DELETE because PUT's replace semantics are more predictable.",
      "detailedExplanation": "GET is safe (no side effects). PUT and DELETE are unsafe but idempotent (repeatable). POST is the least safe — it's neither safe nor idempotent. PUT before DELETE because PUT's replace semantics are more predictable. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-023",
      "type": "multiple-choice",
      "question": "What does 'safe' mean for an HTTP method?",
      "options": [
        "It uses HTTPS",
        "It doesn't modify server state",
        "It's idempotent",
        "It requires authentication"
      ],
      "correct": 1,
      "explanation": "A 'safe' HTTP method doesn't modify server state. GET and HEAD are safe — they only retrieve data. Safe methods can still have side effects (like logging), but they must not change resources.",
      "detailedExplanation": "A 'safe' HTTP method doesn't modify server state. GET and HEAD are safe — they only retrieve data. Safe methods can still have side effects (like logging), but they must not change resources. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-024",
      "type": "multiple-choice",
      "question": "A mobile app needs to check if a resource exists without downloading its body. Which method?",
      "options": ["GET", "HEAD", "OPTIONS", "TRACE"],
      "correct": 1,
      "explanation": "HEAD is identical to GET but returns only headers, no body. It's useful for checking existence (via status code) or metadata (Content-Length, Last-Modified) without transferring the full response.",
      "detailedExplanation": "HEAD is identical to GET but returns only headers, no body. It's useful for checking existence (via status code) or metadata (Content-Length, Last-Modified) without transferring the full response. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-025",
      "type": "multiple-choice",
      "question": "What is the OPTIONS method used for?",
      "options": [
        "Setting configuration options on a resource",
        "Describing the communication options for the target resource",
        "Listing available resources",
        "Checking if the server is alive"
      ],
      "correct": 1,
      "explanation": "OPTIONS returns the allowed HTTP methods and other communication options for a resource. Browsers send OPTIONS as a CORS preflight request to check if a cross-origin request is permitted.",
      "detailedExplanation": "OPTIONS returns the allowed HTTP methods and other communication options for a resource. Browsers send OPTIONS as a CORS preflight request to check if a cross-origin request is permitted. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-026",
      "type": "multiple-choice",
      "question": "What status code indicates the server understood the request but refuses to fulfill it, and authentication won't help?",
      "options": [
        "401 Unauthorized",
        "403 Forbidden",
        "405 Method Not Allowed",
        "406 Not Acceptable"
      ],
      "correct": 1,
      "explanation": "403 Forbidden means the server understood the request and the client's identity, but the client doesn't have permission. Re-authenticating won't change the outcome — different authorization is needed.",
      "detailedExplanation": "403 Forbidden means the server understood the request and the client's identity, but the client doesn't have permission. Re-authenticating won't change the outcome — different authorization is needed. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-027",
      "type": "multiple-choice",
      "question": "Which status code means 'the HTTP method is not supported for this endpoint'?",
      "options": [
        "400 Bad Request",
        "404 Not Found",
        "405 Method Not Allowed",
        "501 Not Implemented"
      ],
      "correct": 2,
      "explanation": "405 Method Not Allowed means the resource exists but doesn't support the HTTP method used. The response should include an Allow header listing valid methods. 501 means the server doesn't recognize the method at all.",
      "detailedExplanation": "405 Method Not Allowed means the resource exists but doesn't support the HTTP method used. The response should include an Allow header listing valid methods. 501 means the server doesn't recognize the method at all. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-028",
      "type": "multiple-choice",
      "question": "Which status code is correct for a successful DELETE that returns no body?",
      "options": ["200 OK", "201 Created", "204 No Content", "202 Accepted"],
      "correct": 2,
      "explanation": "204 No Content means the action succeeded and there's nothing to return in the body. 200 OK is also valid if you include a response body (like the deleted resource or a confirmation message).",
      "detailedExplanation": "204 No Content means the action succeeded and there's nothing to return in the body. 200 OK is also valid if you include a response body (like the deleted resource or a confirmation message). Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-029",
      "type": "two-stage",
      "stages": [
        {
          "question": "An API has POST /orders to create an order. A network failure occurs after the server processes the request but before the client receives the response. The client retries. What happens?",
          "options": [
            "The server rejects the duplicate",
            "A duplicate order is created",
            "The server returns the original order",
            "Depends on the implementation"
          ],
          "correct": 3,
          "explanation": "POST is not idempotent by default. Without additional safeguards, a retry could create a duplicate. The behavior depends entirely on whether the server implements duplicate detection.",
          "detailedExplanation": "POST is not idempotent by default. Without additional safeguards, a retry could create a duplicate. The behavior depends entirely on whether the server implements duplicate detection. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "What's the standard mechanism to make this POST idempotent?",
          "options": [
            "Use PUT instead",
            "Send an Idempotency-Key header with a client-generated unique ID",
            "Include a timestamp in the body",
            "Use HTTPS to prevent network failures"
          ],
          "correct": 1,
          "explanation": "An Idempotency-Key header (popularized by Stripe) lets the server detect retries. The server stores the key and returns the original response for duplicate requests. PUT would work if the client knows the URI, but POST with idempotency keys is more flexible.",
          "detailedExplanation": "An Idempotency-Key header (popularized by Stripe) lets the server detect retries. The server stores the key and returns the original response for duplicate requests. PUT would work if the client knows the URI, but POST with idempotency keys is more flexible. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-030",
      "type": "multiple-choice",
      "question": "Why is POST not considered idempotent?",
      "options": [
        "It always modifies server state",
        "Sending the same POST request twice may produce different results (e.g., two resources created)",
        "It can't be cached",
        "It requires a request body"
      ],
      "correct": 1,
      "explanation": "Idempotency means repeated identical requests produce the same server state. POST /orders with the same data could create two separate orders, so the server state differs. That's why POST is not idempotent.",
      "detailedExplanation": "Idempotency means repeated identical requests produce the same server state. POST /orders with the same data could create two separate orders, so the server state differs. That's why POST is not idempotent. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-031",
      "type": "multi-select",
      "question": "Which are safe HTTP methods?",
      "options": ["GET", "HEAD", "OPTIONS", "DELETE"],
      "correctIndices": [0, 1, 2],
      "explanation": "GET, HEAD, and OPTIONS are safe — they don't modify server state. DELETE is unsafe (it removes a resource) even though it's idempotent.",
      "detailedExplanation": "GET, HEAD, and OPTIONS are safe — they don't modify server state. DELETE is unsafe (it removes a resource) even though it's idempotent. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-032",
      "type": "multiple-choice",
      "question": "Which URI pattern is correct for getting all comments on post 7?",
      "options": [
        "/comments?post=7",
        "/posts/7/comments",
        "/posts/comments/7",
        "/getCommentsByPost/7"
      ],
      "correct": 1,
      "explanation": "Nested resource pattern: /posts/7/comments expresses the parent-child relationship clearly. Query params work but don't convey hierarchy. Verbs in URIs break REST conventions.",
      "detailedExplanation": "Nested resource pattern: /posts/7/comments expresses the parent-child relationship clearly. Query params work but don't convey hierarchy. Verbs in URIs break REST conventions. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-033",
      "type": "multiple-choice",
      "question": "How should you name a REST endpoint that searches for users?",
      "options": [
        "GET /users/search?q=john",
        "POST /users/search with body",
        "GET /users?q=john",
        "GET /searchUsers?q=john"
      ],
      "correct": 2,
      "explanation": "Searching is a filtered GET on the collection: GET /users?q=john. Query parameters are the standard way to filter collections. Adding /search as a sub-resource or using verbs in URIs are less RESTful.",
      "detailedExplanation": "Searching is a filtered GET on the collection: GET /users?q=john. Query parameters are the standard way to filter collections. Adding /search as a sub-resource or using verbs in URIs are less RESTful. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-034",
      "type": "multiple-choice",
      "question": "Which URI convention is preferred for multi-word resource names?",
      "options": [
        "camelCase: /userProfiles",
        "snake_case: /user_profiles",
        "kebab-case: /user-profiles",
        "No convention exists"
      ],
      "correct": 2,
      "explanation": "Kebab-case (hyphens) is the convention for URIs because URIs are case-insensitive by convention, making camelCase unreliable. Hyphens are also more readable in URLs than underscores.",
      "detailedExplanation": "Kebab-case (hyphens) is the convention for URIs because URIs are case-insensitive by convention, making camelCase unreliable. Hyphens are also more readable in URLs than underscores. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-035",
      "type": "multiple-choice",
      "question": "A REST API returns a newly created resource. Which header should point to its canonical URI?",
      "options": ["Content-Location", "Location", "Link", "Referer"],
      "correct": 1,
      "explanation": "The Location header in a 201 Created response provides the URI of the newly created resource. This lets the client immediately know how to access it.",
      "detailedExplanation": "The Location header in a 201 Created response provides the URI of the newly created resource. This lets the client immediately know how to access it. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-036",
      "type": "multiple-choice",
      "question": "What's the REST term for including related resources in a response to reduce round trips?",
      "options": [
        "Eager loading",
        "Resource embedding",
        "Compound documents",
        "All of these describe the same concept"
      ],
      "correct": 3,
      "explanation": "All of these terms describe including related resources in a single response. JSON:API calls them 'compound documents,' HAL calls it 'embedding,' and ORMs call it 'eager loading.' The goal is reducing N+1 HTTP requests.",
      "detailedExplanation": "All of these terms describe including related resources in a single response. JSON:API calls them 'compound documents,' HAL calls it 'embedding,' and ORMs call it 'eager loading.' The goal is reducing N+1 HTTP requests. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-038",
      "type": "multiple-choice",
      "question": "Which 3xx status code indicates the resource has permanently moved to a new URI?",
      "options": [
        "301 Moved Permanently",
        "302 Found",
        "304 Not Modified",
        "307 Temporary Redirect"
      ],
      "correct": 0,
      "explanation": "301 Moved Permanently tells the client (and search engines) to use the new URI from now on. 302/307 are temporary redirects. 304 is a conditional response, not a redirect.",
      "detailedExplanation": "301 Moved Permanently tells the client (and search engines) to use the new URI from now on. 302/307 are temporary redirects. 304 is a conditional response, not a redirect. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-039",
      "type": "multiple-choice",
      "question": "When should you use 304 Not Modified?",
      "options": [
        "When a PATCH request doesn't change anything",
        "When the client's cached version is still current",
        "When the server hasn't been updated recently",
        "When the request is a duplicate"
      ],
      "correct": 1,
      "explanation": "304 Not Modified is used with conditional requests (If-None-Match, If-Modified-Since). The server tells the client its cached version is still valid, saving bandwidth by not resending the body.",
      "detailedExplanation": "304 Not Modified is used with conditional requests (If-None-Match, If-Modified-Since). The server tells the client its cached version is still valid, saving bandwidth by not resending the body. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        }
      ]
    },
    {
      "id": "rest-040",
      "type": "two-stage",
      "stages": [
        {
          "question": "A client sends GET /users/42 with an If-None-Match header containing the current ETag. What should the server return?",
          "options": [
            "200 OK with the full user object",
            "304 Not Modified with no body",
            "204 No Content",
            "400 Bad Request"
          ],
          "correct": 1,
          "explanation": "If the ETag matches (resource hasn't changed), the server returns 304 Not Modified with no body. The client uses its cached version. This saves bandwidth and reduces server load.",
          "detailedExplanation": "If the ETag matches (resource hasn't changed), the server returns 304 Not Modified with no body. The client uses its cached version. This saves bandwidth and reduces server load. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "Another client sends the same GET /users/42 with an outdated ETag. What should the server return?",
          "options": [
            "304 Not Modified",
            "200 OK with the full user object and the new ETag",
            "409 Conflict",
            "412 Precondition Failed"
          ],
          "correct": 1,
          "explanation": "The ETag doesn't match, so the resource has changed. The server returns 200 OK with the full body and the new ETag. 412 would apply to conditional writes (If-Match), not reads.",
          "detailedExplanation": "The ETag doesn't match, so the resource has changed. The server returns 200 OK with the full body and the new ETag. 412 would apply to conditional writes (If-Match), not reads. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-041",
      "type": "multiple-choice",
      "question": "Which status code means 'the server is currently unable to handle the request due to temporary overload'?",
      "options": [
        "500 Internal Server Error",
        "502 Bad Gateway",
        "503 Service Unavailable",
        "504 Gateway Timeout"
      ],
      "correct": 2,
      "explanation": "503 Service Unavailable indicates a temporary condition — the server is overloaded or down for maintenance. It should include a Retry-After header. 500 is a generic server error, not specifically about capacity.",
      "detailedExplanation": "503 Service Unavailable indicates a temporary condition — the server is overloaded or down for maintenance. It should include a Retry-After header. 500 is a generic server error, not specifically about capacity. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ]
    },
    {
      "id": "rest-042",
      "type": "multiple-choice",
      "question": "What's the difference between 502 and 504?",
      "options": [
        "502 is permanent, 504 is temporary",
        "502 means the upstream server gave an invalid response, 504 means it didn't respond in time",
        "502 is for proxies, 504 is for origin servers",
        "They are interchangeable"
      ],
      "correct": 1,
      "explanation": "Both involve a gateway/proxy. 502 Bad Gateway means the proxy received an invalid response from the upstream server. 504 Gateway Timeout means the upstream server didn't respond at all within the time limit.",
      "detailedExplanation": "Both involve a gateway/proxy. 502 Bad Gateway means the proxy received an invalid response from the upstream server. 504 Gateway Timeout means the upstream server didn't respond at all within the time limit. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-043",
      "type": "multiple-choice",
      "question": "Which status code should a rate limiter return when a client exceeds their quota?",
      "options": [
        "400 Bad Request",
        "403 Forbidden",
        "429 Too Many Requests",
        "503 Service Unavailable"
      ],
      "correct": 2,
      "explanation": "429 Too Many Requests is specifically designed for rate limiting. It should include a Retry-After header. 503 implies the entire service is overloaded, not just this client. 403 suggests a permanent authorization issue.",
      "detailedExplanation": "429 Too Many Requests is specifically designed for rate limiting. It should include a Retry-After header. 503 implies the entire service is overloaded, not just this client. 403 suggests a permanent authorization issue. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ]
    },
    {
      "id": "rest-044",
      "type": "multi-select",
      "question": "Which headers are commonly included in a 429 response?",
      "options": [
        "Retry-After",
        "X-RateLimit-Remaining",
        "X-RateLimit-Reset",
        "Content-Encoding"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "Retry-After tells the client when to retry. X-RateLimit-Remaining and X-RateLimit-Reset (non-standard but widely used) tell the client their remaining quota and when it resets. Content-Encoding is unrelated to rate limiting.",
      "detailedExplanation": "Retry-After tells the client when to retry. X-RateLimit-Remaining and X-RateLimit-Reset (non-standard but widely used) tell the client their remaining quota and when it resets. Content-Encoding is unrelated to rate limiting. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ]
    },
    {
      "id": "rest-045",
      "type": "multiple-choice",
      "question": "Which constraint is NOT part of the REST architectural style?",
      "options": [
        "Statelessness",
        "Uniform interface",
        "Strongly-typed schemas",
        "Layered system"
      ],
      "correct": 2,
      "explanation": "REST's six constraints are: client-server, stateless, cacheable, uniform interface, layered system, and (optional) code on demand. Strongly-typed schemas are a feature of gRPC/GraphQL, not a REST constraint.",
      "detailedExplanation": "REST's six constraints are: client-server, stateless, cacheable, uniform interface, layered system, and (optional) code on demand. Strongly-typed schemas are a feature of gRPC/GraphQL, not a REST constraint. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-046",
      "type": "multiple-choice",
      "question": "What does 'stateless' mean in REST?",
      "options": [
        "The server stores no data at all",
        "Each request contains all information needed to process it — the server stores no client session state",
        "The API has no side effects",
        "Resources never change"
      ],
      "correct": 1,
      "explanation": "Stateless means the server doesn't store session state between requests. Each request is self-contained. The server still stores resource state (database) — it just doesn't store 'client X is on step 3 of checkout.'",
      "detailedExplanation": "Stateless means the server doesn't store session state between requests. Each request is self-contained. The server still stores resource state (database) — it just doesn't store 'client X is on step 3 of checkout.'. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-047",
      "type": "two-stage",
      "stages": [
        {
          "question": "An API stores a 'shopping cart' in a server-side session tied to a cookie. Does this violate REST's statelessness constraint?",
          "options": [
            "No, cookies are part of HTTP",
            "Yes, the server is storing client session state",
            "Only if the cart is in memory, not if it's in a database",
            "It depends on the session timeout"
          ],
          "correct": 1,
          "explanation": "A server-side session is client state stored on the server — the next request depends on previous requests having set up that session. This violates REST's statelessness constraint.",
          "detailedExplanation": "A server-side session is client state stored on the server — the next request depends on previous requests having set up that session. This violates REST's statelessness constraint. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "How would you redesign this to be stateless?",
          "options": [
            "Store the cart as a proper resource: POST /carts, GET /carts/{id}",
            "Store the cart in a JWT token",
            "Use WebSockets instead of HTTP",
            "Increase the session timeout"
          ],
          "correct": 0,
          "explanation": "Model the cart as a first-class resource with its own URI. The client stores the cart ID and sends it with each request. Server-side, the cart is resource state (like any database record), not session state.",
          "detailedExplanation": "Model the cart as a first-class resource with its own URI. The client stores the cart ID and sends it with each request. Server-side, the cart is resource state (like any database record), not session state. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-049",
      "type": "multiple-choice",
      "question": "In practice, what does HATEOAS look like in an API response?",
      "options": [
        "XML instead of JSON",
        "Links in the response body pointing to related resources and available actions",
        "A separate documentation endpoint",
        "Version numbers in every response"
      ],
      "correct": 1,
      "explanation": "HATEOAS responses include hypermedia links like {\"self\": \"/orders/42\", \"cancel\": \"/orders/42/cancel\", \"items\": \"/orders/42/items\"}. The client discovers available actions from the response rather than hardcoding them.",
      "detailedExplanation": "HATEOAS responses include hypermedia links like {\"self\": \"/orders/42\", \"cancel\": \"/orders/42/cancel\", \"items\": \"/orders/42/items\"}. The client discovers available actions from the response rather than hardcoding them. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-050",
      "type": "multiple-choice",
      "question": "How many REST APIs in the wild truly implement HATEOAS?",
      "options": [
        "Most of them",
        "About half",
        "Very few — it's the most commonly ignored REST constraint",
        "None — it's purely theoretical"
      ],
      "correct": 2,
      "explanation": "HATEOAS is the most commonly ignored REST constraint. Most APIs described as 'REST' are really 'HTTP APIs with JSON.' True HATEOAS requires clients to be link-following state machines, which adds complexity most teams don't need.",
      "detailedExplanation": "HATEOAS is the most commonly ignored REST constraint. Most APIs described as 'REST' are really 'HTTP APIs with JSON.' True HATEOAS requires clients to be link-following state machines, which adds complexity most teams don't need. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-051",
      "type": "ordering",
      "question": "Rank these from least RESTful to most RESTful (Richardson Maturity Model):",
      "items": [
        "Plain RPC over HTTP (one endpoint)",
        "Resources with proper URIs",
        "HTTP verbs used correctly",
        "HATEOAS"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "The Richardson Maturity Model: Level 0 (one endpoint, RPC), Level 1 (resources), Level 2 (HTTP verbs), Level 3 (HATEOAS). Each level adds more REST constraints. Most production APIs reach Level 2.",
      "detailedExplanation": "The Richardson Maturity Model: Level 0 (one endpoint, RPC), Level 1 (resources), Level 2 (HTTP verbs), Level 3 (HATEOAS). Each level adds more REST constraints. Most production APIs reach Level 2. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-052",
      "type": "multiple-choice",
      "question": "You need to model an action that doesn't map cleanly to CRUD — e.g., 'lock an account.' What's the most RESTful approach?",
      "options": [
        "POST /accounts/42/lock",
        "PATCH /accounts/42 with {\"status\": \"locked\"}",
        "PUT /accounts/42/lock with empty body",
        "POST /account-locks with {\"accountId\": 42}"
      ],
      "correct": 1,
      "explanation": "PATCH to update the account's status field models this as a state change on an existing resource. Alternatively, POST /account-locks models it as creating a new resource. Both are valid, but PATCH is simpler when the action maps to a field change.",
      "detailedExplanation": "PATCH to update the account's status field models this as a state change on an existing resource. Alternatively, POST /account-locks models it as creating a new resource. Both are valid, but PATCH is simpler when the action maps to a field change. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-054",
      "type": "multiple-choice",
      "question": "A PATCH request sends {\"email\": \"new@example.com\"} for a user who also has name, age, and address fields. What should happen to the other fields?",
      "options": [
        "They should be set to null",
        "They should remain unchanged",
        "The server should return 400 because the request is incomplete",
        "It depends on whether you use JSON Merge Patch or JSON Patch"
      ],
      "correct": 3,
      "explanation": "With JSON Merge Patch (RFC 7396), omitted fields are unchanged and null means delete. With JSON Patch (RFC 6902), you send explicit operations. Most APIs use Merge Patch semantics (omitted = unchanged), but the spec matters.",
      "detailedExplanation": "With JSON Merge Patch (RFC 7396), omitted fields are unchanged and null means delete. With JSON Patch (RFC 6902), you send explicit operations. Most APIs use Merge Patch semantics (omitted = unchanged), but the spec matters. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-055",
      "type": "multiple-choice",
      "question": "Which header enables CORS preflight requests?",
      "options": [
        "Access-Control-Allow-Origin",
        "Origin",
        "X-Requested-With",
        "Access-Control-Allow-Methods"
      ],
      "correct": 0,
      "explanation": "Access-Control-Allow-Origin in the response tells the browser which origins can access the resource. The browser's preflight OPTIONS request checks for this header before sending the actual request.",
      "detailedExplanation": "Access-Control-Allow-Origin in the response tells the browser which origins can access the resource. The browser's preflight OPTIONS request checks for this header before sending the actual request. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-056",
      "type": "two-stage",
      "stages": [
        {
          "question": "A browser JavaScript app on app.example.com calls fetch('https://api.example.com/users'). Before the GET request, the browser sends an OPTIONS request. Why?",
          "options": [
            "To check if the server is available",
            "CORS preflight — the browser checks if cross-origin requests are allowed",
            "To negotiate the response format",
            "To establish a persistent connection"
          ],
          "correct": 1,
          "explanation": "Different subdomains are different origins. The browser sends a preflight OPTIONS request to check CORS headers before allowing the cross-origin request. This protects users from malicious cross-site requests.",
          "detailedExplanation": "Different subdomains are different origins. The browser sends a preflight OPTIONS request to check CORS headers before allowing the cross-origin request. This protects users from malicious cross-site requests. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "The OPTIONS response includes Access-Control-Allow-Origin: *. Is this a security concern for a public API?",
          "options": [
            "Yes — it allows any website to make requests",
            "No — CORS only controls browser requests, and a public API wants broad access",
            "Yes — it exposes internal endpoints",
            "No — the * only applies to GET requests"
          ],
          "correct": 1,
          "explanation": "For a public API, Access-Control-Allow-Origin: * is appropriate. CORS is a browser security feature — it doesn't affect server-to-server calls, curl, or mobile apps. A public API intentionally allows broad access. For private APIs, you'd restrict the origin.",
          "detailedExplanation": "For a public API, Access-Control-Allow-Origin: * is appropriate. CORS is a browser security feature — it doesn't affect server-to-server calls, curl, or mobile apps. A public API intentionally allows broad access. For private APIs, you'd restrict the origin. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-057",
      "type": "multiple-choice",
      "question": "What does content negotiation mean in REST?",
      "options": [
        "Negotiating the price of API access",
        "The client and server agree on the representation format via Accept and Content-Type headers",
        "Choosing between REST and GraphQL",
        "Compressing the response body"
      ],
      "correct": 1,
      "explanation": "Content negotiation lets the client request a specific format (JSON, XML, etc.) via the Accept header, and the server responds in that format. This decouples resources from their representations.",
      "detailedExplanation": "Content negotiation lets the client request a specific format (JSON, XML, etc.) via the Accept header, and the server responds in that format. This decouples resources from their representations. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-058",
      "type": "multiple-choice",
      "question": "A GET /users endpoint returns 10,000 users. What's the main problem?",
      "options": [
        "GET can't handle that many results",
        "The response is too large — it wastes bandwidth, memory, and time",
        "GET requests are limited to 1,000 results by HTTP",
        "The server will time out"
      ],
      "correct": 1,
      "explanation": "No HTTP limit exists on response size, but returning 10,000 records is impractical — slow response, high memory usage on client and server, wasted bandwidth for clients who need a few records. Pagination solves this.",
      "detailedExplanation": "No HTTP limit exists on response size, but returning 10,000 records is impractical — slow response, high memory usage on client and server, wasted bandwidth for clients who need a few records. Pagination solves this. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        }
      ]
    },
    {
      "id": "rest-059",
      "type": "multiple-choice",
      "question": "What status code should you return for a request with a valid JSON body but an unsupported media type?",
      "options": [
        "400 Bad Request",
        "406 Not Acceptable",
        "415 Unsupported Media Type",
        "422 Unprocessable Entity"
      ],
      "correct": 2,
      "explanation": "415 Unsupported Media Type means the server can't process the request's Content-Type. For example, if the server only accepts JSON and receives XML. 406 is about the Accept header (response format), not the request format.",
      "detailedExplanation": "415 Unsupported Media Type means the server can't process the request's Content-Type. For example, if the server only accepts JSON and receives XML. 406 is about the Accept header (response format), not the request format. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-060",
      "type": "multi-select",
      "question": "Which are benefits of REST's statelessness constraint?",
      "options": [
        "Horizontal scaling — any server can handle any request",
        "Simpler server implementation — no session management",
        "Reduced network traffic",
        "Better fault tolerance — server restarts don't lose client state"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Statelessness enables horizontal scaling (no sticky sessions), simplifies servers (no session stores), and improves fault tolerance (server crashes don't lose session state). It actually increases network traffic since each request must carry full context.",
      "detailedExplanation": "Statelessness enables horizontal scaling (no sticky sessions), simplifies servers (no session stores), and improves fault tolerance (server crashes don't lose session state). It actually increases network traffic since each request must carry full context. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        }
      ]
    },
    {
      "id": "rest-061",
      "type": "multiple-choice",
      "question": "Which best describes a 'resource' in REST?",
      "options": [
        "A database table",
        "An API endpoint",
        "Any information that can be named — a document, image, service, collection, etc.",
        "A JSON object"
      ],
      "correct": 2,
      "explanation": "In REST, a resource is any concept that can be named and addressed. It could be a single document, a collection, a computed result, or even a non-virtual object. Resources are identified by URIs and can have multiple representations.",
      "detailedExplanation": "In REST, a resource is any concept that can be named and addressed. It could be a single document, a collection, a computed result, or even a non-virtual object. Resources are identified by URIs and can have multiple representations. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-062",
      "type": "multiple-choice",
      "question": "Should a DELETE endpoint return the deleted resource in the response body?",
      "options": [
        "Yes, always — the client needs confirmation",
        "No, never — 204 No Content is the only correct response",
        "Either is valid — 200 with body or 204 without",
        "Only if the client sends an Accept header"
      ],
      "correct": 2,
      "explanation": "Both approaches are valid REST. 204 No Content is clean and minimal. 200 OK with the deleted resource lets clients confirm what was deleted or use the data without an extra GET. Choose based on your API's conventions.",
      "detailedExplanation": "Both approaches are valid REST. 204 No Content is clean and minimal. 200 OK with the deleted resource lets clients confirm what was deleted or use the data without an extra GET. Choose based on your API's conventions. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-063",
      "type": "multiple-choice",
      "question": "What's the purpose of the Allow header?",
      "options": [
        "Listing which origins can access the resource",
        "Listing which HTTP methods are valid for a resource",
        "Listing which content types are accepted",
        "Listing which authentication methods are supported"
      ],
      "correct": 1,
      "explanation": "The Allow header lists valid HTTP methods for a resource (e.g., Allow: GET, POST, DELETE). It's required in 405 Method Not Allowed responses and useful in OPTIONS responses.",
      "detailedExplanation": "The Allow header lists valid HTTP methods for a resource (e.g., Allow: GET, POST, DELETE). It's required in 405 Method Not Allowed responses and useful in OPTIONS responses. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-064",
      "type": "two-stage",
      "stages": [
        {
          "question": "A client updates a user's email with PATCH /users/42. Meanwhile, another client also patches user 42's address. The second PATCH overwrites the first client's email change. What's this problem called?",
          "options": [
            "Race condition",
            "Lost update problem",
            "Dirty read",
            "Phantom read"
          ],
          "correct": 1,
          "explanation": "The lost update problem: two clients read the same state, both modify it, and the second write overwrites the first without incorporating its changes. This is a classic concurrency issue in APIs.",
          "detailedExplanation": "The lost update problem: two clients read the same state, both modify it, and the second write overwrites the first without incorporating its changes. This is a classic concurrency issue in APIs. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "Which HTTP mechanism prevents lost updates?",
          "options": [
            "Using PUT instead of PATCH",
            "Optimistic concurrency with ETags and If-Match",
            "Requiring sequential request IDs",
            "Using transactions in the database"
          ],
          "correct": 1,
          "explanation": "Optimistic concurrency: each response includes an ETag. Updates send If-Match with their ETag. If the resource changed since the client's last read, the server returns 412 Precondition Failed and the client must re-read and retry.",
          "detailedExplanation": "Optimistic concurrency: each response includes an ETag. Updates send If-Match with their ETag. If the resource changed since the client's last read, the server returns 412 Precondition Failed and the client must re-read and retry. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-065",
      "type": "multiple-choice",
      "question": "What status code does the server return when an If-Match precondition fails?",
      "options": [
        "400 Bad Request",
        "409 Conflict",
        "412 Precondition Failed",
        "428 Precondition Required"
      ],
      "correct": 2,
      "explanation": "412 Precondition Failed means the condition in If-Match (or If-Unmodified-Since) was not met — the resource has changed since the client last fetched it. 428 means the server requires a precondition header but the client didn't send one.",
      "detailedExplanation": "412 Precondition Failed means the condition in If-Match (or If-Unmodified-Since) was not met — the resource has changed since the client last fetched it. 428 means the server requires a precondition header but the client didn't send one. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-066",
      "type": "multiple-choice",
      "question": "What's an ETag?",
      "options": [
        "An encryption tag for secure responses",
        "An error tracking identifier",
        "An opaque identifier representing a specific version of a resource",
        "An HTML element tag"
      ],
      "correct": 2,
      "explanation": "An ETag (entity tag) is a version identifier for a resource — typically a hash of the content or a version number. Clients use it with If-None-Match (caching) and If-Match (concurrency control).",
      "detailedExplanation": "An ETag (entity tag) is a version identifier for a resource — typically a hash of the content or a version number. Clients use it with If-None-Match (caching) and If-Match (concurrency control). Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ]
    },
    {
      "id": "rest-067",
      "type": "multi-select",
      "question": "Which are valid uses of ETags?",
      "options": [
        "Conditional GET requests to avoid re-downloading unchanged resources",
        "Optimistic concurrency control for updates",
        "Authentication",
        "Cache validation"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "ETags serve caching (conditional GETs with If-None-Match → 304), concurrency control (conditional writes with If-Match → 412), and cache validation. They have nothing to do with authentication.",
      "detailedExplanation": "ETags serve caching (conditional GETs with If-None-Match → 304), concurrency control (conditional writes with If-Match → 412), and cache validation. They have nothing to do with authentication. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Redis Documentation",
          "url": "https://redis.io/docs/latest/"
        }
      ]
    },
    {
      "id": "rest-068",
      "type": "multiple-choice",
      "question": "Which is NOT a common REST API authentication mechanism?",
      "options": [
        "Bearer tokens (OAuth 2.0)",
        "API keys in headers",
        "HTTP Basic authentication",
        "REST-Auth handshake"
      ],
      "correct": 3,
      "explanation": "There's no such thing as a 'REST-Auth handshake.' Common REST API auth mechanisms include Bearer tokens (OAuth 2.0), API keys (in headers or query params), and HTTP Basic auth (username:password base64-encoded).",
      "detailedExplanation": "There's no such thing as a 'REST-Auth handshake.' Common REST API auth mechanisms include Bearer tokens (OAuth 2.0), API keys (in headers or query params), and HTTP Basic auth (username:password base64-encoded). Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-069",
      "type": "multiple-choice",
      "question": "Where should API keys be sent in a REST request?",
      "options": [
        "Always in the URL query string",
        "Always in the request body",
        "In a header (preferred) or query string",
        "In a cookie"
      ],
      "correct": 2,
      "explanation": "Headers are preferred (e.g., X-API-Key or Authorization) because URLs get logged in server access logs, browser history, and referrer headers. Query strings work but risk exposing the key.",
      "detailedExplanation": "Headers are preferred (e.g., X-API-Key or Authorization) because URLs get logged in server access logs, browser history, and referrer headers. Query strings work but risk exposing the key. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-070",
      "type": "multiple-choice",
      "question": "What happens if a REST API stores client-specific 'step' state on the server (e.g., 'user is on step 3 of a wizard')?",
      "options": [
        "Nothing — this is normal REST",
        "It breaks statelessness, making horizontal scaling harder",
        "The API becomes faster",
        "It improves security"
      ],
      "correct": 1,
      "explanation": "Storing client state on the server violates REST's statelessness constraint. This creates 'sticky sessions' — requests must route to the same server. It complicates scaling, failover, and load balancing.",
      "detailedExplanation": "Storing client state on the server violates REST's statelessness constraint. This creates 'sticky sessions' — requests must route to the same server. It complicates scaling, failover, and load balancing. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ]
    },
    {
      "id": "rest-071",
      "type": "ordering",
      "question": "Rank these API design qualities from most to least important for a public-facing API:",
      "items": [
        "Consistency",
        "Clever URI design",
        "Good error messages",
        "Comprehensive documentation"
      ],
      "correctOrder": [0, 3, 2, 1],
      "explanation": "Consistency is paramount — predictable patterns reduce learning curve. Documentation is essential for adoption. Good errors help debugging. Clever URIs are nice but least critical — a consistent, well-documented API with mediocre URIs beats an inconsistent one with beautiful URIs.",
      "detailedExplanation": "Consistency is paramount — predictable patterns reduce learning curve. Documentation is essential for adoption. Good errors help debugging. Clever URIs are nice but least critical — a consistent, well-documented API with mediocre URIs beats an inconsistent one with beautiful URIs. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "rest-072",
      "type": "multiple-choice",
      "question": "A client sends a valid request but the server fails internally. Which status code?",
      "options": [
        "400 Bad Request",
        "404 Not Found",
        "500 Internal Server Error",
        "503 Service Unavailable"
      ],
      "correct": 2,
      "explanation": "500 Internal Server Error means the server encountered an unexpected condition. The request was valid (not 4xx) but the server failed to fulfill it. Don't expose implementation details — log them server-side.",
      "detailedExplanation": "500 Internal Server Error means the server encountered an unexpected condition. The request was valid (not 4xx) but the server failed to fulfill it. Don't expose implementation details — log them server-side. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-073",
      "type": "multiple-choice",
      "question": "Should REST API endpoints include the action in the URL (e.g., /users/42/activate)?",
      "options": [
        "Yes, it makes the API self-documenting",
        "Never — it's always wrong",
        "It's acceptable for non-CRUD actions that don't map to a resource state change",
        "Only for POST requests"
      ],
      "correct": 2,
      "explanation": "Purists model everything as resource state (PATCH status to 'active'), but for complex actions (restart, validate, import), a verb sub-resource like POST /servers/42/restart is pragmatic and widely accepted.",
      "detailedExplanation": "Purists model everything as resource state (PATCH status to 'active'), but for complex actions (restart, validate, import), a verb sub-resource like POST /servers/42/restart is pragmatic and widely accepted. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-074",
      "type": "multi-select",
      "question": "Which response headers help with caching?",
      "options": ["Cache-Control", "ETag", "Last-Modified", "X-Request-Id"],
      "correctIndices": [0, 1, 2],
      "explanation": "Cache-Control defines caching rules (max-age, no-cache, etc.). ETag enables conditional requests. Last-Modified enables time-based conditional requests. X-Request-Id is for request tracing, not caching.",
      "detailedExplanation": "Cache-Control defines caching rules (max-age, no-cache, etc.). ETag enables conditional requests. Last-Modified enables time-based conditional requests. X-Request-Id is for request tracing, not caching. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Redis Documentation",
          "url": "https://redis.io/docs/latest/"
        }
      ]
    },
    {
      "id": "rest-075",
      "type": "multiple-choice",
      "question": "What does Cache-Control: no-store mean?",
      "options": [
        "The response can be cached but must be revalidated each time",
        "The response must not be stored in any cache, ever",
        "The cache should be cleared",
        "Caching is optional"
      ],
      "correct": 1,
      "explanation": "no-store means no cache (browser, CDN, proxy) should store the response at all. This is the strictest caching directive. no-cache means 'cache it but revalidate every time' — a confusing name.",
      "detailedExplanation": "no-store means no cache (browser, CDN, proxy) should store the response at all. This is the strictest caching directive. no-cache means 'cache it but revalidate every time' — a confusing name. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Redis Documentation",
          "url": "https://redis.io/docs/latest/"
        }
      ]
    },
    {
      "id": "rest-076",
      "type": "multiple-choice",
      "question": "What's the difference between Cache-Control: no-cache and no-store?",
      "options": [
        "They're the same thing",
        "no-cache prevents caching entirely; no-store allows it with revalidation",
        "no-cache allows caching but requires revalidation; no-store prevents caching entirely",
        "no-cache is for browsers; no-store is for CDNs"
      ],
      "correct": 2,
      "explanation": "Despite the name, no-cache does NOT prevent caching — it means 'cache it but revalidate with the server before every use.' no-store prevents any caching whatsoever. For truly sensitive data, use no-store.",
      "detailedExplanation": "Despite the name, no-cache does NOT prevent caching — it means 'cache it but revalidate with the server before every use.' no-store prevents any caching whatsoever. For truly sensitive data, use no-store. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Redis Documentation",
          "url": "https://redis.io/docs/latest/"
        }
      ]
    },
    {
      "id": "rest-077",
      "type": "multiple-choice",
      "question": "A REST API needs to perform a bulk operation — deleting 100 users. What's the most practical approach?",
      "options": [
        "100 individual DELETE /users/{id} requests",
        "DELETE /users with a list of IDs in the body",
        "POST /users/bulk-delete with a list of IDs",
        "Any of these work, but POST with a body is the most practical"
      ],
      "correct": 3,
      "explanation": "100 individual requests are wasteful. DELETE with a body is technically allowed but poorly supported. POST /users/bulk-delete with a body is pragmatic — it's clear, supports a body naturally, and is widely used. Purity matters less than practicality for bulk operations.",
      "detailedExplanation": "100 individual requests are wasteful. DELETE with a body is technically allowed but poorly supported. POST /users/bulk-delete with a body is pragmatic — it's clear, supports a body naturally, and is widely used. Purity matters less than practicality for bulk operations. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-078",
      "type": "two-stage",
      "stages": [
        {
          "question": "You design POST /users which returns 201 Created. Six months later, you need to add email verification. Users shouldn't be fully active until verified. What's the best approach?",
          "options": [
            "Change POST /users to return 200 instead of 201",
            "POST /users still returns 201, but the user resource includes a 'status: pending_verification' field",
            "Create a separate POST /user-registrations endpoint",
            "Return 202 Accepted instead of 201"
          ],
          "correct": 1,
          "explanation": "The user resource is still created (201 is correct), but now includes a status field. This models verification as a state on the resource rather than changing the creation semantics. The alternative — a separate /user-registrations resource — is also valid but more disruptive.",
          "detailedExplanation": "The user resource is still created (201 is correct), but now includes a status field. This models verification as a state on the resource rather than changing the creation semantics. The alternative — a separate /user-registrations resource — is also valid but more disruptive. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "A client hits GET /users/42 for a user who exists but hasn't verified their email. What should the response be?",
          "options": [
            "404 Not Found — they're not a 'real' user yet",
            "200 OK with the user data, including status: pending_verification",
            "403 Forbidden — unverified users can't be accessed",
            "202 Accepted — the user is being processed"
          ],
          "correct": 1,
          "explanation": "The user resource exists, so 200 OK is correct. The status field tells the client the user's state. 404 would be incorrect — the resource exists. Application-level status belongs in the resource representation, not HTTP status codes.",
          "detailedExplanation": "The user resource exists, so 200 OK is correct. The status field tells the client the user's state. 404 would be incorrect — the resource exists. Application-level status belongs in the resource representation, not HTTP status codes. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-079",
      "type": "multiple-choice",
      "question": "Which is the best URI for getting the currently authenticated user's profile?",
      "options": [
        "GET /users/{userId} (client must know their ID)",
        "GET /me",
        "GET /users/current",
        "Either /me or /users/me — both are common conventions"
      ],
      "correct": 3,
      "explanation": "Both /me and /users/me are widely used conventions for 'the current user.' They avoid making the client store and manage their own user ID. The server resolves the identity from the authentication token.",
      "detailedExplanation": "Both /me and /users/me are widely used conventions for 'the current user.' They avoid making the client store and manage their own user ID. The server resolves the identity from the authentication token. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "RFC 7519: JSON Web Token (JWT)",
          "url": "https://www.rfc-editor.org/rfc/rfc7519"
        }
      ]
    },
    {
      "id": "rest-080",
      "type": "multiple-choice",
      "question": "Should query parameters be included in cache keys?",
      "options": [
        "No — only the path matters for caching",
        "Yes — /users?page=1 and /users?page=2 are different resources",
        "Only for GET requests",
        "Only if the Vary header is set"
      ],
      "correct": 1,
      "explanation": "Query parameters change the response, so they must be part of the cache key. /users?page=1 and /users?page=2 return different data. Caches (browsers, CDNs) do include query strings by default.",
      "detailedExplanation": "Query parameters change the response, so they must be part of the cache key. /users?page=1 and /users?page=2 return different data. Caches (browsers, CDNs) do include query strings by default. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Redis Documentation",
          "url": "https://redis.io/docs/latest/"
        }
      ]
    },
    {
      "id": "rest-081",
      "type": "multiple-choice",
      "question": "What does the Vary header do?",
      "options": [
        "Indicates the response varies by server",
        "Tells caches which request headers affect the response, so they should be part of the cache key",
        "Varies the response format randomly",
        "Lists alternative URIs for the resource"
      ],
      "correct": 1,
      "explanation": "Vary: Accept means the response depends on the Accept header — a cache should store separate versions for clients requesting JSON vs XML. Vary: Authorization means each user gets a different response.",
      "detailedExplanation": "Vary: Accept means the response depends on the Accept header — a cache should store separate versions for clients requesting JSON vs XML. Vary: Authorization means each user gets a different response. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Redis Documentation",
          "url": "https://redis.io/docs/latest/"
        }
      ]
    },
    {
      "id": "rest-083",
      "type": "ordering",
      "question": "Rank these approaches for handling partial failures in a batch API, from simplest to most robust:",
      "items": [
        "Fail the entire batch if any item fails",
        "Return 207 Multi-Status with per-item results",
        "Process each item independently, return mixed results"
      ],
      "correctOrder": [0, 2, 1],
      "explanation": "All-or-nothing is simplest to implement and reason about. Independent processing is moderate — just process each and report. 207 Multi-Status is the most robust — it gives per-item status codes, letting clients handle each failure individually.",
      "detailedExplanation": "All-or-nothing is simplest to implement and reason about. Independent processing is moderate — just process each and report. 207 Multi-Status is the most robust — it gives per-item status codes, letting clients handle each failure individually. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-084",
      "type": "multiple-choice",
      "question": "What's the purpose of the Link header in HTTP?",
      "options": [
        "Linking to the API documentation",
        "Providing relationships between resources (pagination, related resources)",
        "Linking stylesheets",
        "Creating hyperlinks in JSON"
      ],
      "correct": 1,
      "explanation": "The Link header provides relationships between the current resource and others. Common use: pagination links (Link: </users?page=2>; rel=\"next\"). It's a lightweight alternative to putting links in the response body.",
      "detailedExplanation": "The Link header provides relationships between the current resource and others. Common use: pagination links (Link: </users?page=2>; rel=\"next\"). It's a lightweight alternative to putting links in the response body. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-085",
      "type": "multi-select",
      "question": "Which are good reasons to use PATCH instead of PUT for updates?",
      "options": [
        "The client only knows which fields changed",
        "The resource is large and sending the whole thing wastes bandwidth",
        "You want the update to be idempotent",
        "Concurrent partial updates are less likely to conflict"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "PATCH is better when clients know only the delta, when resources are large, and for reducing conflict surface (two patches to different fields don't overwrite each other). PUT is actually more idempotent than PATCH, so that's not a reason to choose PATCH.",
      "detailedExplanation": "PATCH is better when clients know only the delta, when resources are large, and for reducing conflict surface (two patches to different fields don't overwrite each other). PUT is actually more idempotent than PATCH, so that's not a reason to choose PATCH. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-086",
      "type": "multiple-choice",
      "question": "An endpoint GET /reports/monthly returns a different report depending on the current date. Is this RESTful?",
      "options": [
        "Yes — the resource representation changes over time, which is fine",
        "No — REST resources must be immutable",
        "Only if Cache-Control is set correctly",
        "Only if the report has a unique URI like /reports/2024-01"
      ],
      "correct": 0,
      "explanation": "REST resources can have representations that change over time. 'The current monthly report' is a valid resource. It's RESTful as long as the same URI consistently identifies the same concept. Consider also providing stable URIs like /reports/2024-01 for historical access.",
      "detailedExplanation": "REST resources can have representations that change over time. 'The current monthly report' is a valid resource. It's RESTful as long as the same URI consistently identifies the same concept. Consider also providing stable URIs like /reports/2024-01 for historical access. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Compound annual growth rate",
          "url": "https://www.investopedia.com/terms/c/cagr.asp"
        }
      ]
    },
    {
      "id": "rest-087",
      "type": "multiple-choice",
      "question": "What's the maximum practical length for a URL?",
      "options": [
        "256 characters (HTTP spec)",
        "~2,000 characters (browser/server limits)",
        "Unlimited in HTTP, but 8KB is a common server limit",
        "It depends on the HTTP method"
      ],
      "correct": 1,
      "explanation": "HTTP itself doesn't limit URL length, but browsers (especially older IE at 2,083 chars) and servers (Apache defaults to 8KB) impose practical limits. Keep URLs under ~2,000 characters to be safe. If you need more, use POST with a body.",
      "detailedExplanation": "HTTP itself doesn't limit URL length, but browsers (especially older IE at 2,083 chars) and servers (Apache defaults to 8KB) impose practical limits. Keep URLs under ~2,000 characters to be safe. If you need more, use POST with a body. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-088",
      "type": "multiple-choice",
      "question": "A REST API returns user data. Which response is better designed?",
      "options": [
        "{\"data\": {\"id\": 42, \"name\": \"Alice\"}}",
        "{\"id\": 42, \"name\": \"Alice\"}",
        "Both are valid — envelope vs. bare resource is a style choice",
        "{\"status\": \"success\", \"data\": {\"id\": 42, \"name\": \"Alice\"}}"
      ],
      "correct": 2,
      "explanation": "Both are valid. Bare resource is simpler and more direct. Enveloped ({data: ...}) reserves space for metadata (pagination, errors). Choose one and be consistent. Avoid redundant fields like 'status: success' — that's what HTTP status codes are for.",
      "detailedExplanation": "Both are valid. Bare resource is simpler and more direct. Enveloped ({data: ...}) reserves space for metadata (pagination, errors). Choose one and be consistent. Avoid redundant fields like 'status: success' — that's what HTTP status codes are for. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-089",
      "type": "multiple-choice",
      "question": "What HTTP status code should an API return if the endpoint exists but the specific resource ID doesn't?",
      "options": [
        "400 Bad Request",
        "404 Not Found",
        "410 Gone",
        "204 No Content"
      ],
      "correct": 1,
      "explanation": "404 Not Found — the URI is valid but no resource exists at that location. 410 Gone would mean it used to exist and has been intentionally removed (useful for SEO/caching). 400 would mean the request itself was malformed.",
      "detailedExplanation": "404 Not Found — the URI is valid but no resource exists at that location. 410 Gone would mean it used to exist and has been intentionally removed (useful for SEO/caching). 400 would mean the request itself was malformed. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-090",
      "type": "multiple-choice",
      "question": "When should you use 410 Gone instead of 404 Not Found?",
      "options": [
        "Always, for deleted resources",
        "When the resource was intentionally deleted and will never return",
        "When the server is shutting down",
        "Never — 404 is always sufficient"
      ],
      "correct": 1,
      "explanation": "410 Gone means the resource existed, has been intentionally removed, and the URI won't be reused. This tells search engines to deindex, caches to purge, and clients to stop retrying. 404 is more ambiguous — the resource might appear later.",
      "detailedExplanation": "410 Gone means the resource existed, has been intentionally removed, and the URI won't be reused. This tells search engines to deindex, caches to purge, and clients to stop retrying. 404 is more ambiguous — the resource might appear later. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-091",
      "type": "two-stage",
      "stages": [
        {
          "question": "You expose a REST API for managing a queue of tasks. Clients should be able to take the next available task. What's the most RESTful way to model 'take next task'?",
          "options": [
            "GET /tasks/next",
            "POST /tasks/next/claim",
            "POST /task-assignments with no body (server picks the next task)",
            "DELETE /tasks/queue/front"
          ],
          "correct": 2,
          "explanation": "POST /task-assignments models the action as creating a resource (an assignment). The server selects the next task and returns the assignment with the task details. This is RESTful — it's a noun (assignment) created via POST.",
          "detailedExplanation": "POST /task-assignments models the action as creating a resource (an assignment). The server selects the next task and returns the assignment with the task details. This is RESTful — it's a noun (assignment) created via POST. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "What should the response include?",
          "options": [
            "Just 201 Created with no body",
            "201 Created with the assignment resource (including task details and a Location header)",
            "200 OK with the task that was assigned",
            "202 Accepted with a polling URL"
          ],
          "correct": 1,
          "explanation": "201 Created with the full assignment resource (who, what task, when) and a Location header pointing to the assignment. This gives the client everything it needs: what task to work on and a URI to update when done.",
          "detailedExplanation": "201 Created with the full assignment resource (who, what task, when) and a Location header pointing to the assignment. This gives the client everything it needs: what task to work on and a URI to update when done. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-092",
      "type": "multi-select",
      "question": "Which are valid ways to represent sub-resources in REST?",
      "options": [
        "/users/42/avatar (a user's avatar)",
        "/users/42/posts (a user's posts)",
        "/users/42.json (format suffix)",
        "/users/42/posts/7/comments (deeply nested)"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Sub-resources like /users/42/avatar, /users/42/posts, and deeper nesting /users/42/posts/7/comments are all valid REST patterns. Format suffixes (.json) are not sub-resources — they're an alternative to content negotiation via Accept headers.",
      "detailedExplanation": "Sub-resources like /users/42/avatar, /users/42/posts, and deeper nesting /users/42/posts/7/comments are all valid REST patterns. Format suffixes (.json) are not sub-resources — they're an alternative to content negotiation via Accept headers. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-093",
      "type": "multiple-choice",
      "question": "How deep should REST URI nesting go?",
      "options": [
        "No limit — nest as deep as the data model requires",
        "Maximum 1 level (/users/42)",
        "Practical limit of 2-3 levels — deeper nesting becomes unwieldy",
        "Exactly 2 levels always"
      ],
      "correct": 2,
      "explanation": "2-3 levels is a practical guideline. /users/42/posts/7/comments is fine; /users/42/posts/7/comments/99/reactions/likes is too deep. For deeply nested resources, promote them to top-level with query filters: /comments?postId=7.",
      "detailedExplanation": "2-3 levels is a practical guideline. /users/42/posts/7/comments is fine; /users/42/posts/7/comments/99/reactions/likes is too deep. For deeply nested resources, promote them to top-level with query filters: /comments?postId=7. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-094",
      "type": "multiple-choice",
      "question": "What's the problem with this URI: GET /users/42/posts/7?",
      "options": [
        "Nothing — it's correctly nested",
        "If post 7 has a unique ID regardless of user, the user prefix is redundant",
        "It should be a POST request",
        "The IDs should be UUIDs, not integers"
      ],
      "correct": 1,
      "explanation": "If posts have globally unique IDs, GET /posts/7 is sufficient and simpler. The /users/42 prefix adds no information and forces clients to know the user ID. Nesting is useful when the child's identity depends on the parent (like /users/42/preferences).",
      "detailedExplanation": "If posts have globally unique IDs, GET /posts/7 is sufficient and simpler. The /users/42 prefix adds no information and forces clients to know the user ID. Nesting is useful when the child's identity depends on the parent (like /users/42/preferences). Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-095",
      "type": "multiple-choice",
      "question": "Should REST APIs return null fields or omit them entirely?",
      "options": [
        "Always include null fields for consistency",
        "Always omit null fields to reduce payload size",
        "Either is fine, but be consistent across the API",
        "Use a separate endpoint for null-checking"
      ],
      "correct": 2,
      "explanation": "Both approaches have tradeoffs. Including nulls is explicit and consistent (clients always know the shape). Omitting saves bandwidth. The key is consistency — don't include nulls for some fields and omit others arbitrarily.",
      "detailedExplanation": "Both approaches have tradeoffs. Including nulls is explicit and consistent (clients always know the shape). Omitting saves bandwidth. The key is consistency — don't include nulls for some fields and omit others arbitrarily. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "rest-096",
      "type": "multiple-choice",
      "question": "Which naming convention is standard for JSON field names in REST APIs?",
      "options": [
        "snake_case (user_name)",
        "camelCase (userName)",
        "PascalCase (UserName)",
        "No universal standard — match your ecosystem"
      ],
      "correct": 3,
      "explanation": "No universal standard exists. JavaScript ecosystems favor camelCase, Ruby/Python favor snake_case, .NET favors PascalCase. Google's JSON style guide uses camelCase. The most important thing is consistency within your API.",
      "detailedExplanation": "No universal standard exists. JavaScript ecosystems favor camelCase, Ruby/Python favor snake_case, .NET favors PascalCase. Google's JSON style guide uses camelCase. The most important thing is consistency within your API. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "rest-098",
      "type": "ordering",
      "question": "Rank these from most commonly used to least commonly used in typical REST APIs:",
      "items": ["GET", "TRACE", "POST", "DELETE"],
      "correctOrder": [0, 2, 3, 1],
      "explanation": "GET is by far the most common (reads). POST is next (creates, actions). DELETE is common but less frequent. TRACE is almost never used in APIs — it's a debugging method that echoes the request back, and is often disabled for security.",
      "detailedExplanation": "GET is by far the most common (reads). POST is next (creates, actions). DELETE is common but less frequent. TRACE is almost never used in APIs — it's a debugging method that echoes the request back, and is often disabled for security. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-099",
      "type": "multiple-choice",
      "question": "What is the CONNECT HTTP method used for?",
      "options": [
        "Connecting to a database",
        "Establishing a tunnel through a proxy (e.g., for HTTPS)",
        "Opening a WebSocket connection",
        "Testing connectivity to the server"
      ],
      "correct": 1,
      "explanation": "CONNECT establishes a tunnel through an HTTP proxy, typically for HTTPS connections. The client asks the proxy to relay raw TCP to the target server. It's not used directly in REST API design.",
      "detailedExplanation": "CONNECT establishes a tunnel through an HTTP proxy, typically for HTTPS connections. The client asks the proxy to relay raw TCP to the target server. It's not used directly in REST API design. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "rest-100",
      "type": "two-stage",
      "stages": [
        {
          "question": "Your REST API uses sequential integer IDs (/users/1, /users/2, ...). A competitor starts scraping all your users by incrementing the ID. What's the vulnerability?",
          "options": [
            "SQL injection",
            "Insecure Direct Object Reference (IDOR) — predictable IDs enable enumeration",
            "Cross-site scripting",
            "Man-in-the-middle attack"
          ],
          "correct": 1,
          "explanation": "Sequential IDs let attackers enumerate all resources by incrementing the ID. This is an IDOR vulnerability. Even with authentication, users might access other users' resources if authorization checks are missing.",
          "detailedExplanation": "Sequential IDs let attackers enumerate all resources by incrementing the ID. This is an IDOR vulnerability. Even with authentication, users might access other users' resources if authorization checks are missing. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "Which mitigation addresses enumeration while keeping the REST pattern?",
          "options": [
            "Use UUIDs instead of sequential IDs",
            "Rate limit all requests",
            "Require authentication",
            "Obfuscate IDs with a reversible cipher"
          ],
          "correct": 0,
          "explanation": "UUIDs make IDs unguessable, preventing enumeration. Rate limiting slows attacks but doesn't prevent them. Authentication doesn't help if authorization checks are missing. Obfuscation through obscurity is fragile. UUIDs plus proper authorization checks is the robust solution.",
          "detailedExplanation": "UUIDs make IDs unguessable, preventing enumeration. Rate limiting slows attacks but doesn't prevent them. Authentication doesn't help if authorization checks are missing. Obfuscation through obscurity is fragile. UUIDs plus proper authorization checks is the robust solution. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    }
  ]
}
