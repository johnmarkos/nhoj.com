{
  "unit": 2,
  "unitTitle": "Data Modeling",
  "chapter": 4,
  "chapterTitle": "Normalization",
  "chapterDescription": "1NF, 2NF, 3NF in plain English — why it matters and how to get there.",
  "problems": [
    {
      "id": "norm-001",
      "type": "multiple-choice",
      "question": "What is the main goal of database normalization?",
      "options": [
        "Faster queries",
        "Eliminate data redundancy and update anomalies",
        "Reduce the number of tables",
        "Make the schema easier to read"
      ],
      "correct": 1,
      "explanation": "Normalization reduces redundancy (same data stored in multiple places) and prevents anomalies (inserting, updating, or deleting data causing inconsistencies).",
      "detailedExplanation": "The core signal here is \"the main goal of database normalization\". Discard modeling choices that look clean but perform poorly for the target queries. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-002",
      "type": "multiple-choice",
      "question": "What is First Normal Form (1NF)?",
      "options": [
        "Each table has a primary key",
        "Each column contains atomic (indivisible) values — no lists, no repeating groups",
        "All columns depend on the primary key",
        "No transitive dependencies"
      ],
      "correct": 1,
      "explanation": "1NF: every column holds a single, atomic value. No comma-separated lists, no repeating groups (phone1, phone2, phone3). Each row-column intersection has one value.",
      "detailedExplanation": "Use \"first Normal Form (1NF)\" as your starting point, then verify tradeoffs carefully. Reject options that conflict with the primary access pattern or index strategy. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-003",
      "type": "multi-select",
      "question": "Which tables violate 1NF?",
      "options": [
        "User(id, name, 'skills: java,python,go')",
        "Order(id, product_id, quantity)",
        "Contact(id, phone1, phone2, phone3)",
        "Post(id, title, body)"
      ],
      "correctIndices": [0, 2],
      "explanation": "Comma-separated skills and repeating phone columns violate 1NF. Order and Post have atomic, single-value columns.",
      "detailedExplanation": "This prompt is really about \"tables violate 1NF\". Treat every option as a separate true/false test under the same constraints. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-004",
      "type": "multiple-choice",
      "question": "How do you fix: User(id, name, skills) where skills = 'java,python,go'?",
      "options": [
        "Use a TEXT column",
        "Create a UserSkill table (user_id, skill)",
        "Add skill1, skill2, skill3 columns",
        "Use JSON instead of CSV"
      ],
      "correct": 1,
      "explanation": "Create a separate UserSkill table. Each skill gets its own row: (user_id=1, skill='java'), (user_id=1, skill='python'). This satisfies 1NF.",
      "detailedExplanation": "The decision turns on \"you fix: User(id, name, skills) where skills = 'java,python,go'\". Prefer the schema/index decision that minimizes query and write amplification for this workload. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Keep quantities like 1 in aligned units before selecting an answer. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-005",
      "type": "ordering",
      "question": "Rank these normal forms from LOWEST to HIGHEST (least to most normalized):",
      "items": ["1NF", "2NF", "3NF", "BCNF"],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Each form builds on the previous. 1NF (atomic values) → 2NF (no partial dependencies) → 3NF (no transitive dependencies) → BCNF (every determinant is a key).",
      "detailedExplanation": "Read this as a scenario about \"rank these normal forms from LOWEST to HIGHEST (least to most normalized):\". Place obvious extremes first, then sort the middle by pairwise comparison. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-006",
      "type": "multiple-choice",
      "question": "What is Second Normal Form (2NF)?",
      "options": [
        "No repeating groups",
        "In 1NF AND every non-key column depends on the ENTIRE primary key (no partial dependencies)",
        "No transitive dependencies",
        "All columns are indexed"
      ],
      "correct": 1,
      "explanation": "2NF: must be in 1NF, and every non-key attribute depends on the whole PK, not just part of it. Only relevant for composite primary keys.",
      "detailedExplanation": "The key clue in this question is \"second Normal Form (2NF)\". Reject options that conflict with the primary access pattern or index strategy. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-007",
      "type": "two-stage",
      "stages": [
        {
          "question": "Table: OrderItem(order_id, product_id, quantity, product_name). PK is (order_id, product_id). Is this in 2NF?",
          "options": [
            "Yes",
            "No — product_name depends only on product_id, not the full PK"
          ],
          "correct": 1,
          "explanation": "product_name depends only on product_id (part of the PK), not on the full composite key (order_id, product_id). This is a partial dependency, violating 2NF.",
          "detailedExplanation": "This prompt is really about \"table: OrderItem(order_id, product_id, quantity, product_name)\". Solve this as chained reasoning where stage two must respect stage one assumptions. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: schema optimized for entities instead of queries."
        },
        {
          "question": "How do you fix this?",
          "options": [
            "Remove product_name",
            "Move product_name to a Product table",
            "Add a surrogate PK",
            "Make product_name part of the PK"
          ],
          "correct": 1,
          "explanation": "Move product_name to Product(product_id, product_name). OrderItem keeps (order_id, product_id, quantity). Now every non-key column depends on the full PK.",
          "detailedExplanation": "If you keep \"you fix this\" in view, the correct answer separates faster. Do not reset assumptions between stages; carry forward prior constraints directly. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: unbounded cardinality in joins or fan-out."
        }
      ],
      "detailedExplanation": "Start from \"normalization\", then pressure-test the result against the options. Do not reset assumptions between stages; carry forward prior constraints directly. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-008",
      "type": "multiple-choice",
      "question": "Can a table with a single-column PK violate 2NF?",
      "options": [
        "Yes, any table can violate 2NF",
        "No — 2NF partial dependency only applies to composite PKs",
        "Only if it has foreign keys",
        "Only in MySQL"
      ],
      "correct": 1,
      "explanation": "Partial dependency means a non-key column depends on PART of the PK. With a single-column PK, there's no 'part'—the whole PK is one column. 2NF is automatically satisfied.",
      "detailedExplanation": "If you keep \"can a table with a single-column PK violate 2NF\" in view, the correct answer separates faster. Reject options that conflict with the primary access pattern or index strategy. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-009",
      "type": "multiple-choice",
      "question": "What is Third Normal Form (3NF)?",
      "options": [
        "No repeating groups",
        "No partial dependencies",
        "In 2NF AND no transitive dependencies (non-key columns don't depend on other non-key columns)",
        "All data is in one table"
      ],
      "correct": 2,
      "explanation": "3NF: in 2NF, and no non-key column depends on another non-key column. Every non-key attribute depends directly on the primary key, not transitively through another column.",
      "detailedExplanation": "The core signal here is \"third Normal Form (3NF)\". Reject options that conflict with the primary access pattern or index strategy. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-010",
      "type": "two-stage",
      "stages": [
        {
          "question": "Employee(id, name, department_id, department_name). Is this in 3NF?",
          "options": [
            "Yes",
            "No — department_name depends on department_id, not directly on employee id"
          ],
          "correct": 1,
          "explanation": "department_name depends on department_id (a non-key column), not directly on the PK (employee id). This is a transitive dependency: id → department_id → department_name.",
          "detailedExplanation": "Start from \"employee(id, name, department_id, department_name)\", then pressure-test the result against the options. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: unbounded cardinality in joins or fan-out."
        },
        {
          "question": "How do you fix this?",
          "options": [
            "Remove department_id",
            "Move department_name to a Department table",
            "Make department_name part of the PK",
            "Remove department_name and store only department_id"
          ],
          "correct": 1,
          "explanation": "Create Department(department_id, department_name). Employee keeps (id, name, department_id). department_name is now stored once, in the Department table.",
          "detailedExplanation": "The decision turns on \"you fix this\". Solve this as chained reasoning where stage two must respect stage one assumptions. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: indexing that over-amplifies writes."
        }
      ],
      "detailedExplanation": "This prompt is really about \"normalization\". Do not reset assumptions between stages; carry forward prior constraints directly. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-011",
      "type": "multi-select",
      "question": "Which are update anomalies that normalization prevents?",
      "options": [
        "Insertion anomaly (can't add data without unrelated data)",
        "Deletion anomaly (deleting a row loses unrelated data)",
        "Update anomaly (changing one fact requires updating many rows)",
        "Query anomaly (queries return wrong results)"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "Normalization prevents insertion, deletion, and update anomalies. Query anomaly isn't a standard term—queries return correct results based on the data they have.",
      "detailedExplanation": "Use \"update anomalies that normalization prevents\" as your starting point, then verify tradeoffs carefully. Treat every option as a separate true/false test under the same constraints. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-012",
      "type": "multiple-choice",
      "question": "Table: Student(id, name, advisor_name, advisor_office). If an advisor changes offices, how many rows must be updated?",
      "options": [
        "1",
        "One per student with that advisor",
        "All rows",
        "None — it's a new row"
      ],
      "correct": 1,
      "explanation": "Every student row with that advisor has the office duplicated. You must update ALL of them. If you miss one, the data is inconsistent. This is an update anomaly.",
      "detailedExplanation": "The core signal here is \"table: Student(id, name, advisor_name, advisor_office)\". Prefer the schema/index decision that minimizes query and write amplification for this workload. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-013",
      "type": "numeric-input",
      "question": "A denormalized orders table stores customer_name on each order. A customer has 500 orders. They change their name. How many rows need updating?",
      "answer": 500,
      "tolerance": "exact",
      "explanation": "All 500 order rows have customer_name duplicated. Each must be updated. With normalization (customer_name in Customers table), you update exactly 1 row.",
      "detailedExplanation": "If you keep \"denormalized orders table stores customer_name on each order\" in view, the correct answer separates faster. Normalize units before computing so conversion mistakes do not propagate. Modeling quality is measured by query fit, cardinality behavior, and operational cost. If values like 500 and 1 appear, convert them into one unit basis before comparison. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-014",
      "type": "ordering",
      "question": "Rank these schemas by normalization level (LEAST to MOST normalized):",
      "items": [
        "Order(id, customer_name, customer_email, product, qty)",
        "Order(id, customer_id, product_id, qty) with Customer and Product tables",
        "Order(id, customer_id, product_id, qty) + OrderHistory + AuditLog"
      ],
      "correctOrder": [0, 1, 2],
      "explanation": "First: everything in one table (denormalized). Second: proper FK references (3NF). Third: further normalized with historical tracking.",
      "detailedExplanation": "Start from \"rank these schemas by normalization level (LEAST to MOST normalized):\", then pressure-test the result against the options. Place obvious extremes first, then sort the middle by pairwise comparison. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-015",
      "type": "multiple-choice",
      "question": "What's an insertion anomaly?",
      "options": [
        "INSERT is slow",
        "You can't insert data about one entity without providing data about another",
        "Inserting duplicates",
        "INSERT fails silently"
      ],
      "correct": 1,
      "explanation": "Example: if Department info is only in Employee table, you can't record a new department until it has employees. The department data depends on employee data existing.",
      "detailedExplanation": "The key clue in this question is \"what's an insertion anomaly\". Discard modeling choices that look clean but perform poorly for the target queries. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-016",
      "type": "multi-select",
      "question": "Table: CourseEnrollment(student_id, course_id, student_name, course_name, grade). PK: (student_id, course_id). Which violate 2NF?",
      "options": [
        "student_name (depends only on student_id)",
        "course_name (depends only on course_id)",
        "grade (depends on both student_id and course_id)",
        "All non-key columns"
      ],
      "correctIndices": [0, 1],
      "explanation": "student_name depends on student_id alone (partial dependency). course_name depends on course_id alone. grade depends on both—the full PK—so it's fine.",
      "detailedExplanation": "Read this as a scenario about \"table: CourseEnrollment(student_id, course_id, student_name, course_name, grade)\". Avoid pattern guessing and evaluate each candidate directly against the scenario. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-017",
      "type": "multiple-choice",
      "question": "What's a transitive dependency?",
      "options": [
        "A → B → C, where A is the PK, B is non-key, and C depends on B",
        "A → B and B → A",
        "All columns depend on the PK",
        "Dependencies between tables"
      ],
      "correct": 0,
      "explanation": "Transitive dependency: A (PK) → B (non-key) → C (non-key). C depends on A only through B. Example: employee_id → department_id → department_name.",
      "detailedExplanation": "The decision turns on \"what's a transitive dependency\". Reject options that conflict with the primary access pattern or index strategy. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-018",
      "type": "two-stage",
      "stages": [
        {
          "question": "Book(isbn, title, author_id, author_name, author_country). What's the transitive dependency?",
          "options": [
            "isbn → title",
            "isbn → author_id → author_name, author_country",
            "author_name → author_country",
            "No transitive dependency"
          ],
          "correct": 1,
          "explanation": "isbn → author_id (direct), then author_id → author_name, author_country (transitive). author_name and author_country depend on isbn only through author_id.",
          "detailedExplanation": "Start from \"book(isbn, title, author_id, author_name, author_country)\", then pressure-test the result against the options. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: unbounded cardinality in joins or fan-out."
        },
        {
          "question": "What's the 3NF fix?",
          "options": [
            "Remove author columns from Book",
            "Move author_name and author_country to an Author table",
            "Make author_id part of the PK",
            "Add a trigger to sync data"
          ],
          "correct": 1,
          "explanation": "Create Author(author_id, author_name, author_country). Book keeps (isbn, title, author_id). No transitive dependency remains.",
          "detailedExplanation": "The decision turns on \"what's the 3NF fix\". Solve this as chained reasoning where stage two must respect stage one assumptions. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: schema optimized for entities instead of queries."
        }
      ],
      "detailedExplanation": "This prompt is really about \"normalization\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-019",
      "type": "multiple-choice",
      "question": "What is BCNF (Boyce-Codd Normal Form)?",
      "options": [
        "Same as 3NF",
        "3NF plus: every determinant must be a candidate key",
        "4NF without multi-valued dependencies",
        "The maximum normalization level"
      ],
      "correct": 1,
      "explanation": "BCNF: for every functional dependency X → Y, X must be a superkey. It's slightly stricter than 3NF—handles edge cases where a non-key column determines part of a composite key.",
      "detailedExplanation": "Use \"bCNF (Boyce-Codd Normal Form)\" as your starting point, then verify tradeoffs carefully. Prefer the schema/index decision that minimizes query and write amplification for this workload. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-020",
      "type": "ordering",
      "question": "Rank these by number of joins typically needed to retrieve a full record (FEWEST to MOST):",
      "items": [
        "Single denormalized table",
        "2NF (some partial dependencies removed)",
        "3NF (fully normalized)",
        "BCNF with junction tables"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "More normalization = more tables = more joins. Denormalized: 0 joins. 2NF: some. 3NF: more. BCNF with junctions: most joins.",
      "detailedExplanation": "The key clue in this question is \"rank these by number of joins typically needed to retrieve a full record (FEWEST to\". Place obvious extremes first, then sort the middle by pairwise comparison. Schema and index choices should follow access patterns and write/read amplification constraints. Numbers such as 0 should be normalized first so downstream reasoning stays consistent. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-021",
      "type": "multi-select",
      "question": "Which problems does storing customer_name directly on Order cause?",
      "options": [
        "Update anomaly: name change requires updating all orders",
        "Storage waste: name duplicated per order",
        "Deletion anomaly: deleting all orders loses the customer",
        "Stale data: old orders show old names (could be desired or not)"
      ],
      "correctIndices": [0, 1, 2, 3],
      "explanation": "All four are real issues. Note: stale data is sometimes intentional (you WANT old orders to show the name at time of purchase).",
      "detailedExplanation": "Start from \"problems does storing customer_name directly on Order cause\", then pressure-test the result against the options. Validate each option independently; do not select statements that are only partially true. A strong caching answer names staleness limits, invalidation behavior, and keying strategy. Common pitfall: stale data despite high hit rates.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-022",
      "type": "multiple-choice",
      "question": "When is 'stale' denormalized data actually desirable?",
      "options": [
        "Never—always normalize",
        "When you need historical accuracy (e.g., order should show the address it shipped to)",
        "When queries are slow",
        "When using NoSQL"
      ],
      "correct": 1,
      "explanation": "Orders should record the shipping address at time of purchase, not a reference that changes when the user updates their address. This is intentional denormalization for historical accuracy.",
      "detailedExplanation": "The decision turns on \"'stale' denormalized data actually desirable\". Reject options that improve speed but weaken freshness or invalidation correctness. Cache design quality is mostly about correctness boundaries, not only hit rate. Common pitfall: hot-key skew causing uneven load.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-023",
      "type": "numeric-input",
      "question": "A non-normalized table has: Order(id, product_name, product_price, category_name, customer_name, customer_email). How many entities should be extracted to reach 3NF?",
      "answer": 3,
      "tolerance": "exact",
      "explanation": "Three entities to extract: Product (name, price, category), Category (name), Customer (name, email). Plus Order references them by FK.",
      "detailedExplanation": "Read this as a scenario about \"non-normalized table has: Order(id, product_name, product_price, category_name,\". Write the unit conversion path explicitly, then calculate, then sanity-check magnitude. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-024",
      "type": "two-stage",
      "stages": [
        {
          "question": "Table: Employee(id, name, skill1, skill2, skill3). What normal form does this violate?",
          "options": [
            "1NF — repeating groups",
            "2NF — partial dependency",
            "3NF — transitive dependency",
            "It's normalized"
          ],
          "correct": 0,
          "explanation": "skill1, skill2, skill3 are repeating groups—the same type of data in multiple columns. This violates 1NF.",
          "detailedExplanation": "The decision turns on \"table: Employee(id, name, skill1, skill2, skill3)\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: indexing that over-amplifies writes."
        },
        {
          "question": "How do you normalize it?",
          "options": [
            "Combine into one skill column",
            "Create EmployeeSkill(employee_id, skill) table",
            "Use a JSON array",
            "Add more skill columns"
          ],
          "correct": 1,
          "explanation": "EmployeeSkill table with (employee_id, skill). Each skill is a separate row. Handles any number of skills without schema changes.",
          "detailedExplanation": "Start from \"you normalize it\", then pressure-test the result against the options. Solve this as chained reasoning where stage two must respect stage one assumptions. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: unbounded cardinality in joins or fan-out."
        }
      ],
      "detailedExplanation": "Use \"normalization\" as your starting point, then verify tradeoffs carefully. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-025",
      "type": "multi-select",
      "question": "Which violate 1NF?",
      "options": [
        "Column storing JSON array of tags",
        "Column storing a single integer",
        "Column storing 'New York, NY' (city and state in one field)",
        "Column storing a boolean"
      ],
      "correctIndices": [0, 2],
      "explanation": "JSON array has multiple values in one field. City+state is two facts in one column. Single integer and boolean are atomic values—1NF compliant.",
      "detailedExplanation": "This prompt is really about \"violate 1NF\". Validate each option independently; do not select statements that are only partially true. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-026",
      "type": "multiple-choice",
      "question": "What's a functional dependency?",
      "options": [
        "A function in the application code",
        "If you know column A, you can determine column B: written A → B",
        "A foreign key relationship",
        "A stored procedure"
      ],
      "correct": 1,
      "explanation": "A → B means knowing A uniquely determines B. Example: student_id → student_name. If you know the student_id, the name is determined. This is the foundation of normalization.",
      "detailedExplanation": "If you keep \"what's a functional dependency\" in view, the correct answer separates faster. Discard modeling choices that look clean but perform poorly for the target queries. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-027",
      "type": "ordering",
      "question": "Rank these issues by how directly normalization addresses them (MOST to LEAST directly):",
      "items": [
        "Data redundancy",
        "Update anomalies",
        "Query performance",
        "Storage cost"
      ],
      "correctOrder": [0, 1, 3, 2],
      "explanation": "Normalization directly targets redundancy and anomalies. Storage reduction is a byproduct. Query performance can actually decrease (more joins)—normalization doesn't optimize for reads.",
      "detailedExplanation": "The core signal here is \"rank these issues by how directly normalization addresses them (MOST to LEAST directly):\". Order by relative scale and bottleneck effect, then validate neighboring items. Storage decisions should align durability expectations with access and cost behavior. Common pitfall: underestimating replication and retention overhead.",
      "references": [
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        },
        {
          "title": "Google Cloud Storage pricing",
          "url": "https://cloud.google.com/storage/pricing"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "norm-028",
      "type": "multiple-choice",
      "question": "A table has PK(student_id), and columns: name, advisor_id, advisor_email. What's the highest normal form?",
      "options": ["1NF", "2NF", "3NF", "Not even 1NF"],
      "correct": 1,
      "explanation": "It's in 2NF (single-column PK, so no partial dependencies possible). But advisor_email depends on advisor_id (a non-key column), creating a transitive dependency. Not 3NF.",
      "detailedExplanation": "The key clue in this question is \"table has PK(student_id), and columns: name, advisor_id, advisor_email\". Discard modeling choices that look clean but perform poorly for the target queries. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-029",
      "type": "multi-select",
      "question": "Which are examples of the deletion anomaly?",
      "options": [
        "Deleting the last student of an advisor loses the advisor's info",
        "Deleting all orders of a product loses the product info (if only stored on orders)",
        "Deleting a user removes their profile",
        "Deleting an order removes its line items (CASCADE)"
      ],
      "correctIndices": [0, 1],
      "explanation": "Deletion anomaly: losing Entity A's data when deleting Entity B. User→profile and order→items are intentional cascades, not anomalies.",
      "detailedExplanation": "Start from \"examples of the deletion anomaly\", then pressure-test the result against the options. Avoid pattern guessing and evaluate each candidate directly against the scenario. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-030",
      "type": "two-stage",
      "stages": [
        {
          "question": "Invoice(id, customer_id, customer_name, customer_address, total). Is customer_name a transitive dependency?",
          "options": [
            "No — it depends directly on the PK",
            "Yes — id → customer_id → customer_name"
          ],
          "correct": 1,
          "explanation": "customer_name depends on customer_id, which depends on id. That's transitive: id → customer_id → customer_name. Violates 3NF.",
          "detailedExplanation": "The core signal here is \"invoice(id, customer_id, customer_name, customer_address, total)\". Do not reset assumptions between stages; carry forward prior constraints directly. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: schema optimized for entities instead of queries."
        },
        {
          "question": "But for invoices, you WANT to preserve the customer name at time of invoicing. How do you handle this?",
          "options": [
            "Accept the 3NF violation as intentional",
            "Normalize AND add a snapshot column: billing_name",
            "Always join to get the current name",
            "Store a versioned customer history"
          ],
          "correct": 1,
          "explanation": "Normalize customer data (FK to Customer) AND add billing_name/billing_address on Invoice for point-in-time record. Both current data and historical snapshot.",
          "detailedExplanation": "Use \"but for invoices, you WANT to preserve the customer name at time of invoicing\" as your starting point, then verify tradeoffs carefully. Do not reset assumptions between stages; carry forward prior constraints directly. Storage decisions should align durability expectations with access and cost behavior. Common pitfall: underestimating replication and retention overhead."
        }
      ],
      "detailedExplanation": "The core signal here is \"normalization\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-031",
      "type": "multiple-choice",
      "question": "A column stores: '2024-01-15 10:30 America/New_York'. Is this 1NF compliant?",
      "options": [
        "Yes — it's a single value",
        "No — it combines date, time, and timezone",
        "Depends on the data type",
        "Only if stored as TIMESTAMPTZ"
      ],
      "correct": 2,
      "explanation": "If stored as TIMESTAMPTZ (one atomic data type that inherently includes timezone), it's 1NF. If stored as a string combining separate concepts, arguable violation.",
      "detailedExplanation": "If you keep \"column stores: '2024-01-15 10:30 America/New_York'\" in view, the correct answer separates faster. Discard modeling choices that look clean but perform poorly for the target queries. Choose data shape based on workload paths, not on normalization dogma alone. Numbers such as 2024 and 01 should be normalized first so downstream reasoning stays consistent. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-032",
      "type": "numeric-input",
      "question": "Table: Sale(id, product, category, customer, city, state, zip). How many transitive dependencies exist?",
      "answer": 2,
      "tolerance": "exact",
      "explanation": "Two: (1) product → category (category depends on product, not sale id). (2) zip → city, state (city/state determined by zip code). Both are transitive through non-key columns.",
      "detailedExplanation": "This prompt is really about \"table: Sale(id, product, category, customer, city, state, zip)\". Write the unit conversion path explicitly, then calculate, then sanity-check magnitude. Schema and index choices should follow access patterns and write/read amplification constraints. Numbers such as 1 and 2 should be normalized first so downstream reasoning stays consistent. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-033",
      "type": "multi-select",
      "question": "Which are benefits of 3NF?",
      "options": [
        "Single source of truth for each fact",
        "Simpler updates (change data in one place)",
        "Fewer tables",
        "Structural integrity — schema prevents inconsistencies"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "3NF means each fact is stored once (single source), updates touch one row, and the schema structure prevents inconsistencies. But 3NF typically means MORE tables, not fewer.",
      "detailedExplanation": "Use \"benefits of 3NF\" as your starting point, then verify tradeoffs carefully. Avoid pattern guessing and evaluate each candidate directly against the scenario. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-034",
      "type": "multiple-choice",
      "question": "Table: StudentCourse(student_id, course_id, course_dept, grade). PK: (student_id, course_id). Which column violates 2NF?",
      "options": ["grade", "course_dept", "student_id", "None — it's in 2NF"],
      "correct": 1,
      "explanation": "course_dept depends only on course_id (part of the PK), not on the full composite key. This is a partial dependency, violating 2NF. grade depends on both—it's fine.",
      "detailedExplanation": "Read this as a scenario about \"table: StudentCourse(student_id, course_id, course_dept, grade)\". Prefer the schema/index decision that minimizes query and write amplification for this workload. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-035",
      "type": "ordering",
      "question": "To normalize this table, rank the steps (FIRST to LAST): Table has repeating groups, partial dependencies, and transitive dependencies.",
      "items": [
        "Remove repeating groups (reach 1NF)",
        "Remove partial dependencies (reach 2NF)",
        "Remove transitive dependencies (reach 3NF)"
      ],
      "correctOrder": [0, 1, 2],
      "explanation": "Normalize in order: 1NF first (atomic values), then 2NF (eliminate partial deps), then 3NF (eliminate transitive deps). Each form builds on the previous.",
      "detailedExplanation": "The decision turns on \"to normalize this table, rank the steps (FIRST to LAST): Table has repeating groups,\". Order by relative scale and bottleneck effect, then validate neighboring items. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-036",
      "type": "two-stage",
      "stages": [
        {
          "question": "OrderDetail(order_id, product_id, product_name, product_category, qty, price). PK: (order_id, product_id). What violates 2NF?",
          "options": [
            "qty and price",
            "product_name and product_category",
            "order_id",
            "Nothing"
          ],
          "correct": 1,
          "explanation": "product_name and product_category depend only on product_id—partial dependency on the composite PK.",
          "detailedExplanation": "This prompt is really about \"orderDetail(order_id, product_id, product_name, product_category, qty, price)\". Solve this as chained reasoning where stage two must respect stage one assumptions. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: unbounded cardinality in joins or fan-out."
        },
        {
          "question": "After moving product_name and product_category to a Product table, is OrderDetail now in 3NF?",
          "options": [
            "Yes — OrderDetail(order_id, product_id, qty, price) has no transitive deps",
            "No — price depends on product_id",
            "No — qty depends on order_id",
            "Depends on whether price is per-order or per-product"
          ],
          "correct": 3,
          "explanation": "If price is the price at time of purchase (per order-product), it depends on the full PK—3NF. If it's always the product's current price, it depends on product_id—extract it.",
          "detailedExplanation": "If you keep \"after moving product_name and product_category to a Product table, is OrderDetail now\" in view, the correct answer separates faster. Do not reset assumptions between stages; carry forward prior constraints directly. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: indexing that over-amplifies writes."
        }
      ],
      "detailedExplanation": "Start from \"normalization\", then pressure-test the result against the options. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-037",
      "type": "multiple-choice",
      "question": "Which normal form eliminates multi-valued dependencies?",
      "options": ["2NF", "3NF", "BCNF", "4NF"],
      "correct": 3,
      "explanation": "4NF eliminates multi-valued dependencies (where two independent multi-valued facts about an entity are stored in the same table). Most practical schemas stop at 3NF or BCNF.",
      "detailedExplanation": "The key clue in this question is \"normal form eliminates multi-valued dependencies\". Discard modeling choices that look clean but perform poorly for the target queries. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-038",
      "type": "multi-select",
      "question": "Which schemas are in 3NF?",
      "options": [
        "User(id, name, email)",
        "User(id, name, dept_id, dept_name)",
        "Order(id, customer_id, total)",
        "Order(id, customer_id, customer_name, total)"
      ],
      "correctIndices": [0, 2],
      "explanation": "User(id, name, email): no transitive deps. Order(id, customer_id, total): no transitive deps. The others have non-key columns depending on other non-key columns.",
      "detailedExplanation": "The core signal here is \"schemas are in 3NF\". Validate each option independently; do not select statements that are only partially true. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-039",
      "type": "multiple-choice",
      "question": "What does 'every non-key attribute must depend on the key, the whole key, and nothing but the key' describe?",
      "options": [
        "1NF",
        "2NF",
        "3NF",
        "It summarizes all three: 1NF + 2NF + 3NF"
      ],
      "correct": 3,
      "explanation": "'The key' = 1NF (data has a key). 'The whole key' = 2NF (no partial deps). 'Nothing but the key' = 3NF (no transitive deps). This mnemonic covers all three normal forms.",
      "detailedExplanation": "If you keep \"'every non-key attribute must depend on the key, the whole key, and nothing but the\" in view, the correct answer separates faster. Discard modeling choices that look clean but perform poorly for the target queries. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-040",
      "type": "ordering",
      "question": "Rank by severity of normalization violation (MOST to LEAST severe):",
      "items": [
        "Repeating groups (violates 1NF)",
        "Partial dependency (violates 2NF)",
        "Transitive dependency (violates 3NF)"
      ],
      "correctOrder": [0, 1, 2],
      "explanation": "1NF violations are most severe—data can't even be properly queried. Partial deps (2NF) cause widespread redundancy. Transitive deps (3NF) are the mildest—often intentionally tolerated.",
      "detailedExplanation": "The decision turns on \"rank by severity of normalization violation (MOST to LEAST severe):\". Build the rank from biggest differences first, then refine with adjacent checks. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-041",
      "type": "numeric-input",
      "question": "An unnormalized table: Employee(id, name, phone_numbers, dept_id, dept_name, dept_head). How many normalization steps to reach 3NF? (Count: fix 1NF, fix 2NF, fix 3NF as separate steps)",
      "answer": 2,
      "tolerance": "exact",
      "explanation": "Step 1: Fix 1NF — extract phone_numbers to EmployeePhone table. Step 2: Fix 3NF — extract dept_name and dept_head to Department table. (2NF isn't violated with a single-column PK.) Two steps.",
      "detailedExplanation": "Read this as a scenario about \"unnormalized table: Employee(id, name, phone_numbers, dept_id, dept_name, dept_head)\". Normalize units before computing so conversion mistakes do not propagate. Modeling quality is measured by query fit, cardinality behavior, and operational cost. If values like 1 and 2 appear, convert them into one unit basis before comparison. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-042",
      "type": "two-stage",
      "stages": [
        {
          "question": "Table: Booking(id, guest_name, room_number, room_type, room_rate, check_in, check_out). What's wrong?",
          "options": [
            "Nothing",
            "room_type and room_rate depend on room_number, not booking id (transitive)",
            "guest_name should be in a Guest table",
            "Both B and C"
          ],
          "correct": 3,
          "explanation": "Two issues: room_type/room_rate depend on room_number (transitive dep), and guest_name should reference a Guest entity.",
          "detailedExplanation": "If you keep \"table: Booking(id, guest_name, room_number, room_type, room_rate, check_in, check_out)\" in view, the correct answer separates faster. Solve this as chained reasoning where stage two must respect stage one assumptions. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: indexing that over-amplifies writes."
        },
        {
          "question": "After normalizing, how many tables?",
          "options": [
            "2 (Booking + Room)",
            "3 (Booking + Room + Guest)",
            "4 (Booking + Room + Guest + RoomType)",
            "1 (just fix columns)"
          ],
          "correct": 1,
          "explanation": "Three: Guest(id, name), Room(number, type, rate), Booking(id, guest_id, room_number, check_in, check_out). RoomType could be separate but rate may vary per room.",
          "detailedExplanation": "This prompt is really about \"after normalizing, how many tables\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: unbounded cardinality in joins or fan-out."
        }
      ],
      "detailedExplanation": "The key clue in this question is \"normalization\". Solve this as chained reasoning where stage two must respect stage one assumptions. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-043",
      "type": "multi-select",
      "question": "Which indicate a table is NOT in 1NF?",
      "options": [
        "A column stores a JSON array",
        "A column stores a comma-separated list",
        "The table has columns like tag1, tag2, tag3",
        "A column stores a single foreign key"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "JSON arrays, CSV lists, and repeating numbered columns all store multiple values where 1NF requires one atomic value per cell.",
      "detailedExplanation": "Start from \"indicate a table is NOT in 1NF\", then pressure-test the result against the options. Avoid pattern guessing and evaluate each candidate directly against the scenario. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-044",
      "type": "multiple-choice",
      "question": "In practice, how normalized should most OLTP systems be?",
      "options": [
        "Always 5NF for maximum correctness",
        "3NF is the standard target for most OLTP systems",
        "1NF is sufficient for modern databases",
        "Normalization is obsolete with NoSQL"
      ],
      "correct": 1,
      "explanation": "3NF is the standard target for transactional systems. It eliminates most redundancy while remaining practical. Higher forms (BCNF, 4NF, 5NF) are rarely needed.",
      "detailedExplanation": "If you keep \"in practice, how normalized should most OLTP systems be\" in view, the correct answer separates faster. Prefer the schema/index decision that minimizes query and write amplification for this workload. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-045",
      "type": "multiple-choice",
      "question": "What's the difference between 3NF and BCNF?",
      "options": [
        "They're identical",
        "BCNF is stricter: in 3NF, a non-key can determine another non-key if it's also a candidate key; BCNF doesn't allow this",
        "BCNF allows transitive dependencies",
        "BCNF requires 4NF"
      ],
      "correct": 1,
      "explanation": "In 3NF, a dependency A → B is allowed if A is a candidate key. BCNF requires A to be a superkey for ANY dependency—slightly stricter. The difference rarely matters in practice.",
      "detailedExplanation": "The core signal here is \"what's the difference between 3NF and BCNF\". Reject options that conflict with the primary access pattern or index strategy. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-046",
      "type": "ordering",
      "question": "Rank these considerations when deciding normalization level (MOST to LEAST important for OLTP):",
      "items": [
        "Data integrity (no anomalies)",
        "Write performance (fewer updates)",
        "Read performance (fewer joins)",
        "Storage efficiency"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "For OLTP: integrity is paramount, then write efficiency (normalized = fewer updates). Read performance can be improved with indexes/caching. Storage is cheap.",
      "detailedExplanation": "Use \"rank these considerations when deciding normalization level (MOST to LEAST important\" as your starting point, then verify tradeoffs carefully. Place obvious extremes first, then sort the middle by pairwise comparison. Capacity answers are more defensible when growth and replication are modeled explicitly. Common pitfall: choosing tier by cost only and missing access constraints.",
      "references": [
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        },
        {
          "title": "Google Cloud Storage pricing",
          "url": "https://cloud.google.com/storage/pricing"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "norm-047",
      "type": "multi-select",
      "question": "Which are signs that a table needs further normalization?",
      "options": [
        "Same value appears in many rows (e.g., department_name repeated)",
        "Updating one fact requires changing many rows",
        "You can't add an entity without adding unrelated data",
        "The table has more than 10 columns"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "Repeated values, multi-row updates for one fact, and insertion anomalies all signal normalization issues. Column count alone doesn't indicate normalization problems.",
      "detailedExplanation": "This prompt is really about \"signs that a table needs further normalization\". Validate each option independently; do not select statements that are only partially true. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-048",
      "type": "two-stage",
      "stages": [
        {
          "question": "Table: Course(course_id, title, instructor_id, instructor_name, instructor_dept). What normal form is this?",
          "options": ["1NF", "2NF", "3NF", "Not even 1NF"],
          "correct": 1,
          "explanation": "It's in 2NF (single-column PK, no partial deps). But instructor_name and instructor_dept depend on instructor_id (transitive). Not 3NF.",
          "detailedExplanation": "Use \"table: Course(course_id, title, instructor_id, instructor_name, instructor_dept)\" as your starting point, then verify tradeoffs carefully. Solve this as chained reasoning where stage two must respect stage one assumptions. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: schema optimized for entities instead of queries."
        },
        {
          "question": "Is there a scenario where keeping instructor_name on Course is acceptable?",
          "options": [
            "No — always normalize",
            "Yes — if the instructor's name at time of teaching matters for historical records",
            "Only in NoSQL",
            "Only for read performance"
          ],
          "correct": 1,
          "explanation": "If you need to record 'who taught this course that semester' and names change (marriage, legal change), a snapshot is valid. But model it explicitly (e.g., instructor_name_at_time).",
          "detailedExplanation": "The core signal here is \"is there a scenario where keeping instructor_name on Course is acceptable\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Storage decisions should align durability expectations with access and cost behavior. Common pitfall: underestimating replication and retention overhead."
        }
      ],
      "detailedExplanation": "The decision turns on \"normalization\". Solve this as chained reasoning where stage two must respect stage one assumptions. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-049",
      "type": "multiple-choice",
      "question": "What is a determinant?",
      "options": [
        "The primary key",
        "Any column (or set of columns) that functionally determines another column",
        "A column with a UNIQUE constraint",
        "A foreign key"
      ],
      "correct": 1,
      "explanation": "A determinant is the left side of a functional dependency (X → Y). X determines Y. The PK is always a determinant, but other columns can be too (e.g., email → user_id if email is unique).",
      "detailedExplanation": "Read this as a scenario about \"a determinant\". Prefer the schema/index decision that minimizes query and write amplification for this workload. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-050",
      "type": "multi-select",
      "question": "In Employee(id, email, dept_id, dept_name), which are determinants?",
      "options": [
        "id (determines all other columns)",
        "email (determines id, name if unique)",
        "dept_id (determines dept_name)",
        "dept_name (determines dept_id if unique)"
      ],
      "correctIndices": [0, 1, 2, 3],
      "explanation": "All can be determinants if they uniquely determine other values. id determines everything. email might too if unique. dept_id ↔ dept_name if each is unique.",
      "detailedExplanation": "Start from \"in Employee(id, email, dept_id, dept_name), which are determinants\", then pressure-test the result against the options. Treat every option as a separate true/false test under the same constraints. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-051",
      "type": "multiple-choice",
      "question": "A table stores: Order(id, customer_id, shipping_street, shipping_city, shipping_state, shipping_zip). Is it in 3NF?",
      "options": [
        "Yes — all columns depend on the PK",
        "No — zip → city, state is a transitive dependency",
        "No — shipping address should be its own entity",
        "Both B and C"
      ],
      "correct": 1,
      "explanation": "zip → city and zip → state are transitive dependencies (id → zip → city/state). To reach 3NF, extract to ZipCode(zip, city, state). In practice, this level of normalization is often skipped.",
      "detailedExplanation": "The key clue in this question is \"table stores: Order(id, customer_id, shipping_street, shipping_city, shipping_state,\". Prefer the schema/index decision that minimizes query and write amplification for this workload. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-052",
      "type": "ordering",
      "question": "Rank these real-world normalization trade-offs by how commonly they're made (MOST to LEAST common):",
      "items": [
        "Store address fields directly (skip zip→city normalization)",
        "Store customer_name on Order for historical record",
        "Store product_name on OrderItem for point-in-time pricing",
        "Fully normalize everything to 5NF"
      ],
      "correctOrder": [0, 2, 1, 3],
      "explanation": "Address denormalization is ubiquitous. Point-in-time pricing is very common. Historical name on orders is common. Full 5NF normalization is extremely rare in practice.",
      "detailedExplanation": "Read this as a scenario about \"rank these real-world normalization trade-offs by how commonly they're made (MOST to\". Order by relative scale and bottleneck effect, then validate neighboring items. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-053",
      "type": "multiple-choice",
      "question": "What's the relationship between normalization and JOIN count?",
      "options": [
        "Normalization reduces JOINs",
        "Higher normalization increases JOINs needed to reconstruct full records",
        "No relationship",
        "Normalization eliminates JOINs"
      ],
      "correct": 1,
      "explanation": "Each extracted table adds a potential JOIN. A denormalized table with all data needs zero JOINs. A 3NF schema with separate Customer, Product, and Category needs JOINs to combine them.",
      "detailedExplanation": "The decision turns on \"what's the relationship between normalization and JOIN count\". Reject options that conflict with the primary access pattern or index strategy. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-054",
      "type": "numeric-input",
      "question": "A fully denormalized Order row has 20 columns (order + customer + product data). After normalizing to 3NF with Order, Customer, Product, and Category tables, how many JOINs to reconstruct the full row?",
      "answer": 3,
      "tolerance": "exact",
      "explanation": "Three JOINs: Order JOIN Customer, JOIN Product, JOIN Category (assuming Product references Category). Each extracted entity adds one JOIN.",
      "detailedExplanation": "This prompt is really about \"fully denormalized Order row has 20 columns (order + customer + product data)\". Normalize units before computing so conversion mistakes do not propagate. Choose data shape based on workload paths, not on normalization dogma alone. If values like 20 appear, convert them into one unit basis before comparison. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-055",
      "type": "two-stage",
      "stages": [
        {
          "question": "Table: Product(id, name, category_id, category_name, supplier_id, supplier_name, supplier_country). How many 3NF violations?",
          "options": ["0", "1", "2", "3"],
          "correct": 2,
          "explanation": "Two transitive dependencies: (1) category_id → category_name, (2) supplier_id → supplier_name, supplier_country.",
          "detailedExplanation": "The decision turns on \"table: Product(id, name, category_id, category_name, supplier_id, supplier_name,\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Choose data shape based on workload paths, not on normalization dogma alone. Keep quantities like 1 and 2 in aligned units before selecting an answer. Common pitfall: unbounded cardinality in joins or fan-out."
        },
        {
          "question": "After normalizing, how many tables?",
          "options": ["2", "3", "4"],
          "correct": 1,
          "explanation": "Three: Product(id, name, category_id, supplier_id), Category(id, name), Supplier(id, name, country).",
          "detailedExplanation": "Start from \"after normalizing, how many tables\", then pressure-test the result against the options. Do not reset assumptions between stages; carry forward prior constraints directly. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: indexing that over-amplifies writes."
        }
      ],
      "detailedExplanation": "Use \"normalization\" as your starting point, then verify tradeoffs carefully. Solve this as chained reasoning where stage two must respect stage one assumptions. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-056",
      "type": "multi-select",
      "question": "Which of these represent intentional (acceptable) denormalization?",
      "options": [
        "Storing shipping address on Order (point-in-time record)",
        "Caching user's post count on User table",
        "Storing product name on OrderItem for invoice history",
        "Storing department name on every Employee row"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "First three are intentional: point-in-time data and cached aggregates. Department name on Employee is unintentional redundancy—it should reference a Department table.",
      "detailedExplanation": "The core signal here is \"of these represent intentional (acceptable) denormalization\". Treat every option as a separate true/false test under the same constraints. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-057",
      "type": "multiple-choice",
      "question": "In the context of normalization, what is a 'prime attribute'?",
      "options": [
        "The most important column",
        "An attribute that is part of any candidate key",
        "The primary key column",
        "A column with a unique constraint"
      ],
      "correct": 1,
      "explanation": "A prime attribute belongs to at least one candidate key. Non-prime attributes don't belong to any candidate key. 2NF and 3NF rules apply to non-prime attributes.",
      "detailedExplanation": "If you keep \"in the context of normalization, what is a 'prime attribute'\" in view, the correct answer separates faster. Prefer the schema/index decision that minimizes query and write amplification for this workload. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-058",
      "type": "ordering",
      "question": "Rank these schema smells by likelihood of indicating a normalization problem (MOST to LEAST likely):",
      "items": [
        "Column storing comma-separated values",
        "Same column name appearing in multiple tables (e.g., customer_name in Orders AND Invoices)",
        "Table with 50+ columns mixing data from different entities",
        "Table with a single-column PK and 5 attributes"
      ],
      "correctOrder": [0, 2, 1, 3],
      "explanation": "CSV values: definite 1NF violation. 50+ columns mixing entities: likely denormalized. Duplicate names across tables: possible redundancy. 5 attributes with PK: well-structured, no red flags.",
      "detailedExplanation": "Start from \"rank these schema smells by likelihood of indicating a normalization problem (MOST to\", then pressure-test the result against the options. Place obvious extremes first, then sort the middle by pairwise comparison. Schema and index choices should follow access patterns and write/read amplification constraints. Keep quantities like 50 and 5 in aligned units before selecting an answer. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-059",
      "type": "multiple-choice",
      "question": "What's a lossless join decomposition?",
      "options": [
        "A join that doesn't lose performance",
        "Splitting a table into smaller tables such that joining them back produces exactly the original data",
        "Removing columns without losing data",
        "A join that doesn't require indexes"
      ],
      "correct": 1,
      "explanation": "Lossless decomposition: when you split a table during normalization, joining the resulting tables must reproduce the original data exactly—no rows lost or added.",
      "detailedExplanation": "The key clue in this question is \"what's a lossless join decomposition\". Discard modeling choices that look clean but perform poorly for the target queries. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-060",
      "type": "two-stage",
      "stages": [
        {
          "question": "A junior developer proposes: 'Let's put everything in one big table to avoid JOINs.' What's the strongest counterargument?",
          "options": [
            "JOINs are fast with proper indexes",
            "Update anomalies will cause data inconsistencies",
            "The table will be too wide",
            "Storage will be wasted"
          ],
          "correct": 1,
          "explanation": "The strongest argument: denormalized data leads to inconsistencies. When the same fact is stored in 100 places, updating it requires changing 100 rows—miss one and data is wrong.",
          "detailedExplanation": "The decision turns on \"junior developer proposes: 'Let's put everything in one big table to avoid JOINs\". Do not reset assumptions between stages; carry forward prior constraints directly. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Numbers such as 100 should be normalized first so downstream reasoning stays consistent. Common pitfall: unbounded cardinality in joins or fan-out."
        },
        {
          "question": "The developer responds: 'We'll enforce consistency in application code.' What's wrong with that?",
          "options": [
            "Application code can have bugs; database constraints can't be bypassed",
            "Application code is slower",
            "Application code doesn't support transactions",
            "Nothing — application enforcement is fine"
          ],
          "correct": 0,
          "explanation": "Application bugs, race conditions, direct DB access, scripts, and migrations can all bypass application logic. Database-level normalization + constraints are the last line of defense.",
          "detailedExplanation": "Start from \"developer responds: 'We'll enforce consistency in application code\", then pressure-test the result against the options. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "Use \"normalization\" as your starting point, then verify tradeoffs carefully. Solve this as chained reasoning where stage two must respect stage one assumptions. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-061",
      "type": "multi-select",
      "question": "Which are true about normalization in NoSQL/document databases?",
      "options": [
        "NoSQL often intentionally denormalizes for read performance",
        "Embedding (denormalization) is a core document DB pattern",
        "Normalization principles still apply when data integrity matters",
        "NoSQL never uses normalization"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "NoSQL often denormalizes by design (embedding documents). But normalization principles still matter—references between documents are normalization. It's a spectrum, not binary.",
      "detailedExplanation": "This prompt is really about \"true about normalization in NoSQL/document databases\". Avoid pattern guessing and evaluate each candidate directly against the scenario. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-062",
      "type": "multiple-choice",
      "question": "Table: Employee(id, name, project_id, project_name, project_manager). What anomaly occurs if you delete the last employee on a project?",
      "options": [
        "Update anomaly",
        "Insertion anomaly",
        "Deletion anomaly — project info is lost",
        "No anomaly"
      ],
      "correct": 2,
      "explanation": "Deleting the last employee on a project loses the project's name and manager data. The project info only exists as duplicated data on employee rows.",
      "detailedExplanation": "If you keep \"table: Employee(id, name, project_id, project_name, project_manager)\" in view, the correct answer separates faster. Prefer the schema/index decision that minimizes query and write amplification for this workload. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-063",
      "type": "numeric-input",
      "question": "A company has 50 departments, each with an average of 200 employees. In a denormalized Employee table (with dept_name), how many rows store a redundant copy of dept_name?",
      "answer": 9950,
      "tolerance": 0.01,
      "explanation": "Each department has 200 employees, so dept_name appears 200 times per department. Only 1 copy per department is 'necessary' (the canonical one). Redundant copies: 50 × (200-1) = 9,950.",
      "detailedExplanation": "The core signal here is \"company has 50 departments, each with an average of 200 employees\". Keep every transformation in one unit system and check order of magnitude at the end. Schema and index choices should follow access patterns and write/read amplification constraints. Keep quantities like 50 and 200 in aligned units before selecting an answer. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-064",
      "type": "ordering",
      "question": "Rank these systems by how normalized they typically are (MOST to LEAST):",
      "items": [
        "Banking/financial OLTP",
        "E-commerce product catalog",
        "Analytics data warehouse",
        "Logging/event store"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Banking: highly normalized for integrity. E-commerce: mostly normalized. Data warehouses: intentionally denormalized (star schema). Event stores: append-only, minimal normalization.",
      "detailedExplanation": "The key clue in this question is \"rank these systems by how normalized they typically are (MOST to LEAST):\". Build the rank from biggest differences first, then refine with adjacent checks. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. Common pitfall: ordering loss during partition or replay changes.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "norm-065",
      "type": "multi-select",
      "question": "Which are valid reasons to stop at 2NF instead of going to 3NF?",
      "options": [
        "Read performance is critical and joins are expensive",
        "The transitive dependency is intentional (point-in-time snapshot)",
        "The team doesn't understand 3NF",
        "The dependent data rarely changes"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Performance needs, intentional snapshots, and rarely-changing data can justify stopping at 2NF. 'Team doesn't understand' isn't a valid reason—educate the team.",
      "detailedExplanation": "Start from \"valid reasons to stop at 2NF instead of going to 3NF\", then pressure-test the result against the options. Validate each option independently; do not select statements that are only partially true. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-066",
      "type": "two-stage",
      "stages": [
        {
          "question": "Table: Flight(flight_no, airline, airline_country, departure, arrival, plane_type, plane_capacity). How many entities should be extracted for 3NF?",
          "options": [
            "1 (Airline)",
            "2 (Airline, Plane)",
            "3 (Airline, Country, Plane)",
            "0 — it's already 3NF"
          ],
          "correct": 1,
          "explanation": "Two: Airline(code, name, country) and PlaneType(type, capacity). Flight keeps FKs to both. airline_country depends on airline (transitive), plane_capacity on plane_type.",
          "detailedExplanation": "Use \"table: Flight(flight_no, airline, airline_country, departure, arrival, plane_type,\" as your starting point, then verify tradeoffs carefully. Solve this as chained reasoning where stage two must respect stage one assumptions. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: indexing that over-amplifies writes."
        },
        {
          "question": "Is airline_country a transitive dependency through airline?",
          "options": [
            "Yes — flight_no → airline → airline_country",
            "No — country is about the flight route",
            "It depends on context",
            "Only if airline is unique"
          ],
          "correct": 0,
          "explanation": "airline_country depends on airline (the airline's home country), not on the flight. flight_no → airline → airline_country is a textbook transitive dependency.",
          "detailedExplanation": "The core signal here is \"is airline_country a transitive dependency through airline\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: schema optimized for entities instead of queries."
        }
      ],
      "detailedExplanation": "The decision turns on \"normalization\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-067",
      "type": "multiple-choice",
      "question": "What's the difference between OLTP and OLAP normalization approaches?",
      "options": [
        "OLTP prefers normalized schemas for integrity; OLAP prefers denormalized (star/snowflake) for query performance",
        "Both use 3NF",
        "OLTP is always denormalized",
        "OLAP doesn't use schemas"
      ],
      "correct": 0,
      "explanation": "OLTP (transactions): normalized to prevent anomalies. OLAP (analytics): denormalized (star schema, dimension tables) for fast aggregation queries with fewer joins.",
      "detailedExplanation": "Read this as a scenario about \"what's the difference between OLTP and OLAP normalization approaches\". Discard modeling choices that look clean but perform poorly for the target queries. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-068",
      "type": "multi-select",
      "question": "What is a star schema (used in data warehouses)?",
      "options": [
        "A central fact table with foreign keys to dimension tables",
        "Dimension tables are denormalized (wide, flat)",
        "Optimized for aggregation queries",
        "Fully normalized to 3NF"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "Star schema: fact table (sales, events) at center, surrounded by denormalized dimension tables (date, product, customer). Optimized for analytics, intentionally not normalized.",
      "detailedExplanation": "Use \"a star schema (used in data warehouses)\" as your starting point, then verify tradeoffs carefully. Validate each option independently; do not select statements that are only partially true. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-069",
      "type": "multiple-choice",
      "question": "A table has: Order(id, product_id, product_name). price is NOT stored. Is product_name a 3NF violation?",
      "options": [
        "Yes — product_name depends on product_id (transitive)",
        "No — product_name depends directly on the PK",
        "Only if there's a Product table",
        "Depends on whether product_id is a candidate key"
      ],
      "correct": 0,
      "explanation": "product_name is determined by product_id, a non-key column. id → product_id → product_name is transitive. Whether a Product table exists yet doesn't change the dependency.",
      "detailedExplanation": "This prompt is really about \"table has: Order(id, product_id, product_name)\". Prefer the schema/index decision that minimizes query and write amplification for this workload. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-070",
      "type": "ordering",
      "question": "Rank these approaches to handling the zip→city dependency (MOST to LEAST practical):",
      "items": [
        "Accept it and store city/state/zip on the address",
        "Create a ZipCode lookup table",
        "Validate via API but store all three",
        "Only store zip and derive city/state from an external service"
      ],
      "correctOrder": [0, 2, 1, 3],
      "explanation": "Most practical: just store all three (near-universal approach). API validation catches errors. ZipCode table works but adds maintenance. External derivation is fragile.",
      "detailedExplanation": "Read this as a scenario about \"rank these approaches to handling the zip→city dependency (MOST to LEAST practical):\". Build the rank from biggest differences first, then refine with adjacent checks. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "norm-071",
      "type": "multiple-choice",
      "question": "What is a multi-valued dependency (relevant to 4NF)?",
      "options": [
        "A column with multiple possible values",
        "An entity has two or more independent multi-valued facts",
        "Multiple foreign keys",
        "A dependency between values in an array"
      ],
      "correct": 1,
      "explanation": "Multi-valued dependency: an employee has multiple skills AND multiple languages, independently. Storing both in one table creates artificial combinations. 4NF separates them.",
      "detailedExplanation": "The decision turns on \"a multi-valued dependency (relevant to 4NF)\". Discard modeling choices that look clean but perform poorly for the target queries. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-072",
      "type": "two-stage",
      "stages": [
        {
          "question": "Table: EmpSkillLang(emp_id, skill, language). An employee knows {Java, Python} and speaks {English, French}. How many rows?",
          "options": ["2", "4", "6"],
          "correct": 1,
          "explanation": "Four rows: (emp, Java, English), (emp, Java, French), (emp, Python, English), (emp, Python, French). The Cartesian product of independent facts.",
          "detailedExplanation": "This prompt is really about \"table: EmpSkillLang(emp_id, skill, language)\". Do not reset assumptions between stages; carry forward prior constraints directly. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: unbounded cardinality in joins or fan-out."
        },
        {
          "question": "What's the 4NF fix?",
          "options": [
            "Add a surrogate PK",
            "Split into EmpSkill(emp_id, skill) and EmpLanguage(emp_id, language)",
            "Remove one of the columns",
            "Use JSON arrays"
          ],
          "correct": 1,
          "explanation": "Split into two tables: EmpSkill(emp, Java), (emp, Python) and EmpLanguage(emp, English), (emp, French). 4 rows → 4 rows, but no artificial Cartesian product.",
          "detailedExplanation": "If you keep \"what's the 4NF fix\" in view, the correct answer separates faster. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Schema and index choices should follow access patterns and write/read amplification constraints. If values like 4 appear, convert them into one unit basis before comparison. Common pitfall: indexing that over-amplifies writes."
        }
      ],
      "detailedExplanation": "Start from \"normalization\", then pressure-test the result against the options. Solve this as chained reasoning where stage two must respect stage one assumptions. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-073",
      "type": "multi-select",
      "question": "Which normal forms does the following table violate? Table: Student(id, name, courses_csv, advisor_id, advisor_name). courses_csv stores 'Math,Physics'.",
      "options": [
        "1NF (courses_csv is not atomic)",
        "2NF (no composite PK, so N/A)",
        "3NF (advisor_name depends on advisor_id)",
        "4NF (multi-valued dependency)"
      ],
      "correctIndices": [0, 2],
      "explanation": "Violates 1NF (CSV column) and 3NF (advisor_name transitive through advisor_id). 2NF not applicable (single PK). 4NF isn't relevant without the 1NF fix.",
      "detailedExplanation": "The key clue in this question is \"normal forms does the following table violate? Table: Student(id, name, courses_csv,\". Avoid pattern guessing and evaluate each candidate directly against the scenario. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-074",
      "type": "multiple-choice",
      "question": "A view joins normalized tables to present a denormalized result. Does this violate normalization?",
      "options": [
        "Yes — the view is denormalized",
        "No — the underlying tables are still normalized; the view is just a query",
        "Only if the view is materialized",
        "Depends on the database"
      ],
      "correct": 1,
      "explanation": "Views don't store data (unless materialized). A view that joins normalized tables provides convenience without violating normalization. The schema is still 3NF.",
      "detailedExplanation": "The core signal here is \"view joins normalized tables to present a denormalized result\". Prefer the schema/index decision that minimizes query and write amplification for this workload. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-075",
      "type": "numeric-input",
      "question": "A denormalized table has 5 entities' data in one table. To normalize to 3NF, what's the minimum number of tables?",
      "answer": 5,
      "tolerance": "exact",
      "explanation": "Minimum 5 tables—one per entity. Each entity's attributes go in its own table with a PK, and relationships are captured via FKs. More if there are M:N relationships.",
      "detailedExplanation": "If you keep \"denormalized table has 5 entities' data in one table\" in view, the correct answer separates faster. Normalize units before computing so conversion mistakes do not propagate. Choose data shape based on workload paths, not on normalization dogma alone. If values like 5 appear, convert them into one unit basis before comparison. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-076",
      "type": "ordering",
      "question": "Rank these scenarios by how much they benefit from normalization (MOST to LEAST benefit):",
      "items": [
        "Frequently updated master data (customer names, prices)",
        "Write-once event logs",
        "Read-heavy reporting dashboards",
        "Data that's written once and rarely updated (archived records)"
      ],
      "correctOrder": [0, 3, 1, 2],
      "explanation": "Frequently updated data benefits most (prevents update anomalies). Archived data: integrity matters. Write-once logs: append-only, less benefit. Dashboards: denormalized is faster.",
      "detailedExplanation": "This prompt is really about \"rank these scenarios by how much they benefit from normalization (MOST to LEAST\". Place obvious extremes first, then sort the middle by pairwise comparison. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-077",
      "type": "two-stage",
      "stages": [
        {
          "question": "Your colleague says 'NoSQL means we don't need normalization.' Is this correct?",
          "options": [
            "Yes — NoSQL is schema-free",
            "Partially — NoSQL trades normalization for read performance",
            "No — normalization principles apply regardless of database type",
            "Depends on the NoSQL type"
          ],
          "correct": 1,
          "explanation": "NoSQL intentionally denormalizes for performance (embedding, duplication). But normalization concepts still guide decisions—you're making conscious trade-offs, not ignoring the principles.",
          "detailedExplanation": "The decision turns on \"your colleague says 'NoSQL means we don't need normalization\". Do not reset assumptions between stages; carry forward prior constraints directly. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: schema optimized for entities instead of queries."
        },
        {
          "question": "In MongoDB, you embed a user's address in the user document. What normalization trade-off are you making?",
          "options": [
            "None — documents are different",
            "Denormalizing for read performance; accepting that updating all addresses of a type requires updating each document",
            "Violating 1NF",
            "Creating a transitive dependency"
          ],
          "correct": 1,
          "explanation": "Embedding = intentional denormalization. The trade-off: no join needed for reads, but if the address format changes, every document must be updated individually.",
          "detailedExplanation": "Start from \"in MongoDB, you embed a user's address in the user document\", then pressure-test the result against the options. Solve this as chained reasoning where stage two must respect stage one assumptions. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: schema optimized for entities instead of queries."
        }
      ],
      "detailedExplanation": "Use \"normalization\" as your starting point, then verify tradeoffs carefully. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-078",
      "type": "multi-select",
      "question": "Which are true about the practical limits of normalization?",
      "options": [
        "Most production schemas stop at 3NF",
        "4NF and 5NF are rarely used in practice",
        "Over-normalization can hurt read performance",
        "Normalization is always the right choice"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "3NF is the practical standard. 4NF/5NF are academic. Over-normalization creates too many small tables and JOINs. The right level depends on access patterns.",
      "detailedExplanation": "Read this as a scenario about \"true about the practical limits of normalization\". Validate each option independently; do not select statements that are only partially true. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-079",
      "type": "multiple-choice",
      "question": "What is 'dependency preservation' in normalization?",
      "options": [
        "Keeping all foreign keys",
        "After decomposition, all functional dependencies can still be enforced without joins",
        "Preserving backward compatibility",
        "Keeping dependent tables together"
      ],
      "correct": 1,
      "explanation": "Dependency preservation: after splitting tables, each functional dependency should be checkable within a single table (without joining). Some decompositions lose this property.",
      "detailedExplanation": "The decision turns on \"'dependency preservation' in normalization\". Reject options that conflict with the primary access pattern or index strategy. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-080",
      "type": "multiple-choice",
      "question": "Table: Shipment(id, order_id, carrier, carrier_phone, tracking_number). Is carrier_phone a 3NF violation?",
      "options": [
        "No — it depends on the PK",
        "Yes — carrier_phone depends on carrier (transitive)",
        "Only if carrier has a separate table",
        "Depends on whether carriers change phone numbers"
      ],
      "correct": 1,
      "explanation": "carrier_phone depends on carrier, not directly on shipment id. id → carrier → carrier_phone is transitive. Extract Carrier(name, phone).",
      "detailedExplanation": "If you keep \"table: Shipment(id, order_id, carrier, carrier_phone, tracking_number)\" in view, the correct answer separates faster. Discard modeling choices that look clean but perform poorly for the target queries. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-081",
      "type": "ordering",
      "question": "Rank these data types by how appropriate they are for a 1NF-compliant column (MOST to LEAST appropriate):",
      "items": [
        "INTEGER",
        "VARCHAR (single value)",
        "JSON object (structured data)",
        "TEXT[] (array)"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "INTEGER and single VARCHAR are fully atomic. JSON is debatable—atomic if treated as opaque, but multi-valued if queried. Arrays are explicitly multi-valued, violating strict 1NF.",
      "detailedExplanation": "The core signal here is \"rank these data types by how appropriate they are for a 1NF-compliant column (MOST to\". Build the rank from biggest differences first, then refine with adjacent checks. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-082",
      "type": "two-stage",
      "stages": [
        {
          "question": "You're designing an e-commerce schema. The PM says 'store the product name on each order line for invoices.' What's your response?",
          "options": [
            "Refuse — it violates 3NF",
            "Accept — this is valid point-in-time denormalization",
            "Ask: does the name need to be the name at time of purchase or the current name?",
            "Use a view instead"
          ],
          "correct": 2,
          "explanation": "The right question: is this a snapshot requirement? If products can be renamed, old invoices should show the original name. This determines whether it's a valid denormalization.",
          "detailedExplanation": "The decision turns on \"you're designing an e-commerce schema\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: unbounded cardinality in joins or fan-out."
        },
        {
          "question": "The PM confirms: 'We need the name at time of purchase.' How do you model it cleanly?",
          "options": [
            "Just store product_name on OrderItem",
            "Store product_name_at_purchase on OrderItem AND keep product_id FK to current Product",
            "Only store product_id and look up the name",
            "Create a ProductHistory table"
          ],
          "correct": 1,
          "explanation": "Both: product_id FK (for current data, joins, integrity) AND product_name_at_purchase (for the snapshot). This makes the intent clear and preserves both capabilities.",
          "detailedExplanation": "Start from \"pM confirms: 'We need the name at time of purchase\", then pressure-test the result against the options. Do not reset assumptions between stages; carry forward prior constraints directly. Storage decisions should align durability expectations with access and cost behavior. Common pitfall: underestimating replication and retention overhead."
        }
      ],
      "detailedExplanation": "Use \"normalization\" as your starting point, then verify tradeoffs carefully. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-083",
      "type": "multiple-choice",
      "question": "Which column in OrderItem(order_id, product_id, qty, unit_price, product_current_price) is problematic?",
      "options": [
        "unit_price (snapshot of price at purchase time)",
        "product_current_price (changes with product — update anomaly)",
        "qty (depends on the full composite key)",
        "order_id and product_id (foreign keys)"
      ],
      "correct": 1,
      "explanation": "product_current_price is redundant and will go stale — it changes when the product price changes, creating an update anomaly. unit_price is a valid snapshot (frozen at purchase time). qty depends on the full PK. The FKs are correct.",
      "detailedExplanation": "This prompt is really about \"column in OrderItem(order_id, product_id, qty, unit_price, product_current_price) is\". Prefer the choice that balances hit rate with clear staleness and invalidation behavior. Treat freshness policy and invalidation paths as first-class constraints. Common pitfall: hot-key skew causing uneven load.",
      "references": [
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        },
        {
          "title": "Google Cloud Storage pricing",
          "url": "https://cloud.google.com/storage/pricing"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "norm-084",
      "type": "multiple-choice",
      "question": "What does 'normalize until it hurts, then denormalize until it works' mean?",
      "options": [
        "Start fully normalized for integrity, then selectively denormalize where performance requires it",
        "Normalization is painful",
        "Denormalization is always better",
        "Try both and pick the faster one"
      ],
      "correct": 0,
      "explanation": "Start with a clean, normalized schema (3NF). When specific queries are too slow due to JOINs, strategically denormalize those hot paths. Integrity first, performance second.",
      "detailedExplanation": "The decision turns on \"'normalize until it hurts, then denormalize until it works' mean\". Discard modeling choices that look clean but perform poorly for the target queries. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-085",
      "type": "numeric-input",
      "question": "Table: LibraryLoan(loan_id, book_isbn, book_title, book_author, member_id, member_name, loan_date). How many non-key columns violate 3NF?",
      "answer": 3,
      "tolerance": "exact",
      "explanation": "Three: book_title and book_author depend on book_isbn (transitive), member_name depends on member_id (transitive). loan_date depends directly on loan_id (fine).",
      "detailedExplanation": "Read this as a scenario about \"table: LibraryLoan(loan_id, book_isbn, book_title, book_author, member_id, member_name,\". Normalize units before computing so conversion mistakes do not propagate. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-086",
      "type": "multi-select",
      "question": "After normalizing the library table above, which tables exist?",
      "options": [
        "LibraryLoan(loan_id, book_isbn, member_id, loan_date)",
        "Book(isbn, title, author)",
        "Member(id, name)",
        "LibraryLoan(loan_id, book_title, member_name, loan_date)"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "Three tables: LibraryLoan with FKs, Book with book attributes, Member with member attributes. The last option keeps the denormalized columns—that's what we're fixing.",
      "detailedExplanation": "The key clue in this question is \"after normalizing the library table above, which tables exist\". Avoid pattern guessing and evaluate each candidate directly against the scenario. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-087",
      "type": "two-stage",
      "stages": [
        {
          "question": "A developer stores user preferences as JSON: User(id, name, preferences JSON). Does this violate 1NF?",
          "options": [
            "Yes — JSON is not atomic",
            "No — if treated as a single opaque value",
            "It's a gray area — depends on how it's queried",
            "Only if using a relational database"
          ],
          "correct": 2,
          "explanation": "Strict interpretation: JSON is multi-valued → violates 1NF. Pragmatic: if you never query individual JSON fields in WHERE clauses, it acts like an opaque blob—acceptable.",
          "detailedExplanation": "This prompt is really about \"developer stores user preferences as JSON: User(id, name, preferences JSON)\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Capacity answers are more defensible when growth and replication are modeled explicitly. Common pitfall: choosing tier by cost only and missing access constraints."
        },
        {
          "question": "The app now needs to query WHERE preferences->>'theme' = 'dark'. Does your answer change?",
          "options": [
            "No — still fine as JSON",
            "Yes — the field is now being treated as structured data, not atomic",
            "Depends on database support",
            "Only matters for performance"
          ],
          "correct": 1,
          "explanation": "Querying inside JSON means it's structured data, not atomic. Consider: either add a GIN index (pragmatic) or extract theme to its own column (strict normalization).",
          "detailedExplanation": "If you keep \"app now needs to query WHERE preferences->>'theme' = 'dark'\" in view, the correct answer separates faster. Solve this as chained reasoning where stage two must respect stage one assumptions. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: schema optimized for entities instead of queries."
        }
      ],
      "detailedExplanation": "Start from \"normalization\", then pressure-test the result against the options. Do not reset assumptions between stages; carry forward prior constraints directly. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-088",
      "type": "multiple-choice",
      "question": "What is a 'derived attribute' and how does it relate to normalization?",
      "options": [
        "An attribute computed from other attributes (e.g., age from birth_date) — storing it creates redundancy",
        "An attribute inherited from a parent table",
        "A foreign key",
        "A computed column in a view"
      ],
      "correct": 0,
      "explanation": "Derived attributes (total_price = qty × unit_price, age = now - birth_date) are redundant because they can be computed. Storing them risks inconsistency but can improve read performance.",
      "detailedExplanation": "If you keep \"a 'derived attribute' and how does it relate to normalization\" in view, the correct answer separates faster. Prefer the schema/index decision that minimizes query and write amplification for this workload. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-089",
      "type": "ordering",
      "question": "Rank these derived values by how reasonable it is to store them (MOST to LEAST reasonable):",
      "items": [
        "Order total (sum of line items — expensive to recompute for every query)",
        "User's age (changes daily — always stale)",
        "Post word count (stable once published)",
        "Account balance (critical, frequently read)"
      ],
      "correctOrder": [3, 0, 2, 1],
      "explanation": "Account balance: critical, stored for integrity. Order total: expensive aggregate, worth caching. Word count: stable, cheap to store. Age: always stale, compute from birth_date.",
      "detailedExplanation": "The core signal here is \"rank these derived values by how reasonable it is to store them (MOST to LEAST\". Build the rank from biggest differences first, then refine with adjacent checks. A strong caching answer names staleness limits, invalidation behavior, and keying strategy. Common pitfall: invalidation races under concurrent writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-090",
      "type": "multi-select",
      "question": "Which of these schemas are in 1NF?",
      "options": [
        "User(id, name, email)",
        "User(id, name, phones TEXT[])",
        "Product(id, name, tags JSON)",
        "Order(id, date, total DECIMAL)"
      ],
      "correctIndices": [0, 3],
      "explanation": "User(id, name, email) and Order are 1NF—atomic values. TEXT[] and JSON are multi-valued, violating strict 1NF interpretation.",
      "detailedExplanation": "This prompt is really about \"of these schemas are in 1NF\". Avoid pattern guessing and evaluate each candidate directly against the scenario. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-091",
      "type": "multiple-choice",
      "question": "A schema has: Employee(id, name), Department(id, name), EmployeeDept(employee_id, department_id, start_date). What NF is this?",
      "options": ["1NF", "2NF", "3NF", "Beyond 3NF"],
      "correct": 2,
      "explanation": "3NF: all attributes depend on their table's PK. No partial dependencies (EmployeeDept's composite PK determines start_date fully). No transitive dependencies. Clean schema.",
      "detailedExplanation": "Use \"schema has: Employee(id, name), Department(id, name), EmployeeDept(employee_id,\" as your starting point, then verify tradeoffs carefully. Reject options that conflict with the primary access pattern or index strategy. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-092",
      "type": "two-stage",
      "stages": [
        {
          "question": "A legacy table has 80 columns mixing Order, Customer, Product, and Shipping data. First step to normalize?",
          "options": [
            "Identify the distinct entities (Order, Customer, Product, Shipping)",
            "Add indexes",
            "Split into random groups of columns",
            "Add a surrogate PK"
          ],
          "correct": 0,
          "explanation": "First: identify entities and their natural boundaries. Group columns by what entity they describe. Then create tables for each entity with proper PKs and FKs.",
          "detailedExplanation": "The core signal here is \"legacy table has 80 columns mixing Order, Customer, Product, and Shipping data\". Solve this as chained reasoning where stage two must respect stage one assumptions. Schema and index choices should follow access patterns and write/read amplification constraints. If values like 80 appear, convert them into one unit basis before comparison. Common pitfall: unbounded cardinality in joins or fan-out."
        },
        {
          "question": "After splitting into 4 entity tables, what should you verify?",
          "options": [
            "That queries are faster",
            "That joins reconstruct the original data losslessly",
            "That the table count is minimal",
            "That column names are consistent"
          ],
          "correct": 1,
          "explanation": "Verify lossless decomposition: joining the new tables must produce exactly the original data. No rows lost, no spurious rows added. This ensures the normalization is correct.",
          "detailedExplanation": "Use \"after splitting into 4 entity tables, what should you verify\" as your starting point, then verify tradeoffs carefully. Solve this as chained reasoning where stage two must respect stage one assumptions. Schema and index choices should follow access patterns and write/read amplification constraints. If values like 4 appear, convert them into one unit basis before comparison. Common pitfall: indexing that over-amplifies writes."
        }
      ],
      "detailedExplanation": "The core signal here is \"normalization\". Solve this as chained reasoning where stage two must respect stage one assumptions. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-093",
      "type": "numeric-input",
      "question": "A table has columns: sale_id (PK), product_id, product_name, product_category, category_manager, customer_id, customer_name, customer_city. How many functional dependency chains violate 3NF?",
      "answer": 3,
      "tolerance": "exact",
      "explanation": "Three chains: (1) product_id → product_name, (2) product_id → product_category → category_manager, (3) customer_id → customer_name, customer_city. All are transitive through non-key columns.",
      "detailedExplanation": "If you keep \"table has columns: sale_id (PK), product_id, product_name, product_category,\" in view, the correct answer separates faster. Keep every transformation in one unit system and check order of magnitude at the end. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Keep quantities like 1 and 2 in aligned units before selecting an answer. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-094",
      "type": "multi-select",
      "question": "What tools help identify normalization issues in existing databases?",
      "options": [
        "ER diagram analysis (visualize dependencies)",
        "Duplicate data queries (find repeated values)",
        "Application code review (look for multi-row updates of the same fact)",
        "EXPLAIN ANALYZE (query performance)"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "ER diagrams show structural issues. Duplicate queries find redundancy. Code review reveals update anomalies. EXPLAIN shows performance but not normalization issues.",
      "detailedExplanation": "Start from \"tools help identify normalization issues in existing databases\", then pressure-test the result against the options. Validate each option independently; do not select statements that are only partially true. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-095",
      "type": "multiple-choice",
      "question": "What is 5NF (Fifth Normal Form)?",
      "options": [
        "The most normalized possible",
        "In 4NF AND every join dependency is implied by candidate keys",
        "A table with 5 columns",
        "Unused in practice"
      ],
      "correct": 1,
      "explanation": "5NF (Project-Join Normal Form): every join dependency is implied by candidate keys. Extremely rare to encounter in practice. Most schemas don't need to go beyond 3NF or BCNF.",
      "detailedExplanation": "The key clue in this question is \"5NF (Fifth Normal Form)\". Prefer the schema/index decision that minimizes query and write amplification for this workload. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-096",
      "type": "ordering",
      "question": "Rank these normalization levels by practical usage frequency (MOST to LEAST used in real systems):",
      "items": ["3NF", "1NF", "BCNF", "5NF"],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "3NF is the most common design target. 1NF is a given (even denormalized tables usually have atomic values). BCNF is occasionally needed. 5NF is almost never used.",
      "detailedExplanation": "Read this as a scenario about \"rank these normalization levels by practical usage frequency (MOST to LEAST used in\". Build the rank from biggest differences first, then refine with adjacent checks. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-097",
      "type": "two-stage",
      "stages": [
        {
          "question": "You inherit a database where 30% of queries touch a denormalized 'user_dashboard_data' table. Should you normalize it?",
          "options": [
            "Yes — always normalize",
            "No — it's a materialized view pattern for read performance",
            "Maybe — check if update anomalies are causing bugs",
            "Delete the table"
          ],
          "correct": 2,
          "explanation": "Check if the denormalization causes real problems (stale data, bugs, update failures). If it's working correctly as a read optimization, it might be fine as-is.",
          "detailedExplanation": "Use \"you inherit a database where 30% of queries touch a denormalized 'user_dashboard_data'\" as your starting point, then verify tradeoffs carefully. Do not reset assumptions between stages; carry forward prior constraints directly. Cache design quality is mostly about correctness boundaries, not only hit rate. Numbers such as 30 should be normalized first so downstream reasoning stays consistent. Common pitfall: hot-key skew causing uneven load."
        },
        {
          "question": "Investigation shows the table gets out of sync weekly, requiring manual fixes. What should you do?",
          "options": [
            "Normalize the data and use JOINs",
            "Normalize but add a materialized view with automatic refresh",
            "Fix the sync logic",
            "Both B and C are valid"
          ],
          "correct": 1,
          "explanation": "Best of both: normalize the source of truth (3NF tables), then create a materialized view for the dashboard. Automatic refresh keeps it in sync without manual intervention.",
          "detailedExplanation": "The core signal here is \"investigation shows the table gets out of sync weekly, requiring manual fixes\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: indexing that over-amplifies writes."
        }
      ],
      "detailedExplanation": "The decision turns on \"normalization\". Do not reset assumptions between stages; carry forward prior constraints directly. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-098",
      "type": "multi-select",
      "question": "Which correctly describe materialized views in relation to normalization?",
      "options": [
        "They're precomputed denormalized query results",
        "They keep the source schema normalized",
        "They need refresh strategies (manual, periodic, or on change)",
        "They replace the need for normalization"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "Materialized views store denormalized results of queries on normalized tables. Source tables stay normalized. Views need refresh. They complement normalization, don't replace it.",
      "detailedExplanation": "This prompt is really about \"correctly describe materialized views in relation to normalization\". Treat every option as a separate true/false test under the same constraints. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-099",
      "type": "multiple-choice",
      "question": "Which mnemonic summarizes the dependencies checked by 1NF, 2NF, and 3NF?",
      "options": [
        "'The key, the whole key, and nothing but the key, so help me Codd'",
        "'First tables, then keys, then constraints'",
        "'Normalize, optimize, denormalize'",
        "'One table, one purpose'"
      ],
      "correct": 0,
      "explanation": "The famous mnemonic: 'The key (1NF—data has a key), the whole key (2NF—no partial deps), and nothing but the key (3NF—no transitive deps), so help me Codd.'",
      "detailedExplanation": "Use \"mnemonic summarizes the dependencies checked by 1NF, 2NF, and 3NF\" as your starting point, then verify tradeoffs carefully. Reject options that conflict with the primary access pattern or index strategy. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "norm-100",
      "type": "multiple-choice",
      "question": "What is the single most important practical takeaway about normalization?",
      "options": [
        "Always normalize to the highest possible level",
        "Every fact should be stored in exactly one place — duplication creates anomalies",
        "Normalization is only for SQL databases",
        "JOINs are bad and should be avoided"
      ],
      "correct": 1,
      "explanation": "The core principle: each fact stored once. When a fact is duplicated, changes must touch every copy—miss one and data is inconsistent. This drives all normalization rules.",
      "detailedExplanation": "The core signal here is \"the single most important practical takeaway about normalization\". Reject options that conflict with the primary access pattern or index strategy. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    }
  ]
}
