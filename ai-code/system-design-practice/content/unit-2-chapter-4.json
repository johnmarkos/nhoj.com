{
  "unit": 2,
  "unitTitle": "Data Modeling",
  "chapter": 4,
  "chapterTitle": "Normalization",
  "chapterDescription": "1NF, 2NF, 3NF in plain English — why it matters and how to get there.",
  "problems": [
    {
      "id": "norm-001",
      "type": "multiple-choice",
      "question": "What is the main goal of database normalization?",
      "options": ["Faster queries", "Eliminate data redundancy and update anomalies", "Reduce the number of tables", "Make the schema easier to read"],
      "correct": 1,
      "explanation": "Normalization reduces redundancy (same data stored in multiple places) and prevents anomalies (inserting, updating, or deleting data causing inconsistencies)."
    },
    {
      "id": "norm-002",
      "type": "multiple-choice",
      "question": "What is First Normal Form (1NF)?",
      "options": ["Each table has a primary key", "Each column contains atomic (indivisible) values — no lists, no repeating groups", "All columns depend on the primary key", "No transitive dependencies"],
      "correct": 1,
      "explanation": "1NF: every column holds a single, atomic value. No comma-separated lists, no repeating groups (phone1, phone2, phone3). Each row-column intersection has one value."
    },
    {
      "id": "norm-003",
      "type": "multi-select",
      "question": "Which tables violate 1NF?",
      "options": ["User(id, name, 'skills: java,python,go')", "Order(id, product_id, quantity)", "Contact(id, phone1, phone2, phone3)", "Post(id, title, body)"],
      "correctIndices": [0, 2],
      "explanation": "Comma-separated skills and repeating phone columns violate 1NF. Order and Post have atomic, single-value columns."
    },
    {
      "id": "norm-004",
      "type": "multiple-choice",
      "question": "How do you fix: User(id, name, skills) where skills = 'java,python,go'?",
      "options": ["Use a TEXT column", "Create a UserSkill table (user_id, skill)", "Add skill1, skill2, skill3 columns", "Use JSON instead of CSV"],
      "correct": 1,
      "explanation": "Create a separate UserSkill table. Each skill gets its own row: (user_id=1, skill='java'), (user_id=1, skill='python'). This satisfies 1NF."
    },
    {
      "id": "norm-005",
      "type": "ordering",
      "question": "Rank these normal forms from LOWEST to HIGHEST (least to most normalized):",
      "items": ["1NF", "2NF", "3NF", "BCNF"],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Each form builds on the previous. 1NF (atomic values) → 2NF (no partial dependencies) → 3NF (no transitive dependencies) → BCNF (every determinant is a key)."
    },
    {
      "id": "norm-006",
      "type": "multiple-choice",
      "question": "What is Second Normal Form (2NF)?",
      "options": ["No repeating groups", "In 1NF AND every non-key column depends on the ENTIRE primary key (no partial dependencies)", "No transitive dependencies", "All columns are indexed"],
      "correct": 1,
      "explanation": "2NF: must be in 1NF, and every non-key attribute depends on the whole PK, not just part of it. Only relevant for composite primary keys."
    },
    {
      "id": "norm-007",
      "type": "two-stage",
      "stages": [
        {
          "question": "Table: OrderItem(order_id, product_id, quantity, product_name). PK is (order_id, product_id). Is this in 2NF?",
          "options": ["Yes", "No — product_name depends only on product_id, not the full PK"],
          "correct": 1,
          "explanation": "product_name depends only on product_id (part of the PK), not on the full composite key (order_id, product_id). This is a partial dependency, violating 2NF."
        },
        {
          "question": "How do you fix this?",
          "options": ["Remove product_name", "Move product_name to a Product table", "Add a surrogate PK", "Make product_name part of the PK"],
          "correct": 1,
          "explanation": "Move product_name to Product(product_id, product_name). OrderItem keeps (order_id, product_id, quantity). Now every non-key column depends on the full PK."
        }
      ]
    },
    {
      "id": "norm-008",
      "type": "multiple-choice",
      "question": "Can a table with a single-column PK violate 2NF?",
      "options": ["Yes, any table can violate 2NF", "No — 2NF partial dependency only applies to composite PKs", "Only if it has foreign keys", "Only in MySQL"],
      "correct": 1,
      "explanation": "Partial dependency means a non-key column depends on PART of the PK. With a single-column PK, there's no 'part'—the whole PK is one column. 2NF is automatically satisfied."
    },
    {
      "id": "norm-009",
      "type": "multiple-choice",
      "question": "What is Third Normal Form (3NF)?",
      "options": ["No repeating groups", "No partial dependencies", "In 2NF AND no transitive dependencies (non-key columns don't depend on other non-key columns)", "All data is in one table"],
      "correct": 2,
      "explanation": "3NF: in 2NF, and no non-key column depends on another non-key column. Every non-key attribute depends directly on the primary key, not transitively through another column."
    },
    {
      "id": "norm-010",
      "type": "two-stage",
      "stages": [
        {
          "question": "Employee(id, name, department_id, department_name). Is this in 3NF?",
          "options": ["Yes", "No — department_name depends on department_id, not directly on employee id"],
          "correct": 1,
          "explanation": "department_name depends on department_id (a non-key column), not directly on the PK (employee id). This is a transitive dependency: id → department_id → department_name."
        },
        {
          "question": "How do you fix this?",
          "options": ["Remove department_id", "Move department_name to a Department table", "Make department_name part of the PK", "Remove department_name and store only department_id"],
          "correct": 1,
          "explanation": "Create Department(department_id, department_name). Employee keeps (id, name, department_id). department_name is now stored once, in the Department table."
        }
      ]
    },
    {
      "id": "norm-011",
      "type": "multi-select",
      "question": "Which are update anomalies that normalization prevents?",
      "options": ["Insertion anomaly (can't add data without unrelated data)", "Deletion anomaly (deleting a row loses unrelated data)", "Update anomaly (changing one fact requires updating many rows)", "Query anomaly (queries return wrong results)"],
      "correctIndices": [0, 1, 2],
      "explanation": "Normalization prevents insertion, deletion, and update anomalies. Query anomaly isn't a standard term—queries return correct results based on the data they have."
    },
    {
      "id": "norm-012",
      "type": "multiple-choice",
      "question": "Table: Student(id, name, advisor_name, advisor_office). If an advisor changes offices, how many rows must be updated?",
      "options": ["1", "One per student with that advisor", "All rows", "None — it's a new row"],
      "correct": 1,
      "explanation": "Every student row with that advisor has the office duplicated. You must update ALL of them. If you miss one, the data is inconsistent. This is an update anomaly."
    },
    {
      "id": "norm-013",
      "type": "numeric-input",
      "question": "A denormalized orders table stores customer_name on each order. A customer has 500 orders. They change their name. How many rows need updating?",
      "answer": 500,
      "tolerance": "exact",
      "explanation": "All 500 order rows have customer_name duplicated. Each must be updated. With normalization (customer_name in Customers table), you update exactly 1 row."
    },
    {
      "id": "norm-014",
      "type": "ordering",
      "question": "Rank these schemas by normalization level (LEAST to MOST normalized):",
      "items": ["Order(id, customer_name, customer_email, product, qty)", "Order(id, customer_id, product_id, qty) with Customer and Product tables", "Order(id, customer_id, product_id, qty) + OrderHistory + AuditLog"],
      "correctOrder": [0, 1, 2],
      "explanation": "First: everything in one table (denormalized). Second: proper FK references (3NF). Third: further normalized with historical tracking."
    },
    {
      "id": "norm-015",
      "type": "multiple-choice",
      "question": "What's an insertion anomaly?",
      "options": ["INSERT is slow", "You can't insert data about one entity without providing data about another", "Inserting duplicates", "INSERT fails silently"],
      "correct": 1,
      "explanation": "Example: if Department info is only in Employee table, you can't record a new department until it has employees. The department data depends on employee data existing."
    },
    {
      "id": "norm-016",
      "type": "multi-select",
      "question": "Table: CourseEnrollment(student_id, course_id, student_name, course_name, grade). PK: (student_id, course_id). Which violate 2NF?",
      "options": ["student_name (depends only on student_id)", "course_name (depends only on course_id)", "grade (depends on both student_id and course_id)", "All non-key columns"],
      "correctIndices": [0, 1],
      "explanation": "student_name depends on student_id alone (partial dependency). course_name depends on course_id alone. grade depends on both—the full PK—so it's fine."
    },
    {
      "id": "norm-017",
      "type": "multiple-choice",
      "question": "What's a transitive dependency?",
      "options": ["A → B → C, where A is the PK, B is non-key, and C depends on B", "A → B and B → A", "All columns depend on the PK", "Dependencies between tables"],
      "correct": 0,
      "explanation": "Transitive dependency: A (PK) → B (non-key) → C (non-key). C depends on A only through B. Example: employee_id → department_id → department_name."
    },
    {
      "id": "norm-018",
      "type": "two-stage",
      "stages": [
        {
          "question": "Book(isbn, title, author_id, author_name, author_country). What's the transitive dependency?",
          "options": ["isbn → title", "isbn → author_id → author_name, author_country", "author_name → author_country", "No transitive dependency"],
          "correct": 1,
          "explanation": "isbn → author_id (direct), then author_id → author_name, author_country (transitive). author_name and author_country depend on isbn only through author_id."
        },
        {
          "question": "What's the 3NF fix?",
          "options": ["Remove author columns from Book", "Move author_name and author_country to an Author table", "Make author_id part of the PK", "Add a trigger to sync data"],
          "correct": 1,
          "explanation": "Create Author(author_id, author_name, author_country). Book keeps (isbn, title, author_id). No transitive dependency remains."
        }
      ]
    },
    {
      "id": "norm-019",
      "type": "multiple-choice",
      "question": "What is BCNF (Boyce-Codd Normal Form)?",
      "options": ["Same as 3NF", "3NF plus: every determinant must be a candidate key", "4NF without multi-valued dependencies", "The maximum normalization level"],
      "correct": 1,
      "explanation": "BCNF: for every functional dependency X → Y, X must be a superkey. It's slightly stricter than 3NF—handles edge cases where a non-key column determines part of a composite key."
    },
    {
      "id": "norm-020",
      "type": "ordering",
      "question": "Rank these by number of joins typically needed to retrieve a full record (FEWEST to MOST):",
      "items": ["Single denormalized table", "2NF (some partial dependencies removed)", "3NF (fully normalized)", "BCNF with junction tables"],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "More normalization = more tables = more joins. Denormalized: 0 joins. 2NF: some. 3NF: more. BCNF with junctions: most joins."
    },
    {
      "id": "norm-021",
      "type": "multi-select",
      "question": "Which problems does storing customer_name directly on Order cause?",
      "options": ["Update anomaly: name change requires updating all orders", "Storage waste: name duplicated per order", "Deletion anomaly: deleting all orders loses the customer", "Stale data: old orders show old names (could be desired or not)"],
      "correctIndices": [0, 1, 2, 3],
      "explanation": "All four are real issues. Note: stale data is sometimes intentional (you WANT old orders to show the name at time of purchase)."
    },
    {
      "id": "norm-022",
      "type": "multiple-choice",
      "question": "When is 'stale' denormalized data actually desirable?",
      "options": ["Never—always normalize", "When you need historical accuracy (e.g., order should show the address it shipped to)", "When queries are slow", "When using NoSQL"],
      "correct": 1,
      "explanation": "Orders should record the shipping address at time of purchase, not a reference that changes when the user updates their address. This is intentional denormalization for historical accuracy."
    },
    {
      "id": "norm-023",
      "type": "numeric-input",
      "question": "A non-normalized table has: Order(id, product_name, product_price, category_name, customer_name, customer_email). How many entities should be extracted to reach 3NF?",
      "answer": 3,
      "tolerance": "exact",
      "explanation": "Three entities to extract: Product (name, price, category), Category (name), Customer (name, email). Plus Order references them by FK."
    },
    {
      "id": "norm-024",
      "type": "two-stage",
      "stages": [
        {
          "question": "Table: Employee(id, name, skill1, skill2, skill3). What normal form does this violate?",
          "options": ["1NF — repeating groups", "2NF — partial dependency", "3NF — transitive dependency", "It's normalized"],
          "correct": 0,
          "explanation": "skill1, skill2, skill3 are repeating groups—the same type of data in multiple columns. This violates 1NF."
        },
        {
          "question": "How do you normalize it?",
          "options": ["Combine into one skill column", "Create EmployeeSkill(employee_id, skill) table", "Use a JSON array", "Add more skill columns"],
          "correct": 1,
          "explanation": "EmployeeSkill table with (employee_id, skill). Each skill is a separate row. Handles any number of skills without schema changes."
        }
      ]
    },
    {
      "id": "norm-025",
      "type": "multi-select",
      "question": "Which violate 1NF?",
      "options": ["Column storing JSON array of tags", "Column storing a single integer", "Column storing 'New York, NY' (city and state in one field)", "Column storing a boolean"],
      "correctIndices": [0, 2],
      "explanation": "JSON array has multiple values in one field. City+state is two facts in one column. Single integer and boolean are atomic values—1NF compliant."
    },
    {
      "id": "norm-026",
      "type": "multiple-choice",
      "question": "What's a functional dependency?",
      "options": ["A function in the application code", "If you know column A, you can determine column B: written A → B", "A foreign key relationship", "A stored procedure"],
      "correct": 1,
      "explanation": "A → B means knowing A uniquely determines B. Example: student_id → student_name. If you know the student_id, the name is determined. This is the foundation of normalization."
    },
    {
      "id": "norm-027",
      "type": "ordering",
      "question": "Rank these issues by how directly normalization addresses them (MOST to LEAST directly):",
      "items": ["Data redundancy", "Update anomalies", "Query performance", "Storage cost"],
      "correctOrder": [0, 1, 3, 2],
      "explanation": "Normalization directly targets redundancy and anomalies. Storage reduction is a byproduct. Query performance can actually decrease (more joins)—normalization doesn't optimize for reads."
    },
    {
      "id": "norm-028",
      "type": "multiple-choice",
      "question": "A table has PK(student_id), and columns: name, advisor_id, advisor_email. What's the highest normal form?",
      "options": ["1NF", "2NF", "3NF", "Not even 1NF"],
      "correct": 1,
      "explanation": "It's in 2NF (single-column PK, so no partial dependencies possible). But advisor_email depends on advisor_id (a non-key column), creating a transitive dependency. Not 3NF."
    },
    {
      "id": "norm-029",
      "type": "multi-select",
      "question": "Which are examples of the deletion anomaly?",
      "options": ["Deleting the last student of an advisor loses the advisor's info", "Deleting all orders of a product loses the product info (if only stored on orders)", "Deleting a user removes their profile", "Deleting an order removes its line items (CASCADE)"],
      "correctIndices": [0, 1],
      "explanation": "Deletion anomaly: losing Entity A's data when deleting Entity B. User→profile and order→items are intentional cascades, not anomalies."
    },
    {
      "id": "norm-030",
      "type": "two-stage",
      "stages": [
        {
          "question": "Invoice(id, customer_id, customer_name, customer_address, total). Is customer_name a transitive dependency?",
          "options": ["No — it depends directly on the PK", "Yes — id → customer_id → customer_name"],
          "correct": 1,
          "explanation": "customer_name depends on customer_id, which depends on id. That's transitive: id → customer_id → customer_name. Violates 3NF."
        },
        {
          "question": "But for invoices, you WANT to preserve the customer name at time of invoicing. How do you handle this?",
          "options": ["Accept the 3NF violation as intentional", "Normalize AND add a snapshot column: billing_name", "Always join to get the current name", "Store a versioned customer history"],
          "correct": 1,
          "explanation": "Normalize customer data (FK to Customer) AND add billing_name/billing_address on Invoice for point-in-time record. Both current data and historical snapshot."
        }
      ]
    },
    {
      "id": "norm-031",
      "type": "multiple-choice",
      "question": "A column stores: '2024-01-15 10:30 America/New_York'. Is this 1NF compliant?",
      "options": ["Yes — it's a single value", "No — it combines date, time, and timezone", "Depends on the data type", "Only if stored as TIMESTAMPTZ"],
      "correct": 2,
      "explanation": "If stored as TIMESTAMPTZ (one atomic data type that inherently includes timezone), it's 1NF. If stored as a string combining separate concepts, arguable violation."
    },
    {
      "id": "norm-032",
      "type": "numeric-input",
      "question": "Table: Sale(id, product, category, customer, city, state, zip). How many transitive dependencies exist?",
      "answer": 2,
      "tolerance": "exact",
      "explanation": "Two: (1) product → category (category depends on product, not sale id). (2) zip → city, state (city/state determined by zip code). Both are transitive through non-key columns."
    },
    {
      "id": "norm-033",
      "type": "multi-select",
      "question": "Which are benefits of 3NF?",
      "options": ["Single source of truth for each fact", "Simpler updates (change data in one place)", "Fewer tables", "Structural integrity — schema prevents inconsistencies"],
      "correctIndices": [0, 1, 3],
      "explanation": "3NF means each fact is stored once (single source), updates touch one row, and the schema structure prevents inconsistencies. But 3NF typically means MORE tables, not fewer."
    },
    {
      "id": "norm-034",
      "type": "multiple-choice",
      "question": "Table: StudentCourse(student_id, course_id, course_dept, grade). PK: (student_id, course_id). Which column violates 2NF?",
      "options": ["grade", "course_dept", "student_id", "None — it's in 2NF"],
      "correct": 1,
      "explanation": "course_dept depends only on course_id (part of the PK), not on the full composite key. This is a partial dependency, violating 2NF. grade depends on both—it's fine."
    },
    {
      "id": "norm-035",
      "type": "ordering",
      "question": "To normalize this table, rank the steps (FIRST to LAST): Table has repeating groups, partial dependencies, and transitive dependencies.",
      "items": ["Remove repeating groups (reach 1NF)", "Remove partial dependencies (reach 2NF)", "Remove transitive dependencies (reach 3NF)"],
      "correctOrder": [0, 1, 2],
      "explanation": "Normalize in order: 1NF first (atomic values), then 2NF (eliminate partial deps), then 3NF (eliminate transitive deps). Each form builds on the previous."
    },
    {
      "id": "norm-036",
      "type": "two-stage",
      "stages": [
        {
          "question": "OrderDetail(order_id, product_id, product_name, product_category, qty, price). PK: (order_id, product_id). What violates 2NF?",
          "options": ["qty and price", "product_name and product_category", "order_id", "Nothing"],
          "correct": 1,
          "explanation": "product_name and product_category depend only on product_id—partial dependency on the composite PK."
        },
        {
          "question": "After moving product_name and product_category to a Product table, is OrderDetail now in 3NF?",
          "options": ["Yes — OrderDetail(order_id, product_id, qty, price) has no transitive deps", "No — price depends on product_id", "No — qty depends on order_id", "Depends on whether price is per-order or per-product"],
          "correct": 3,
          "explanation": "If price is the price at time of purchase (per order-product), it depends on the full PK—3NF. If it's always the product's current price, it depends on product_id—extract it."
        }
      ]
    },
    {
      "id": "norm-037",
      "type": "multiple-choice",
      "question": "Which normal form eliminates multi-valued dependencies?",
      "options": ["2NF", "3NF", "BCNF", "4NF"],
      "correct": 3,
      "explanation": "4NF eliminates multi-valued dependencies (where two independent multi-valued facts about an entity are stored in the same table). Most practical schemas stop at 3NF or BCNF."
    },
    {
      "id": "norm-038",
      "type": "multi-select",
      "question": "Which schemas are in 3NF?",
      "options": ["User(id, name, email)", "User(id, name, dept_id, dept_name)", "Order(id, customer_id, total)", "Order(id, customer_id, customer_name, total)"],
      "correctIndices": [0, 2],
      "explanation": "User(id, name, email): no transitive deps. Order(id, customer_id, total): no transitive deps. The others have non-key columns depending on other non-key columns."
    },
    {
      "id": "norm-039",
      "type": "multiple-choice",
      "question": "What does 'every non-key attribute must depend on the key, the whole key, and nothing but the key' describe?",
      "options": ["1NF", "2NF", "3NF", "It summarizes all three: 1NF + 2NF + 3NF"],
      "correct": 3,
      "explanation": "'The key' = 1NF (data has a key). 'The whole key' = 2NF (no partial deps). 'Nothing but the key' = 3NF (no transitive deps). This mnemonic covers all three normal forms."
    },
    {
      "id": "norm-040",
      "type": "ordering",
      "question": "Rank by severity of normalization violation (MOST to LEAST severe):",
      "items": ["Repeating groups (violates 1NF)", "Partial dependency (violates 2NF)", "Transitive dependency (violates 3NF)"],
      "correctOrder": [0, 1, 2],
      "explanation": "1NF violations are most severe—data can't even be properly queried. Partial deps (2NF) cause widespread redundancy. Transitive deps (3NF) are the mildest—often intentionally tolerated."
    },
    {
      "id": "norm-041",
      "type": "numeric-input",
      "question": "An unnormalized table: Employee(id, name, phone_numbers, dept_id, dept_name, dept_head). How many normalization steps to reach 3NF? (Count: fix 1NF, fix 2NF, fix 3NF as separate steps)",
      "answer": 2,
      "tolerance": "exact",
      "explanation": "Step 1: Fix 1NF — extract phone_numbers to EmployeePhone table. Step 2: Fix 3NF — extract dept_name and dept_head to Department table. (2NF isn't violated with a single-column PK.) Two steps."
    },
    {
      "id": "norm-042",
      "type": "two-stage",
      "stages": [
        {
          "question": "Table: Booking(id, guest_name, room_number, room_type, room_rate, check_in, check_out). What's wrong?",
          "options": ["Nothing", "room_type and room_rate depend on room_number, not booking id (transitive)", "guest_name should be in a Guest table", "Both B and C"],
          "correct": 3,
          "explanation": "Two issues: room_type/room_rate depend on room_number (transitive dep), and guest_name should reference a Guest entity."
        },
        {
          "question": "After normalizing, how many tables?",
          "options": ["2 (Booking + Room)", "3 (Booking + Room + Guest)", "4 (Booking + Room + Guest + RoomType)", "1 (just fix columns)"],
          "correct": 1,
          "explanation": "Three: Guest(id, name), Room(number, type, rate), Booking(id, guest_id, room_number, check_in, check_out). RoomType could be separate but rate may vary per room."
        }
      ]
    },
    {
      "id": "norm-043",
      "type": "multi-select",
      "question": "Which indicate a table is NOT in 1NF?",
      "options": ["A column stores a JSON array", "A column stores a comma-separated list", "The table has columns like tag1, tag2, tag3", "A column stores a single foreign key"],
      "correctIndices": [0, 1, 2],
      "explanation": "JSON arrays, CSV lists, and repeating numbered columns all store multiple values where 1NF requires one atomic value per cell."
    },
    {
      "id": "norm-044",
      "type": "multiple-choice",
      "question": "In practice, how normalized should most OLTP systems be?",
      "options": ["Always 5NF for maximum correctness", "3NF is the standard target for most OLTP systems", "1NF is sufficient for modern databases", "Normalization is obsolete with NoSQL"],
      "correct": 1,
      "explanation": "3NF is the standard target for transactional systems. It eliminates most redundancy while remaining practical. Higher forms (BCNF, 4NF, 5NF) are rarely needed."
    },
    {
      "id": "norm-045",
      "type": "multiple-choice",
      "question": "What's the difference between 3NF and BCNF?",
      "options": ["They're identical", "BCNF is stricter: in 3NF, a non-key can determine another non-key if it's also a candidate key; BCNF doesn't allow this", "BCNF allows transitive dependencies", "BCNF requires 4NF"],
      "correct": 1,
      "explanation": "In 3NF, a dependency A → B is allowed if A is a candidate key. BCNF requires A to be a superkey for ANY dependency—slightly stricter. The difference rarely matters in practice."
    },
    {
      "id": "norm-046",
      "type": "ordering",
      "question": "Rank these considerations when deciding normalization level (MOST to LEAST important for OLTP):",
      "items": ["Data integrity (no anomalies)", "Write performance (fewer updates)", "Read performance (fewer joins)", "Storage efficiency"],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "For OLTP: integrity is paramount, then write efficiency (normalized = fewer updates). Read performance can be improved with indexes/caching. Storage is cheap."
    },
    {
      "id": "norm-047",
      "type": "multi-select",
      "question": "Which are signs that a table needs further normalization?",
      "options": ["Same value appears in many rows (e.g., department_name repeated)", "Updating one fact requires changing many rows", "You can't add an entity without adding unrelated data", "The table has more than 10 columns"],
      "correctIndices": [0, 1, 2],
      "explanation": "Repeated values, multi-row updates for one fact, and insertion anomalies all signal normalization issues. Column count alone doesn't indicate normalization problems."
    },
    {
      "id": "norm-048",
      "type": "two-stage",
      "stages": [
        {
          "question": "Table: Course(course_id, title, instructor_id, instructor_name, instructor_dept). What normal form is this?",
          "options": ["1NF", "2NF", "3NF", "Not even 1NF"],
          "correct": 1,
          "explanation": "It's in 2NF (single-column PK, no partial deps). But instructor_name and instructor_dept depend on instructor_id (transitive). Not 3NF."
        },
        {
          "question": "Is there a scenario where keeping instructor_name on Course is acceptable?",
          "options": ["No — always normalize", "Yes — if the instructor's name at time of teaching matters for historical records", "Only in NoSQL", "Only for read performance"],
          "correct": 1,
          "explanation": "If you need to record 'who taught this course that semester' and names change (marriage, legal change), a snapshot is valid. But model it explicitly (e.g., instructor_name_at_time)."
        }
      ]
    },
    {
      "id": "norm-049",
      "type": "multiple-choice",
      "question": "What is a determinant?",
      "options": ["The primary key", "Any column (or set of columns) that functionally determines another column", "A column with a UNIQUE constraint", "A foreign key"],
      "correct": 1,
      "explanation": "A determinant is the left side of a functional dependency (X → Y). X determines Y. The PK is always a determinant, but other columns can be too (e.g., email → user_id if email is unique)."
    },
    {
      "id": "norm-050",
      "type": "multi-select",
      "question": "In Employee(id, email, dept_id, dept_name), which are determinants?",
      "options": ["id (determines all other columns)", "email (determines id, name if unique)", "dept_id (determines dept_name)", "dept_name (determines dept_id if unique)"],
      "correctIndices": [0, 1, 2, 3],
      "explanation": "All can be determinants if they uniquely determine other values. id determines everything. email might too if unique. dept_id ↔ dept_name if each is unique."
    },
    {
      "id": "norm-051",
      "type": "multiple-choice",
      "question": "A table stores: Order(id, customer_id, shipping_street, shipping_city, shipping_state, shipping_zip). Is it in 3NF?",
      "options": ["Yes — all columns depend on the PK", "No — zip → city, state is a transitive dependency", "No — shipping address should be its own entity", "Both B and C"],
      "correct": 1,
      "explanation": "zip → city and zip → state are transitive dependencies (id → zip → city/state). To reach 3NF, extract to ZipCode(zip, city, state). In practice, this level of normalization is often skipped."
    },
    {
      "id": "norm-052",
      "type": "ordering",
      "question": "Rank these real-world normalization trade-offs by how commonly they're made (MOST to LEAST common):",
      "items": ["Store address fields directly (skip zip→city normalization)", "Store customer_name on Order for historical record", "Store product_name on OrderItem for point-in-time pricing", "Fully normalize everything to 5NF"],
      "correctOrder": [0, 2, 1, 3],
      "explanation": "Address denormalization is ubiquitous. Point-in-time pricing is very common. Historical name on orders is common. Full 5NF normalization is extremely rare in practice."
    },
    {
      "id": "norm-053",
      "type": "multiple-choice",
      "question": "What's the relationship between normalization and JOIN count?",
      "options": ["Normalization reduces JOINs", "Higher normalization increases JOINs needed to reconstruct full records", "No relationship", "Normalization eliminates JOINs"],
      "correct": 1,
      "explanation": "Each extracted table adds a potential JOIN. A denormalized table with all data needs zero JOINs. A 3NF schema with separate Customer, Product, and Category needs JOINs to combine them."
    },
    {
      "id": "norm-054",
      "type": "numeric-input",
      "question": "A fully denormalized Order row has 20 columns (order + customer + product data). After normalizing to 3NF with Order, Customer, Product, and Category tables, how many JOINs to reconstruct the full row?",
      "answer": 3,
      "tolerance": "exact",
      "explanation": "Three JOINs: Order JOIN Customer, JOIN Product, JOIN Category (assuming Product references Category). Each extracted entity adds one JOIN."
    },
    {
      "id": "norm-055",
      "type": "two-stage",
      "stages": [
        {
          "question": "Table: Product(id, name, category_id, category_name, supplier_id, supplier_name, supplier_country). How many 3NF violations?",
          "options": ["0", "1", "2", "3"],
          "correct": 2,
          "explanation": "Two transitive dependencies: (1) category_id → category_name, (2) supplier_id → supplier_name, supplier_country."
        },
        {
          "question": "After normalizing, how many tables?",
          "options": ["2", "3", "4"],
          "correct": 1,
          "explanation": "Three: Product(id, name, category_id, supplier_id), Category(id, name), Supplier(id, name, country)."
        }
      ]
    },
    {
      "id": "norm-056",
      "type": "multi-select",
      "question": "Which of these represent intentional (acceptable) denormalization?",
      "options": ["Storing shipping address on Order (point-in-time record)", "Caching user's post count on User table", "Storing product name on OrderItem for invoice history", "Storing department name on every Employee row"],
      "correctIndices": [0, 1, 2],
      "explanation": "First three are intentional: point-in-time data and cached aggregates. Department name on Employee is unintentional redundancy—it should reference a Department table."
    },
    {
      "id": "norm-057",
      "type": "multiple-choice",
      "question": "In the context of normalization, what is a 'prime attribute'?",
      "options": ["The most important column", "An attribute that is part of any candidate key", "The primary key column", "A column with a unique constraint"],
      "correct": 1,
      "explanation": "A prime attribute belongs to at least one candidate key. Non-prime attributes don't belong to any candidate key. 2NF and 3NF rules apply to non-prime attributes."
    },
    {
      "id": "norm-058",
      "type": "ordering",
      "question": "Rank these schema smells by likelihood of indicating a normalization problem (MOST to LEAST likely):",
      "items": ["Column storing comma-separated values", "Same column name appearing in multiple tables (e.g., customer_name in Orders AND Invoices)", "Table with 50+ columns mixing data from different entities", "Table with a single-column PK and 5 attributes"],
      "correctOrder": [0, 2, 1, 3],
      "explanation": "CSV values: definite 1NF violation. 50+ columns mixing entities: likely denormalized. Duplicate names across tables: possible redundancy. 5 attributes with PK: well-structured, no red flags."
    },
    {
      "id": "norm-059",
      "type": "multiple-choice",
      "question": "What's a lossless join decomposition?",
      "options": ["A join that doesn't lose performance", "Splitting a table into smaller tables such that joining them back produces exactly the original data", "Removing columns without losing data", "A join that doesn't require indexes"],
      "correct": 1,
      "explanation": "Lossless decomposition: when you split a table during normalization, joining the resulting tables must reproduce the original data exactly—no rows lost or added."
    },
    {
      "id": "norm-060",
      "type": "two-stage",
      "stages": [
        {
          "question": "A junior developer proposes: 'Let's put everything in one big table to avoid JOINs.' What's the strongest counterargument?",
          "options": ["JOINs are fast with proper indexes", "Update anomalies will cause data inconsistencies", "The table will be too wide", "Storage will be wasted"],
          "correct": 1,
          "explanation": "The strongest argument: denormalized data leads to inconsistencies. When the same fact is stored in 100 places, updating it requires changing 100 rows—miss one and data is wrong."
        },
        {
          "question": "The developer responds: 'We'll enforce consistency in application code.' What's wrong with that?",
          "options": ["Application code can have bugs; database constraints can't be bypassed", "Application code is slower", "Application code doesn't support transactions", "Nothing — application enforcement is fine"],
          "correct": 0,
          "explanation": "Application bugs, race conditions, direct DB access, scripts, and migrations can all bypass application logic. Database-level normalization + constraints are the last line of defense."
        }
      ]
    },
    {
      "id": "norm-061",
      "type": "multi-select",
      "question": "Which are true about normalization in NoSQL/document databases?",
      "options": ["NoSQL often intentionally denormalizes for read performance", "Embedding (denormalization) is a core document DB pattern", "Normalization principles still apply when data integrity matters", "NoSQL never uses normalization"],
      "correctIndices": [0, 1, 2],
      "explanation": "NoSQL often denormalizes by design (embedding documents). But normalization principles still matter—references between documents are normalization. It's a spectrum, not binary."
    },
    {
      "id": "norm-062",
      "type": "multiple-choice",
      "question": "Table: Employee(id, name, project_id, project_name, project_manager). What anomaly occurs if you delete the last employee on a project?",
      "options": ["Update anomaly", "Insertion anomaly", "Deletion anomaly — project info is lost", "No anomaly"],
      "correct": 2,
      "explanation": "Deleting the last employee on a project loses the project's name and manager data. The project info only exists as duplicated data on employee rows."
    },
    {
      "id": "norm-063",
      "type": "numeric-input",
      "question": "A company has 50 departments, each with an average of 200 employees. In a denormalized Employee table (with dept_name), how many rows store a redundant copy of dept_name?",
      "answer": 9950,
      "tolerance": 0.01,
      "explanation": "Each department has 200 employees, so dept_name appears 200 times per department. Only 1 copy per department is 'necessary' (the canonical one). Redundant copies: 50 × (200-1) = 9,950."
    },
    {
      "id": "norm-064",
      "type": "ordering",
      "question": "Rank these systems by how normalized they typically are (MOST to LEAST):",
      "items": ["Banking/financial OLTP", "E-commerce product catalog", "Analytics data warehouse", "Logging/event store"],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Banking: highly normalized for integrity. E-commerce: mostly normalized. Data warehouses: intentionally denormalized (star schema). Event stores: append-only, minimal normalization."
    },
    {
      "id": "norm-065",
      "type": "multi-select",
      "question": "Which are valid reasons to stop at 2NF instead of going to 3NF?",
      "options": ["Read performance is critical and joins are expensive", "The transitive dependency is intentional (point-in-time snapshot)", "The team doesn't understand 3NF", "The dependent data rarely changes"],
      "correctIndices": [0, 1, 3],
      "explanation": "Performance needs, intentional snapshots, and rarely-changing data can justify stopping at 2NF. 'Team doesn't understand' isn't a valid reason—educate the team."
    },
    {
      "id": "norm-066",
      "type": "two-stage",
      "stages": [
        {
          "question": "Table: Flight(flight_no, airline, airline_country, departure, arrival, plane_type, plane_capacity). How many entities should be extracted for 3NF?",
          "options": ["1 (Airline)", "2 (Airline, Plane)", "3 (Airline, Country, Plane)", "0 — it's already 3NF"],
          "correct": 1,
          "explanation": "Two: Airline(code, name, country) and PlaneType(type, capacity). Flight keeps FKs to both. airline_country depends on airline (transitive), plane_capacity on plane_type."
        },
        {
          "question": "Is airline_country a transitive dependency through airline?",
          "options": ["Yes — flight_no → airline → airline_country", "No — country is about the flight route", "It depends on context", "Only if airline is unique"],
          "correct": 0,
          "explanation": "airline_country depends on airline (the airline's home country), not on the flight. flight_no → airline → airline_country is a textbook transitive dependency."
        }
      ]
    },
    {
      "id": "norm-067",
      "type": "multiple-choice",
      "question": "What's the difference between OLTP and OLAP normalization approaches?",
      "options": ["OLTP prefers normalized schemas for integrity; OLAP prefers denormalized (star/snowflake) for query performance", "Both use 3NF", "OLTP is always denormalized", "OLAP doesn't use schemas"],
      "correct": 0,
      "explanation": "OLTP (transactions): normalized to prevent anomalies. OLAP (analytics): denormalized (star schema, dimension tables) for fast aggregation queries with fewer joins."
    },
    {
      "id": "norm-068",
      "type": "multi-select",
      "question": "What is a star schema (used in data warehouses)?",
      "options": ["A central fact table with foreign keys to dimension tables", "Dimension tables are denormalized (wide, flat)", "Optimized for aggregation queries", "Fully normalized to 3NF"],
      "correctIndices": [0, 1, 2],
      "explanation": "Star schema: fact table (sales, events) at center, surrounded by denormalized dimension tables (date, product, customer). Optimized for analytics, intentionally not normalized."
    },
    {
      "id": "norm-069",
      "type": "multiple-choice",
      "question": "A table has: Order(id, product_id, product_name). price is NOT stored. Is product_name a 3NF violation?",
      "options": ["Yes — product_name depends on product_id (transitive)", "No — product_name depends directly on the PK", "Only if there's a Product table", "Depends on whether product_id is a candidate key"],
      "correct": 0,
      "explanation": "product_name is determined by product_id, a non-key column. id → product_id → product_name is transitive. Whether a Product table exists yet doesn't change the dependency."
    },
    {
      "id": "norm-070",
      "type": "ordering",
      "question": "Rank these approaches to handling the zip→city dependency (MOST to LEAST practical):",
      "items": ["Accept it and store city/state/zip on the address", "Create a ZipCode lookup table", "Validate via API but store all three", "Only store zip and derive city/state from an external service"],
      "correctOrder": [0, 2, 1, 3],
      "explanation": "Most practical: just store all three (near-universal approach). API validation catches errors. ZipCode table works but adds maintenance. External derivation is fragile."
    },
    {
      "id": "norm-071",
      "type": "multiple-choice",
      "question": "What is a multi-valued dependency (relevant to 4NF)?",
      "options": ["A column with multiple possible values", "An entity has two or more independent multi-valued facts", "Multiple foreign keys", "A dependency between values in an array"],
      "correct": 1,
      "explanation": "Multi-valued dependency: an employee has multiple skills AND multiple languages, independently. Storing both in one table creates artificial combinations. 4NF separates them."
    },
    {
      "id": "norm-072",
      "type": "two-stage",
      "stages": [
        {
          "question": "Table: EmpSkillLang(emp_id, skill, language). An employee knows {Java, Python} and speaks {English, French}. How many rows?",
          "options": ["2", "4", "6"],
          "correct": 1,
          "explanation": "Four rows: (emp, Java, English), (emp, Java, French), (emp, Python, English), (emp, Python, French). The Cartesian product of independent facts."
        },
        {
          "question": "What's the 4NF fix?",
          "options": ["Add a surrogate PK", "Split into EmpSkill(emp_id, skill) and EmpLanguage(emp_id, language)", "Remove one of the columns", "Use JSON arrays"],
          "correct": 1,
          "explanation": "Split into two tables: EmpSkill(emp, Java), (emp, Python) and EmpLanguage(emp, English), (emp, French). 4 rows → 4 rows, but no artificial Cartesian product."
        }
      ]
    },
    {
      "id": "norm-073",
      "type": "multi-select",
      "question": "Which normal forms does the following table violate? Table: Student(id, name, courses_csv, advisor_id, advisor_name). courses_csv stores 'Math,Physics'.",
      "options": ["1NF (courses_csv is not atomic)", "2NF (no composite PK, so N/A)", "3NF (advisor_name depends on advisor_id)", "4NF (multi-valued dependency)"],
      "correctIndices": [0, 2],
      "explanation": "Violates 1NF (CSV column) and 3NF (advisor_name transitive through advisor_id). 2NF not applicable (single PK). 4NF isn't relevant without the 1NF fix."
    },
    {
      "id": "norm-074",
      "type": "multiple-choice",
      "question": "A view joins normalized tables to present a denormalized result. Does this violate normalization?",
      "options": ["Yes — the view is denormalized", "No — the underlying tables are still normalized; the view is just a query", "Only if the view is materialized", "Depends on the database"],
      "correct": 1,
      "explanation": "Views don't store data (unless materialized). A view that joins normalized tables provides convenience without violating normalization. The schema is still 3NF."
    },
    {
      "id": "norm-075",
      "type": "numeric-input",
      "question": "A denormalized table has 5 entities' data in one table. To normalize to 3NF, what's the minimum number of tables?",
      "answer": 5,
      "tolerance": "exact",
      "explanation": "Minimum 5 tables—one per entity. Each entity's attributes go in its own table with a PK, and relationships are captured via FKs. More if there are M:N relationships."
    },
    {
      "id": "norm-076",
      "type": "ordering",
      "question": "Rank these scenarios by how much they benefit from normalization (MOST to LEAST benefit):",
      "items": ["Frequently updated master data (customer names, prices)", "Write-once event logs", "Read-heavy reporting dashboards", "Data that's written once and rarely updated (archived records)"],
      "correctOrder": [0, 3, 1, 2],
      "explanation": "Frequently updated data benefits most (prevents update anomalies). Archived data: integrity matters. Write-once logs: append-only, less benefit. Dashboards: denormalized is faster."
    },
    {
      "id": "norm-077",
      "type": "two-stage",
      "stages": [
        {
          "question": "Your colleague says 'NoSQL means we don't need normalization.' Is this correct?",
          "options": ["Yes — NoSQL is schema-free", "Partially — NoSQL trades normalization for read performance", "No — normalization principles apply regardless of database type", "Depends on the NoSQL type"],
          "correct": 1,
          "explanation": "NoSQL intentionally denormalizes for performance (embedding, duplication). But normalization concepts still guide decisions—you're making conscious trade-offs, not ignoring the principles."
        },
        {
          "question": "In MongoDB, you embed a user's address in the user document. What normalization trade-off are you making?",
          "options": ["None — documents are different", "Denormalizing for read performance; accepting that updating all addresses of a type requires updating each document", "Violating 1NF", "Creating a transitive dependency"],
          "correct": 1,
          "explanation": "Embedding = intentional denormalization. The trade-off: no join needed for reads, but if the address format changes, every document must be updated individually."
        }
      ]
    },
    {
      "id": "norm-078",
      "type": "multi-select",
      "question": "Which are true about the practical limits of normalization?",
      "options": ["Most production schemas stop at 3NF", "4NF and 5NF are rarely used in practice", "Over-normalization can hurt read performance", "Normalization is always the right choice"],
      "correctIndices": [0, 1, 2],
      "explanation": "3NF is the practical standard. 4NF/5NF are academic. Over-normalization creates too many small tables and JOINs. The right level depends on access patterns."
    },
    {
      "id": "norm-079",
      "type": "multiple-choice",
      "question": "What is 'dependency preservation' in normalization?",
      "options": ["Keeping all foreign keys", "After decomposition, all functional dependencies can still be enforced without joins", "Preserving backward compatibility", "Keeping dependent tables together"],
      "correct": 1,
      "explanation": "Dependency preservation: after splitting tables, each functional dependency should be checkable within a single table (without joining). Some decompositions lose this property."
    },
    {
      "id": "norm-080",
      "type": "multiple-choice",
      "question": "Table: Shipment(id, order_id, carrier, carrier_phone, tracking_number). Is carrier_phone a 3NF violation?",
      "options": ["No — it depends on the PK", "Yes — carrier_phone depends on carrier (transitive)", "Only if carrier has a separate table", "Depends on whether carriers change phone numbers"],
      "correct": 1,
      "explanation": "carrier_phone depends on carrier, not directly on shipment id. id → carrier → carrier_phone is transitive. Extract Carrier(name, phone)."
    },
    {
      "id": "norm-081",
      "type": "ordering",
      "question": "Rank these data types by how appropriate they are for a 1NF-compliant column (MOST to LEAST appropriate):",
      "items": ["INTEGER", "VARCHAR (single value)", "JSON object (structured data)", "TEXT[] (array)"],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "INTEGER and single VARCHAR are fully atomic. JSON is debatable—atomic if treated as opaque, but multi-valued if queried. Arrays are explicitly multi-valued, violating strict 1NF."
    },
    {
      "id": "norm-082",
      "type": "two-stage",
      "stages": [
        {
          "question": "You're designing an e-commerce schema. The PM says 'store the product name on each order line for invoices.' What's your response?",
          "options": ["Refuse — it violates 3NF", "Accept — this is valid point-in-time denormalization", "Ask: does the name need to be the name at time of purchase or the current name?", "Use a view instead"],
          "correct": 2,
          "explanation": "The right question: is this a snapshot requirement? If products can be renamed, old invoices should show the original name. This determines whether it's a valid denormalization."
        },
        {
          "question": "The PM confirms: 'We need the name at time of purchase.' How do you model it cleanly?",
          "options": ["Just store product_name on OrderItem", "Store product_name_at_purchase on OrderItem AND keep product_id FK to current Product", "Only store product_id and look up the name", "Create a ProductHistory table"],
          "correct": 1,
          "explanation": "Both: product_id FK (for current data, joins, integrity) AND product_name_at_purchase (for the snapshot). This makes the intent clear and preserves both capabilities."
        }
      ]
    },
    {
      "id": "norm-083",
      "type": "multiple-choice",
      "question": "Which column in OrderItem(order_id, product_id, qty, unit_price, product_current_price) is problematic?",
      "options": ["unit_price (snapshot of price at purchase time)", "product_current_price (changes with product — update anomaly)", "qty (depends on the full composite key)", "order_id and product_id (foreign keys)"],
      "correct": 1,
      "explanation": "product_current_price is redundant and will go stale — it changes when the product price changes, creating an update anomaly. unit_price is a valid snapshot (frozen at purchase time). qty depends on the full PK. The FKs are correct."
    },
    {
      "id": "norm-084",
      "type": "multiple-choice",
      "question": "What does 'normalize until it hurts, then denormalize until it works' mean?",
      "options": ["Start fully normalized for integrity, then selectively denormalize where performance requires it", "Normalization is painful", "Denormalization is always better", "Try both and pick the faster one"],
      "correct": 0,
      "explanation": "Start with a clean, normalized schema (3NF). When specific queries are too slow due to JOINs, strategically denormalize those hot paths. Integrity first, performance second."
    },
    {
      "id": "norm-085",
      "type": "numeric-input",
      "question": "Table: LibraryLoan(loan_id, book_isbn, book_title, book_author, member_id, member_name, loan_date). How many non-key columns violate 3NF?",
      "answer": 3,
      "tolerance": "exact",
      "explanation": "Three: book_title and book_author depend on book_isbn (transitive), member_name depends on member_id (transitive). loan_date depends directly on loan_id (fine)."
    },
    {
      "id": "norm-086",
      "type": "multi-select",
      "question": "After normalizing the library table above, which tables exist?",
      "options": ["LibraryLoan(loan_id, book_isbn, member_id, loan_date)", "Book(isbn, title, author)", "Member(id, name)", "LibraryLoan(loan_id, book_title, member_name, loan_date)"],
      "correctIndices": [0, 1, 2],
      "explanation": "Three tables: LibraryLoan with FKs, Book with book attributes, Member with member attributes. The last option keeps the denormalized columns—that's what we're fixing."
    },
    {
      "id": "norm-087",
      "type": "two-stage",
      "stages": [
        {
          "question": "A developer stores user preferences as JSON: User(id, name, preferences JSON). Does this violate 1NF?",
          "options": ["Yes — JSON is not atomic", "No — if treated as a single opaque value", "It's a gray area — depends on how it's queried", "Only if using a relational database"],
          "correct": 2,
          "explanation": "Strict interpretation: JSON is multi-valued → violates 1NF. Pragmatic: if you never query individual JSON fields in WHERE clauses, it acts like an opaque blob—acceptable."
        },
        {
          "question": "The app now needs to query WHERE preferences->>'theme' = 'dark'. Does your answer change?",
          "options": ["No — still fine as JSON", "Yes — the field is now being treated as structured data, not atomic", "Depends on database support", "Only matters for performance"],
          "correct": 1,
          "explanation": "Querying inside JSON means it's structured data, not atomic. Consider: either add a GIN index (pragmatic) or extract theme to its own column (strict normalization)."
        }
      ]
    },
    {
      "id": "norm-088",
      "type": "multiple-choice",
      "question": "What is a 'derived attribute' and how does it relate to normalization?",
      "options": ["An attribute computed from other attributes (e.g., age from birth_date) — storing it creates redundancy", "An attribute inherited from a parent table", "A foreign key", "A computed column in a view"],
      "correct": 0,
      "explanation": "Derived attributes (total_price = qty × unit_price, age = now - birth_date) are redundant because they can be computed. Storing them risks inconsistency but can improve read performance."
    },
    {
      "id": "norm-089",
      "type": "ordering",
      "question": "Rank these derived values by how reasonable it is to store them (MOST to LEAST reasonable):",
      "items": ["Order total (sum of line items — expensive to recompute for every query)", "User's age (changes daily — always stale)", "Post word count (stable once published)", "Account balance (critical, frequently read)"],
      "correctOrder": [3, 0, 2, 1],
      "explanation": "Account balance: critical, stored for integrity. Order total: expensive aggregate, worth caching. Word count: stable, cheap to store. Age: always stale, compute from birth_date."
    },
    {
      "id": "norm-090",
      "type": "multi-select",
      "question": "Which of these schemas are in 1NF?",
      "options": ["User(id, name, email)", "User(id, name, phones TEXT[])", "Product(id, name, tags JSON)", "Order(id, date, total DECIMAL)"],
      "correctIndices": [0, 3],
      "explanation": "User(id, name, email) and Order are 1NF—atomic values. TEXT[] and JSON are multi-valued, violating strict 1NF interpretation."
    },
    {
      "id": "norm-091",
      "type": "multiple-choice",
      "question": "A schema has: Employee(id, name), Department(id, name), EmployeeDept(employee_id, department_id, start_date). What NF is this?",
      "options": ["1NF", "2NF", "3NF", "Beyond 3NF"],
      "correct": 2,
      "explanation": "3NF: all attributes depend on their table's PK. No partial dependencies (EmployeeDept's composite PK determines start_date fully). No transitive dependencies. Clean schema."
    },
    {
      "id": "norm-092",
      "type": "two-stage",
      "stages": [
        {
          "question": "A legacy table has 80 columns mixing Order, Customer, Product, and Shipping data. First step to normalize?",
          "options": ["Identify the distinct entities (Order, Customer, Product, Shipping)", "Add indexes", "Split into random groups of columns", "Add a surrogate PK"],
          "correct": 0,
          "explanation": "First: identify entities and their natural boundaries. Group columns by what entity they describe. Then create tables for each entity with proper PKs and FKs."
        },
        {
          "question": "After splitting into 4 entity tables, what should you verify?",
          "options": ["That queries are faster", "That joins reconstruct the original data losslessly", "That the table count is minimal", "That column names are consistent"],
          "correct": 1,
          "explanation": "Verify lossless decomposition: joining the new tables must produce exactly the original data. No rows lost, no spurious rows added. This ensures the normalization is correct."
        }
      ]
    },
    {
      "id": "norm-093",
      "type": "numeric-input",
      "question": "A table has columns: sale_id (PK), product_id, product_name, product_category, category_manager, customer_id, customer_name, customer_city. How many functional dependency chains violate 3NF?",
      "answer": 3,
      "tolerance": "exact",
      "explanation": "Three chains: (1) product_id → product_name, (2) product_id → product_category → category_manager, (3) customer_id → customer_name, customer_city. All are transitive through non-key columns."
    },
    {
      "id": "norm-094",
      "type": "multi-select",
      "question": "What tools help identify normalization issues in existing databases?",
      "options": ["ER diagram analysis (visualize dependencies)", "Duplicate data queries (find repeated values)", "Application code review (look for multi-row updates of the same fact)", "EXPLAIN ANALYZE (query performance)"],
      "correctIndices": [0, 1, 2],
      "explanation": "ER diagrams show structural issues. Duplicate queries find redundancy. Code review reveals update anomalies. EXPLAIN shows performance but not normalization issues."
    },
    {
      "id": "norm-095",
      "type": "multiple-choice",
      "question": "What is 5NF (Fifth Normal Form)?",
      "options": ["The most normalized possible", "In 4NF AND every join dependency is implied by candidate keys", "A table with 5 columns", "Unused in practice"],
      "correct": 1,
      "explanation": "5NF (Project-Join Normal Form): every join dependency is implied by candidate keys. Extremely rare to encounter in practice. Most schemas don't need to go beyond 3NF or BCNF."
    },
    {
      "id": "norm-096",
      "type": "ordering",
      "question": "Rank these normalization levels by practical usage frequency (MOST to LEAST used in real systems):",
      "items": ["3NF", "1NF", "BCNF", "5NF"],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "3NF is the most common design target. 1NF is a given (even denormalized tables usually have atomic values). BCNF is occasionally needed. 5NF is almost never used."
    },
    {
      "id": "norm-097",
      "type": "two-stage",
      "stages": [
        {
          "question": "You inherit a database where 30% of queries touch a denormalized 'user_dashboard_data' table. Should you normalize it?",
          "options": ["Yes — always normalize", "No — it's a materialized view pattern for read performance", "Maybe — check if update anomalies are causing bugs", "Delete the table"],
          "correct": 2,
          "explanation": "Check if the denormalization causes real problems (stale data, bugs, update failures). If it's working correctly as a read optimization, it might be fine as-is."
        },
        {
          "question": "Investigation shows the table gets out of sync weekly, requiring manual fixes. What should you do?",
          "options": ["Normalize the data and use JOINs", "Normalize but add a materialized view with automatic refresh", "Fix the sync logic", "Both B and C are valid"],
          "correct": 1,
          "explanation": "Best of both: normalize the source of truth (3NF tables), then create a materialized view for the dashboard. Automatic refresh keeps it in sync without manual intervention."
        }
      ]
    },
    {
      "id": "norm-098",
      "type": "multi-select",
      "question": "Which correctly describe materialized views in relation to normalization?",
      "options": ["They're precomputed denormalized query results", "They keep the source schema normalized", "They need refresh strategies (manual, periodic, or on change)", "They replace the need for normalization"],
      "correctIndices": [0, 1, 2],
      "explanation": "Materialized views store denormalized results of queries on normalized tables. Source tables stay normalized. Views need refresh. They complement normalization, don't replace it."
    },
    {
      "id": "norm-099",
      "type": "multiple-choice",
      "question": "Which mnemonic summarizes the dependencies checked by 1NF, 2NF, and 3NF?",
      "options": ["'The key, the whole key, and nothing but the key, so help me Codd'", "'First tables, then keys, then constraints'", "'Normalize, optimize, denormalize'", "'One table, one purpose'"],
      "correct": 0,
      "explanation": "The famous mnemonic: 'The key (1NF—data has a key), the whole key (2NF—no partial deps), and nothing but the key (3NF—no transitive deps), so help me Codd.'"
    },
    {
      "id": "norm-100",
      "type": "multiple-choice",
      "question": "What is the single most important practical takeaway about normalization?",
      "options": ["Always normalize to the highest possible level", "Every fact should be stored in exactly one place — duplication creates anomalies", "Normalization is only for SQL databases", "JOINs are bad and should be avoided"],
      "correct": 1,
      "explanation": "The core principle: each fact stored once. When a fact is duplicated, changes must touch every copy—miss one and data is inconsistent. This drives all normalization rules."
    }
  ]
}
