{
  "unit": 8,
  "unitTitle": "Consistency & Coordination",
  "chapter": 7,
  "chapterTitle": "Conflict Resolution & Convergence",
  "chapterDescription": "Designing merge semantics and replay-safe conflict handling for eventually consistent systems with concurrent updates.",
  "problems": [
    {
      "id": "cc-cr-001",
      "type": "multiple-choice",
      "question": "A user profile merge service is facing concurrent updates to same field. Which conflict-resolution/convergence decision is strongest? Recent partition tests exposed merge ambiguity.",
      "options": [
        "Use domain-specific merge semantics instead of global last-write-wins for critical fields.",
        "Apply universal last-write-wins for every entity and field.",
        "Discard conflicting updates silently to preserve throughput.",
        "Assume replayed updates are always newer than stored state."
      ],
      "correct": 0,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A user profile merge service is facing concurrent updates to same field, this is the strongest fit in Conflict Resolution & Convergence.",
      "detailedExplanation": "Use \"user profile merge service is facing concurrent updates to same field\" as your starting point, then verify tradeoffs carefully. Prefer the choice that keeps ordering/acknowledgment behavior predictable under failure. A good message-system answer defines guarantees clearly for both producer and consumer paths. Common pitfall: assuming exactly-once without idempotency.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-002",
      "type": "multiple-choice",
      "question": "A collaborative doc state store is facing offline edits arriving out of order. Which conflict-resolution/convergence decision is strongest? User trust impact is high for this data class.",
      "options": [
        "Apply universal last-write-wins for every entity and field.",
        "Discard conflicting updates silently to preserve throughput.",
        "Assume replayed updates are always newer than stored state.",
        "Use version/vector metadata to detect concurrency and drive deterministic merge decisions."
      ],
      "correct": 3,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A collaborative doc state store is facing offline edits arriving out of order, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "The core signal here is \"collaborative doc state store is facing offline edits arriving out of order\". Prefer the option that preserves correctness guarantees for the stated consistency boundary. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-003",
      "type": "multiple-choice",
      "question": "A shopping cart sync backend is facing divergent region writes after partition. Which conflict-resolution/convergence decision is strongest? The system handles offline-first clients at scale.",
      "options": [
        "Discard conflicting updates silently to preserve throughput.",
        "Assume replayed updates are always newer than stored state.",
        "Use CRDT-style commutative structures where business semantics allow safe convergence.",
        "Apply universal last-write-wins for every entity and field."
      ],
      "correct": 2,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A shopping cart sync backend is facing divergent region writes after partition, this is the strongest fit in Conflict Resolution & Convergence.",
      "detailedExplanation": "If you keep \"shopping cart sync backend is facing divergent region writes after partition\" in view, the correct answer separates faster. Eliminate options that ignore delivery semantics or backpressure behavior. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. Common pitfall: consumer lag growth under burst traffic.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-004",
      "type": "multiple-choice",
      "question": "A inventory reconciliation service is facing duplicate event replay with stale payload. Which conflict-resolution/convergence decision is strongest? Current LWW behavior caused silent field loss.",
      "options": [
        "Assume replayed updates are always newer than stored state.",
        "Make merge handlers idempotent and replay-safe with dedupe/version guards.",
        "Apply universal last-write-wins for every entity and field.",
        "Discard conflicting updates silently to preserve throughput."
      ],
      "correct": 1,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A inventory reconciliation service is facing duplicate event replay with stale payload, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "Start from \"inventory reconciliation service is facing duplicate event replay with stale payload\", then pressure-test the result against the options. Discard options that weaken contract clarity or compatibility over time. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-005",
      "type": "multiple-choice",
      "question": "A chat thread state projector is facing last-write-wins data loss risk. Which conflict-resolution/convergence decision is strongest? Replay rates increased after retry-policy changes.",
      "options": [
        "Escalate unresolved conflicts to explicit user/business resolution flow for high-risk data.",
        "Apply universal last-write-wins for every entity and field.",
        "Discard conflicting updates silently to preserve throughput.",
        "Assume replayed updates are always newer than stored state."
      ],
      "correct": 0,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A chat thread state projector is facing last-write-wins data loss risk, this is the strongest fit in Conflict Resolution & Convergence.",
      "detailedExplanation": "The key clue in this question is \"chat thread state projector is facing last-write-wins data loss risk\". Prioritize the option that best protects the reliability objective under the stated failure conditions. Tie the decision to concrete operational outcomes, not abstract reliability language. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Retry pattern",
          "url": "https://learn.microsoft.com/en-us/azure/architecture/patterns/retry"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-006",
      "type": "multiple-choice",
      "question": "A feature-flag state distribution is facing merge ambiguity for non-commutative operations. Which conflict-resolution/convergence decision is strongest? Auditability requirements now include conflict rationale.",
      "options": [
        "Apply universal last-write-wins for every entity and field.",
        "Discard conflicting updates silently to preserve throughput.",
        "Assume replayed updates are always newer than stored state.",
        "Partition entities by conflict profile and apply tailored merge policy per class."
      ],
      "correct": 3,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A feature-flag state distribution is facing merge ambiguity for non-commutative operations, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "Read this as a scenario about \"feature-flag state distribution is facing merge ambiguity for non-commutative operations\". Eliminate approaches that hand-wave conflict resolution or quorum behavior. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-007",
      "type": "multiple-choice",
      "question": "A multi-region settings service is facing compensation event arriving late. Which conflict-resolution/convergence decision is strongest? Business requires deterministic merge outcomes.",
      "options": [
        "Discard conflicting updates silently to preserve throughput.",
        "Assume replayed updates are always newer than stored state.",
        "Record causal history needed for conflict explanation and auditability.",
        "Apply universal last-write-wins for every entity and field."
      ],
      "correct": 2,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A multi-region settings service is facing compensation event arriving late, this is the strongest fit in Conflict Resolution & Convergence.",
      "detailedExplanation": "The decision turns on \"multi-region settings service is facing compensation event arriving late\". Reject designs that improve throughput while weakening reliability guarantees. Throughput is only one part; replay behavior and consumer lag handling matter equally. Common pitfall: ordering loss during partition or replay changes.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-008",
      "type": "multiple-choice",
      "question": "A ad campaign config sync is facing partial convergence under retry backoff. Which conflict-resolution/convergence decision is strongest? Some fields are commutative; others are not.",
      "options": [
        "Assume replayed updates are always newer than stored state.",
        "Define compensation ordering semantics so late compensations cannot corrupt newer state.",
        "Apply universal last-write-wins for every entity and field.",
        "Discard conflicting updates silently to preserve throughput."
      ],
      "correct": 1,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A ad campaign config sync is facing partial convergence under retry backoff, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "This prompt is really about \"ad campaign config sync is facing partial convergence under retry backoff\". Eliminate answers that do not directly address the failure mode, recovery path, or blast radius. Tie the decision to concrete operational outcomes, not abstract reliability language. Common pitfall: meeting average goals while missing tail-risk.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Retry pattern",
          "url": "https://learn.microsoft.com/en-us/azure/architecture/patterns/retry"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-009",
      "type": "multiple-choice",
      "question": "A identity claim convergence pipeline is facing idempotency gap in merge handlers. Which conflict-resolution/convergence decision is strongest? The team needs a safe first migration step.",
      "options": [
        "Bound eventual convergence windows and alert on prolonged divergence.",
        "Apply universal last-write-wins for every entity and field.",
        "Discard conflicting updates silently to preserve throughput.",
        "Assume replayed updates are always newer than stored state."
      ],
      "correct": 0,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A identity claim convergence pipeline is facing idempotency gap in merge handlers, this is the strongest fit in Conflict Resolution & Convergence.",
      "detailedExplanation": "Use \"identity claim convergence pipeline is facing idempotency gap in merge handlers\" as your starting point, then verify tradeoffs carefully. Eliminate approaches that hand-wave conflict resolution or quorum behavior. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-010",
      "type": "multiple-choice",
      "question": "A ticket reservation reconciliation is facing conflicting business rule updates. Which conflict-resolution/convergence decision is strongest? Current event payload lacks explicit causality metadata.",
      "options": [
        "Apply universal last-write-wins for every entity and field.",
        "Discard conflicting updates silently to preserve throughput.",
        "Assume replayed updates are always newer than stored state.",
        "Protect invariant-critical writes with stronger coordination, leaving tolerant fields convergent."
      ],
      "correct": 3,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A ticket reservation reconciliation is facing conflicting business rule updates, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "If you keep \"ticket reservation reconciliation is facing conflicting business rule updates\" in view, the correct answer separates faster. Discard options that weaken contract clarity or compatibility over time. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-011",
      "type": "multiple-choice",
      "question": "A billing adjustment merger is facing concurrent updates to same field. Which conflict-resolution/convergence decision is strongest? Conflict incidents are intermittent but high impact.",
      "options": [
        "Discard conflicting updates silently to preserve throughput.",
        "Assume replayed updates are always newer than stored state.",
        "Use domain-specific merge semantics instead of global last-write-wins for critical fields.",
        "Apply universal last-write-wins for every entity and field."
      ],
      "correct": 2,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A billing adjustment merger is facing concurrent updates to same field, this is the strongest fit in Conflict Resolution & Convergence.",
      "detailedExplanation": "The core signal here is \"billing adjustment merger is facing concurrent updates to same field\". Eliminate approaches that hand-wave conflict resolution or quorum behavior. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-012",
      "type": "multiple-choice",
      "question": "A notification state converger is facing offline edits arriving out of order. Which conflict-resolution/convergence decision is strongest? Compensation events can arrive significantly late.",
      "options": [
        "Assume replayed updates are always newer than stored state.",
        "Use version/vector metadata to detect concurrency and drive deterministic merge decisions.",
        "Apply universal last-write-wins for every entity and field.",
        "Discard conflicting updates silently to preserve throughput."
      ],
      "correct": 1,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A notification state converger is facing offline edits arriving out of order, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "Use \"notification state converger is facing offline edits arriving out of order\" as your starting point, then verify tradeoffs carefully. Prefer the option that preserves correctness guarantees for the stated consistency boundary. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-013",
      "type": "multiple-choice",
      "question": "A comment thread merge service is facing divergent region writes after partition. Which conflict-resolution/convergence decision is strongest? Cross-device edits frequently race in production.",
      "options": [
        "Use CRDT-style commutative structures where business semantics allow safe convergence.",
        "Apply universal last-write-wins for every entity and field.",
        "Discard conflicting updates silently to preserve throughput.",
        "Assume replayed updates are always newer than stored state."
      ],
      "correct": 0,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A comment thread merge service is facing divergent region writes after partition, this is the strongest fit in Conflict Resolution & Convergence.",
      "detailedExplanation": "This prompt is really about \"comment thread merge service is facing divergent region writes after partition\". Reject designs that improve throughput while weakening reliability guarantees. A good message-system answer defines guarantees clearly for both producer and consumer paths. Common pitfall: consumer lag growth under burst traffic.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-014",
      "type": "multiple-choice",
      "question": "A offline-first mobile sync API is facing duplicate event replay with stale payload. Which conflict-resolution/convergence decision is strongest? Schema evolution introduced merge policy drift.",
      "options": [
        "Apply universal last-write-wins for every entity and field.",
        "Discard conflicting updates silently to preserve throughput.",
        "Assume replayed updates are always newer than stored state.",
        "Make merge handlers idempotent and replay-safe with dedupe/version guards."
      ],
      "correct": 3,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A offline-first mobile sync API is facing duplicate event replay with stale payload, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "The decision turns on \"offline-first mobile sync API is facing duplicate event replay with stale payload\". Discard options that weaken contract clarity or compatibility over time. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-015",
      "type": "multiple-choice",
      "question": "A catalog attribute merge path is facing last-write-wins data loss risk. Which conflict-resolution/convergence decision is strongest? Operators need visibility into unresolved conflicts.",
      "options": [
        "Discard conflicting updates silently to preserve throughput.",
        "Assume replayed updates are always newer than stored state.",
        "Escalate unresolved conflicts to explicit user/business resolution flow for high-risk data.",
        "Apply universal last-write-wins for every entity and field."
      ],
      "correct": 2,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A catalog attribute merge path is facing last-write-wins data loss risk, this is the strongest fit in Conflict Resolution & Convergence.",
      "detailedExplanation": "Read this as a scenario about \"catalog attribute merge path is facing last-write-wins data loss risk\". Eliminate approaches that hand-wave conflict resolution or quorum behavior. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-016",
      "type": "multiple-choice",
      "question": "A fraud case state reconciler is facing merge ambiguity for non-commutative operations. Which conflict-resolution/convergence decision is strongest? Critical invariants must never be resolved by blind overwrite.",
      "options": [
        "Assume replayed updates are always newer than stored state.",
        "Partition entities by conflict profile and apply tailored merge policy per class.",
        "Apply universal last-write-wins for every entity and field.",
        "Discard conflicting updates silently to preserve throughput."
      ],
      "correct": 1,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A fraud case state reconciler is facing merge ambiguity for non-commutative operations, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "The key clue in this question is \"fraud case state reconciler is facing merge ambiguity for non-commutative operations\". Eliminate approaches that hand-wave conflict resolution or quorum behavior. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-017",
      "type": "multiple-choice",
      "question": "A support ticket merge workflow is facing compensation event arriving late. Which conflict-resolution/convergence decision is strongest? Current merge code is difficult to reason about.",
      "options": [
        "Record causal history needed for conflict explanation and auditability.",
        "Apply universal last-write-wins for every entity and field.",
        "Discard conflicting updates silently to preserve throughput.",
        "Assume replayed updates are always newer than stored state."
      ],
      "correct": 0,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A support ticket merge workflow is facing compensation event arriving late, this is the strongest fit in Conflict Resolution & Convergence.",
      "detailedExplanation": "Start from \"support ticket merge workflow is facing compensation event arriving late\", then pressure-test the result against the options. Reject designs that improve throughput while weakening reliability guarantees. A good message-system answer defines guarantees clearly for both producer and consumer paths. Common pitfall: consumer lag growth under burst traffic.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-018",
      "type": "multiple-choice",
      "question": "A shipment status convergence service is facing partial convergence under retry backoff. Which conflict-resolution/convergence decision is strongest? Performance constraints discourage global strict coordination.",
      "options": [
        "Apply universal last-write-wins for every entity and field.",
        "Discard conflicting updates silently to preserve throughput.",
        "Assume replayed updates are always newer than stored state.",
        "Define compensation ordering semantics so late compensations cannot corrupt newer state."
      ],
      "correct": 3,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A shipment status convergence service is facing partial convergence under retry backoff, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "If you keep \"shipment status convergence service is facing partial convergence under retry backoff\" in view, the correct answer separates faster. Eliminate answers that do not directly address the failure mode, recovery path, or blast radius. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Retry pattern",
          "url": "https://learn.microsoft.com/en-us/azure/architecture/patterns/retry"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-019",
      "type": "multiple-choice",
      "question": "A membership preference sync store is facing idempotency gap in merge handlers. Which conflict-resolution/convergence decision is strongest? User-facing consistency SLOs were recently added.",
      "options": [
        "Discard conflicting updates silently to preserve throughput.",
        "Assume replayed updates are always newer than stored state.",
        "Bound eventual convergence windows and alert on prolonged divergence.",
        "Apply universal last-write-wins for every entity and field."
      ],
      "correct": 2,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A membership preference sync store is facing idempotency gap in merge handlers, this is the strongest fit in Conflict Resolution & Convergence.",
      "detailedExplanation": "The core signal here is \"membership preference sync store is facing idempotency gap in merge handlers\". Eliminate approaches that hand-wave conflict resolution or quorum behavior. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-020",
      "type": "multiple-choice",
      "question": "A device configuration convergence backend is facing conflicting business rule updates. Which conflict-resolution/convergence decision is strongest? Downstream systems assume converged state within minutes.",
      "options": [
        "Assume replayed updates are always newer than stored state.",
        "Protect invariant-critical writes with stronger coordination, leaving tolerant fields convergent.",
        "Apply universal last-write-wins for every entity and field.",
        "Discard conflicting updates silently to preserve throughput."
      ],
      "correct": 1,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A device configuration convergence backend is facing conflicting business rule updates, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "The core signal here is \"device configuration convergence backend is facing conflicting business rule updates\". Discard choices that violate required invariants during concurrent or failed states. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-021",
      "type": "multiple-choice",
      "question": "A user profile merge service is facing concurrent updates to same field. Which conflict-resolution/convergence decision is strongest? The platform supports dedupe keys and version checks.",
      "options": [
        "Use domain-specific merge semantics instead of global last-write-wins for critical fields.",
        "Apply universal last-write-wins for every entity and field.",
        "Discard conflicting updates silently to preserve throughput.",
        "Assume replayed updates are always newer than stored state."
      ],
      "correct": 0,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A user profile merge service is facing concurrent updates to same field, this is the strongest fit in Conflict Resolution & Convergence.",
      "detailedExplanation": "If you keep \"user profile merge service is facing concurrent updates to same field\" in view, the correct answer separates faster. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-022",
      "type": "multiple-choice",
      "question": "A collaborative doc state store is facing offline edits arriving out of order. Which conflict-resolution/convergence decision is strongest? There is no current escalation path for irreconcilable conflicts.",
      "options": [
        "Apply universal last-write-wins for every entity and field.",
        "Discard conflicting updates silently to preserve throughput.",
        "Assume replayed updates are always newer than stored state.",
        "Use version/vector metadata to detect concurrency and drive deterministic merge decisions."
      ],
      "correct": 3,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A collaborative doc state store is facing offline edits arriving out of order, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "This prompt is really about \"collaborative doc state store is facing offline edits arriving out of order\". Eliminate approaches that hand-wave conflict resolution or quorum behavior. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-023",
      "type": "multiple-choice",
      "question": "A shopping cart sync backend is facing divergent region writes after partition. Which conflict-resolution/convergence decision is strongest? Some tenants tolerate delay but not silent data loss.",
      "options": [
        "Discard conflicting updates silently to preserve throughput.",
        "Assume replayed updates are always newer than stored state.",
        "Use CRDT-style commutative structures where business semantics allow safe convergence.",
        "Apply universal last-write-wins for every entity and field."
      ],
      "correct": 2,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A shopping cart sync backend is facing divergent region writes after partition, this is the strongest fit in Conflict Resolution & Convergence.",
      "detailedExplanation": "Use \"shopping cart sync backend is facing divergent region writes after partition\" as your starting point, then verify tradeoffs carefully. Eliminate options that ignore delivery semantics or backpressure behavior. A good message-system answer defines guarantees clearly for both producer and consumer paths. Common pitfall: consumer lag growth under burst traffic.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-024",
      "type": "multiple-choice",
      "question": "A inventory reconciliation service is facing duplicate event replay with stale payload. Which conflict-resolution/convergence decision is strongest? Replay and reorder are common after failover.",
      "options": [
        "Assume replayed updates are always newer than stored state.",
        "Make merge handlers idempotent and replay-safe with dedupe/version guards.",
        "Apply universal last-write-wins for every entity and field.",
        "Discard conflicting updates silently to preserve throughput."
      ],
      "correct": 1,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A inventory reconciliation service is facing duplicate event replay with stale payload, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "Read this as a scenario about \"inventory reconciliation service is facing duplicate event replay with stale payload\". Reject choices that sound good generally but do not reduce the concrete reliability risk in this scenario. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: meeting average goals while missing tail-risk.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-025",
      "type": "multiple-choice",
      "question": "A chat thread state projector is facing last-write-wins data loss risk. Which conflict-resolution/convergence decision is strongest? A prior patch reduced duplicates but increased drift.",
      "options": [
        "Escalate unresolved conflicts to explicit user/business resolution flow for high-risk data.",
        "Apply universal last-write-wins for every entity and field.",
        "Discard conflicting updates silently to preserve throughput.",
        "Assume replayed updates are always newer than stored state."
      ],
      "correct": 0,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A chat thread state projector is facing last-write-wins data loss risk, this is the strongest fit in Conflict Resolution & Convergence.",
      "detailedExplanation": "The decision turns on \"chat thread state projector is facing last-write-wins data loss risk\". Eliminate approaches that hand-wave conflict resolution or quorum behavior. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-026",
      "type": "multiple-choice",
      "question": "A feature-flag state distribution is facing merge ambiguity for non-commutative operations. Which conflict-resolution/convergence decision is strongest? The product now supports cross-region active-active writes.",
      "options": [
        "Apply universal last-write-wins for every entity and field.",
        "Discard conflicting updates silently to preserve throughput.",
        "Assume replayed updates are always newer than stored state.",
        "Partition entities by conflict profile and apply tailored merge policy per class."
      ],
      "correct": 3,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A feature-flag state distribution is facing merge ambiguity for non-commutative operations, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "Start from \"feature-flag state distribution is facing merge ambiguity for non-commutative operations\", then pressure-test the result against the options. Discard choices that violate required invariants during concurrent or failed states. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-027",
      "type": "multiple-choice",
      "question": "A multi-region settings service is facing compensation event arriving late. Which conflict-resolution/convergence decision is strongest? Business teams demand explicit merge policy documentation.",
      "options": [
        "Discard conflicting updates silently to preserve throughput.",
        "Assume replayed updates are always newer than stored state.",
        "Record causal history needed for conflict explanation and auditability.",
        "Apply universal last-write-wins for every entity and field."
      ],
      "correct": 2,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A multi-region settings service is facing compensation event arriving late, this is the strongest fit in Conflict Resolution & Convergence.",
      "detailedExplanation": "The key clue in this question is \"multi-region settings service is facing compensation event arriving late\". Eliminate options that ignore delivery semantics or backpressure behavior. Throughput is only one part; replay behavior and consumer lag handling matter equally. Common pitfall: ordering loss during partition or replay changes.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-028",
      "type": "multiple-choice",
      "question": "A ad campaign config sync is facing partial convergence under retry backoff. Which conflict-resolution/convergence decision is strongest? Observability now tracks divergence duration by entity.",
      "options": [
        "Assume replayed updates are always newer than stored state.",
        "Define compensation ordering semantics so late compensations cannot corrupt newer state.",
        "Apply universal last-write-wins for every entity and field.",
        "Discard conflicting updates silently to preserve throughput."
      ],
      "correct": 1,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A ad campaign config sync is facing partial convergence under retry backoff, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "The core signal here is \"ad campaign config sync is facing partial convergence under retry backoff\". Prioritize the option that best protects the reliability objective under the stated failure conditions. The strongest answer explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Retry pattern",
          "url": "https://learn.microsoft.com/en-us/azure/architecture/patterns/retry"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-029",
      "type": "multiple-choice",
      "question": "A identity claim convergence pipeline is facing idempotency gap in merge handlers. Which conflict-resolution/convergence decision is strongest? Conflicts cluster around a few high-write fields.",
      "options": [
        "Bound eventual convergence windows and alert on prolonged divergence.",
        "Apply universal last-write-wins for every entity and field.",
        "Discard conflicting updates silently to preserve throughput.",
        "Assume replayed updates are always newer than stored state."
      ],
      "correct": 0,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A identity claim convergence pipeline is facing idempotency gap in merge handlers, this is the strongest fit in Conflict Resolution & Convergence.",
      "detailedExplanation": "If you keep \"identity claim convergence pipeline is facing idempotency gap in merge handlers\" in view, the correct answer separates faster. Eliminate approaches that hand-wave conflict resolution or quorum behavior. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-030",
      "type": "multiple-choice",
      "question": "A ticket reservation reconciliation is facing conflicting business rule updates. Which conflict-resolution/convergence decision is strongest? The migration must be canary-friendly and reversible.",
      "options": [
        "Apply universal last-write-wins for every entity and field.",
        "Discard conflicting updates silently to preserve throughput.",
        "Assume replayed updates are always newer than stored state.",
        "Protect invariant-critical writes with stronger coordination, leaving tolerant fields convergent."
      ],
      "correct": 3,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A ticket reservation reconciliation is facing conflicting business rule updates, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "The key clue in this question is \"ticket reservation reconciliation is facing conflicting business rule updates\". Discard choices that violate required invariants during concurrent or failed states. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-031",
      "type": "multiple-choice",
      "question": "A billing adjustment merger is facing concurrent updates to same field. Which conflict-resolution/convergence decision is strongest? Client retries may re-send stale updates unexpectedly.",
      "options": [
        "Discard conflicting updates silently to preserve throughput.",
        "Assume replayed updates are always newer than stored state.",
        "Use domain-specific merge semantics instead of global last-write-wins for critical fields.",
        "Apply universal last-write-wins for every entity and field."
      ],
      "correct": 2,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A billing adjustment merger is facing concurrent updates to same field, this is the strongest fit in Conflict Resolution & Convergence.",
      "detailedExplanation": "Start from \"billing adjustment merger is facing concurrent updates to same field\", then pressure-test the result against the options. Prefer the choice that balances hit rate with clear staleness and invalidation behavior. Treat freshness policy and invalidation paths as first-class constraints. Common pitfall: invalidation races under concurrent writes.",
      "references": [
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-032",
      "type": "multiple-choice",
      "question": "A notification state converger is facing offline edits arriving out of order. Which conflict-resolution/convergence decision is strongest? Compensating logic exists but lacks ordering safeguards.",
      "options": [
        "Assume replayed updates are always newer than stored state.",
        "Use version/vector metadata to detect concurrency and drive deterministic merge decisions.",
        "Apply universal last-write-wins for every entity and field.",
        "Discard conflicting updates silently to preserve throughput."
      ],
      "correct": 1,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A notification state converger is facing offline edits arriving out of order, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "The decision turns on \"notification state converger is facing offline edits arriving out of order\". Discard choices that violate required invariants during concurrent or failed states. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-033",
      "type": "multiple-choice",
      "question": "A comment thread merge service is facing divergent region writes after partition. Which conflict-resolution/convergence decision is strongest? Throughput targets remain strict despite stronger merge semantics.",
      "options": [
        "Use CRDT-style commutative structures where business semantics allow safe convergence.",
        "Apply universal last-write-wins for every entity and field.",
        "Discard conflicting updates silently to preserve throughput.",
        "Assume replayed updates are always newer than stored state."
      ],
      "correct": 0,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A comment thread merge service is facing divergent region writes after partition, this is the strongest fit in Conflict Resolution & Convergence.",
      "detailedExplanation": "Read this as a scenario about \"comment thread merge service is facing divergent region writes after partition\". Reject designs that improve throughput while weakening reliability guarantees. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. Common pitfall: ordering loss during partition or replay changes.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-034",
      "type": "multiple-choice",
      "question": "A offline-first mobile sync API is facing duplicate event replay with stale payload. Which conflict-resolution/convergence decision is strongest? Support teams need explainable conflict outcomes.",
      "options": [
        "Apply universal last-write-wins for every entity and field.",
        "Discard conflicting updates silently to preserve throughput.",
        "Assume replayed updates are always newer than stored state.",
        "Make merge handlers idempotent and replay-safe with dedupe/version guards."
      ],
      "correct": 3,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A offline-first mobile sync API is facing duplicate event replay with stale payload, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "Use \"offline-first mobile sync API is facing duplicate event replay with stale payload\" as your starting point, then verify tradeoffs carefully. Discard options that weaken contract clarity or compatibility over time. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-035",
      "type": "multiple-choice",
      "question": "A catalog attribute merge path is facing last-write-wins data loss risk. Which conflict-resolution/convergence decision is strongest? Post-incident hardening is part of this scope.",
      "options": [
        "Discard conflicting updates silently to preserve throughput.",
        "Assume replayed updates are always newer than stored state.",
        "Escalate unresolved conflicts to explicit user/business resolution flow for high-risk data.",
        "Apply universal last-write-wins for every entity and field."
      ],
      "correct": 2,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A catalog attribute merge path is facing last-write-wins data loss risk, this is the strongest fit in Conflict Resolution & Convergence.",
      "detailedExplanation": "This prompt is really about \"catalog attribute merge path is facing last-write-wins data loss risk\". Eliminate answers that do not directly address the failure mode, recovery path, or blast radius. Tie the decision to concrete operational outcomes, not abstract reliability language. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-036",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: shopping cart sync backend reports incidents around last-write-wins data loss risk. What is the primary diagnosis?",
          "options": [
            "Current merge policy in shopping cart sync backend mismatches last-write-wins data loss risk, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness."
          ],
          "correct": 0,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For shopping cart sync backend reports incidents around last-write-wins data loss risk, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "The key clue in this question is \"scenario: shopping cart sync backend reports incidents around last-write-wins data loss\". Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while preserving user-visible coherence?",
          "options": [
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Make merge handlers idempotent and replay-safe with dedupe/version guards."
          ],
          "correct": 3,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change while preserving user-visible coherence, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "Read this as a scenario about \"after confirming diagnosis, what is the strongest next change while preserving\". Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "If you keep \"conflict Resolution & Convergence\" in view, the correct answer separates faster. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-037",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: inventory reconciliation service reports incidents around merge ambiguity for non-commutative operations. What is the primary diagnosis?",
          "options": [
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness.",
            "Current merge policy in inventory reconciliation service mismatches merge ambiguity for non-commutative operations, causing incorrect convergence."
          ],
          "correct": 3,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For inventory reconciliation service reports incidents around merge ambiguity for non-commutative operations, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "The core signal here is \"scenario: inventory reconciliation service reports incidents around merge ambiguity for\". Solve this as chained reasoning where stage two must respect stage one assumptions. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under replay-heavy failure recovery?",
          "options": [
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Escalate unresolved conflicts to explicit user/business resolution flow for high-risk data.",
            "Disable conflict detection to reduce write latency."
          ],
          "correct": 2,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change under replay-heavy failure recovery, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Use \"after confirming diagnosis, what is the strongest next change under replay-heavy\" as your starting point, then verify tradeoffs carefully. Do not reset assumptions between stages; carry forward prior constraints directly. Tie the decision to concrete operational outcomes, not abstract reliability language. Common pitfall: meeting average goals while missing tail-risk."
        }
      ],
      "detailedExplanation": "The core signal here is \"conflict Resolution & Convergence\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-038",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: chat thread state projector reports incidents around compensation event arriving late. What is the primary diagnosis?",
          "options": [
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness.",
            "Current merge policy in chat thread state projector mismatches compensation event arriving late, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists."
          ],
          "correct": 2,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For chat thread state projector reports incidents around compensation event arriving late, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "If you keep \"scenario: chat thread state projector reports incidents around compensation event\" in view, the correct answer separates faster. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Throughput is only one part; replay behavior and consumer lag handling matter equally. Common pitfall: ordering loss during partition or replay changes."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change during cross-region divergence?",
          "options": [
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Partition entities by conflict profile and apply tailored merge policy per class.",
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only."
          ],
          "correct": 1,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change during cross-region divergence, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "This prompt is really about \"after confirming diagnosis, what is the strongest next change during cross-region\". Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "The key clue in this question is \"conflict Resolution & Convergence\". Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-039",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: feature-flag state distribution reports incidents around partial convergence under retry backoff. What is the primary diagnosis?",
          "options": [
            "Replay handling is independent from merge correctness.",
            "Current merge policy in feature-flag state distribution mismatches partial convergence under retry backoff, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome."
          ],
          "correct": 1,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For feature-flag state distribution reports incidents around partial convergence under retry backoff, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "This prompt is really about \"scenario: feature-flag state distribution reports incidents around partial convergence\". Do not reset assumptions between stages; carry forward prior constraints directly. Tie the decision to concrete operational outcomes, not abstract reliability language. Common pitfall: meeting average goals while missing tail-risk."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change without silent data loss?",
          "options": [
            "Record causal history needed for conflict explanation and auditability.",
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup."
          ],
          "correct": 0,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change without silent data loss, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "If you keep \"after confirming diagnosis, what is the strongest next change without silent data loss\" in view, the correct answer separates faster. Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "Start from \"conflict Resolution & Convergence\", then pressure-test the result against the options. Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-040",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: multi-region settings service reports incidents around idempotency gap in merge handlers. What is the primary diagnosis?",
          "options": [
            "Current merge policy in multi-region settings service mismatches idempotency gap in merge handlers, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness."
          ],
          "correct": 0,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For multi-region settings service reports incidents around idempotency gap in merge handlers, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "This prompt is really about \"scenario: multi-region settings service reports incidents around idempotency gap in\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with strict auditability needs?",
          "options": [
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Define compensation ordering semantics so late compensations cannot corrupt newer state."
          ],
          "correct": 3,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change with strict auditability needs, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "If you keep \"after confirming diagnosis, what is the strongest next change with strict auditability\" in view, the correct answer separates faster. Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "Start from \"conflict Resolution & Convergence\", then pressure-test the result against the options. Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-041",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: ad campaign config sync reports incidents around conflicting business rule updates. What is the primary diagnosis?",
          "options": [
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness.",
            "Current merge policy in ad campaign config sync mismatches conflicting business rule updates, causing incorrect convergence."
          ],
          "correct": 3,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For ad campaign config sync reports incidents around conflicting business rule updates, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "If you keep \"scenario: ad campaign config sync reports incidents around conflicting business rule\" in view, the correct answer separates faster. Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under high write concurrency?",
          "options": [
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Bound eventual convergence windows and alert on prolonged divergence.",
            "Disable conflict detection to reduce write latency."
          ],
          "correct": 2,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change under high write concurrency, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "This prompt is really about \"after confirming diagnosis, what is the strongest next change under high write\". Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "The key clue in this question is \"conflict Resolution & Convergence\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-042",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: identity claim convergence pipeline reports incidents around concurrent updates to same field. What is the primary diagnosis?",
          "options": [
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness.",
            "Current merge policy in identity claim convergence pipeline mismatches concurrent updates to same field, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists."
          ],
          "correct": 2,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For identity claim convergence pipeline reports incidents around concurrent updates to same field, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "Read this as a scenario about \"scenario: identity claim convergence pipeline reports incidents around concurrent\". Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while keeping merge latency acceptable?",
          "options": [
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Protect invariant-critical writes with stronger coordination, leaving tolerant fields convergent.",
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only."
          ],
          "correct": 1,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change while keeping merge latency acceptable, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "The key clue in this question is \"after confirming diagnosis, what is the strongest next change while keeping merge\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "Read this as a scenario about \"conflict Resolution & Convergence\". Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-043",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: ticket reservation reconciliation reports incidents around offline edits arriving out of order. What is the primary diagnosis?",
          "options": [
            "Replay handling is independent from merge correctness.",
            "Current merge policy in ticket reservation reconciliation mismatches offline edits arriving out of order, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome."
          ],
          "correct": 1,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For ticket reservation reconciliation reports incidents around offline edits arriving out of order, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Use \"scenario: ticket reservation reconciliation reports incidents around offline edits\" as your starting point, then verify tradeoffs carefully. Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change during compensation reordering?",
          "options": [
            "Use domain-specific merge semantics instead of global last-write-wins for critical fields.",
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup."
          ],
          "correct": 0,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change during compensation reordering, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "The core signal here is \"after confirming diagnosis, what is the strongest next change during compensation\". Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "The decision turns on \"conflict Resolution & Convergence\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-044",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: billing adjustment merger reports incidents around divergent region writes after partition. What is the primary diagnosis?",
          "options": [
            "Current merge policy in billing adjustment merger mismatches divergent region writes after partition, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness."
          ],
          "correct": 0,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For billing adjustment merger reports incidents around divergent region writes after partition, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "Start from \"scenario: billing adjustment merger reports incidents around divergent region writes\", then pressure-test the result against the options. Solve this as chained reasoning where stage two must respect stage one assumptions. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. Common pitfall: ordering loss during partition or replay changes."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with mixed commutative/non-commutative fields?",
          "options": [
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Use version/vector metadata to detect concurrency and drive deterministic merge decisions."
          ],
          "correct": 3,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change with mixed commutative/non-commutative fields, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "The decision turns on \"after confirming diagnosis, what is the strongest next change with mixed\". Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "This prompt is really about \"conflict Resolution & Convergence\". Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-045",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: notification state converger reports incidents around duplicate event replay with stale payload. What is the primary diagnosis?",
          "options": [
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness.",
            "Current merge policy in notification state converger mismatches duplicate event replay with stale payload, causing incorrect convergence."
          ],
          "correct": 3,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For notification state converger reports incidents around duplicate event replay with stale payload, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "The decision turns on \"scenario: notification state converger reports incidents around duplicate event replay\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: interface design coupled too tightly to internal implementation."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change before wider rollout?",
          "options": [
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Use CRDT-style commutative structures where business semantics allow safe convergence.",
            "Disable conflict detection to reduce write latency."
          ],
          "correct": 2,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change before wider rollout, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Start from \"after confirming diagnosis, what is the strongest next change before wider rollout\", then pressure-test the result against the options. Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "Use \"conflict Resolution & Convergence\" as your starting point, then verify tradeoffs carefully. Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-046",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: comment thread merge service reports incidents around last-write-wins data loss risk. What is the primary diagnosis?",
          "options": [
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness.",
            "Current merge policy in comment thread merge service mismatches last-write-wins data loss risk, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists."
          ],
          "correct": 2,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For comment thread merge service reports incidents around last-write-wins data loss risk, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "The core signal here is \"scenario: comment thread merge service reports incidents around last-write-wins data\". Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under offline client resync storms?",
          "options": [
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Make merge handlers idempotent and replay-safe with dedupe/version guards.",
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only."
          ],
          "correct": 1,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change under offline client resync storms, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "Use \"after confirming diagnosis, what is the strongest next change under offline client\" as your starting point, then verify tradeoffs carefully. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "The core signal here is \"conflict Resolution & Convergence\". Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-047",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: offline-first mobile sync API reports incidents around merge ambiguity for non-commutative operations. What is the primary diagnosis?",
          "options": [
            "Replay handling is independent from merge correctness.",
            "Current merge policy in offline-first mobile sync API mismatches merge ambiguity for non-commutative operations, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome."
          ],
          "correct": 1,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For offline-first mobile sync API reports incidents around merge ambiguity for non-commutative operations, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "The key clue in this question is \"scenario: offline-first mobile sync API reports incidents around merge ambiguity for\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: interface design coupled too tightly to internal implementation."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while controlling operational complexity?",
          "options": [
            "Escalate unresolved conflicts to explicit user/business resolution flow for high-risk data.",
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup."
          ],
          "correct": 0,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change while controlling operational complexity, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Read this as a scenario about \"after confirming diagnosis, what is the strongest next change while controlling\". Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "If you keep \"conflict Resolution & Convergence\" in view, the correct answer separates faster. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-048",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: catalog attribute merge path reports incidents around compensation event arriving late. What is the primary diagnosis?",
          "options": [
            "Current merge policy in catalog attribute merge path mismatches compensation event arriving late, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness."
          ],
          "correct": 0,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For catalog attribute merge path reports incidents around compensation event arriving late, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "This prompt is really about \"scenario: catalog attribute merge path reports incidents around compensation event\". Solve this as chained reasoning where stage two must respect stage one assumptions. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. Common pitfall: ordering loss during partition or replay changes."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with bounded convergence SLO?",
          "options": [
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Partition entities by conflict profile and apply tailored merge policy per class."
          ],
          "correct": 3,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change with bounded convergence SLO, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "If you keep \"after confirming diagnosis, what is the strongest next change with bounded convergence\" in view, the correct answer separates faster. Do not reset assumptions between stages; carry forward prior constraints directly. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: meeting average goals while missing tail-risk."
        }
      ],
      "detailedExplanation": "Start from \"conflict Resolution & Convergence\", then pressure-test the result against the options. Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-049",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: fraud case state reconciler reports incidents around partial convergence under retry backoff. What is the primary diagnosis?",
          "options": [
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness.",
            "Current merge policy in fraud case state reconciler mismatches partial convergence under retry backoff, causing incorrect convergence."
          ],
          "correct": 3,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For fraud case state reconciler reports incidents around partial convergence under retry backoff, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "If you keep \"scenario: fraud case state reconciler reports incidents around partial convergence\" in view, the correct answer separates faster. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. The strongest answer explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: assuming recovery speed without operational proof."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change during schema migration?",
          "options": [
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Record causal history needed for conflict explanation and auditability.",
            "Disable conflict detection to reduce write latency."
          ],
          "correct": 2,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change during schema migration, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "This prompt is really about \"after confirming diagnosis, what is the strongest next change during schema migration\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "The key clue in this question is \"conflict Resolution & Convergence\". Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-050",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: support ticket merge workflow reports incidents around idempotency gap in merge handlers. What is the primary diagnosis?",
          "options": [
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness.",
            "Current merge policy in support ticket merge workflow mismatches idempotency gap in merge handlers, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists."
          ],
          "correct": 2,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For support ticket merge workflow reports incidents around idempotency gap in merge handlers, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "Use \"scenario: support ticket merge workflow reports incidents around idempotency gap in\" as your starting point, then verify tradeoffs carefully. Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under tenant-specific merge policies?",
          "options": [
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Define compensation ordering semantics so late compensations cannot corrupt newer state.",
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only."
          ],
          "correct": 1,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change under tenant-specific merge policies, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "The core signal here is \"after confirming diagnosis, what is the strongest next change under tenant-specific\". Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "The decision turns on \"conflict Resolution & Convergence\". Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-051",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: shipment status convergence service reports incidents around conflicting business rule updates. What is the primary diagnosis?",
          "options": [
            "Replay handling is independent from merge correctness.",
            "Current merge policy in shipment status convergence service mismatches conflicting business rule updates, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome."
          ],
          "correct": 1,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For shipment status convergence service reports incidents around conflicting business rule updates, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Read this as a scenario about \"scenario: shipment status convergence service reports incidents around conflicting\". Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while preserving invariants?",
          "options": [
            "Bound eventual convergence windows and alert on prolonged divergence.",
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup."
          ],
          "correct": 0,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change while preserving invariants, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "The key clue in this question is \"after confirming diagnosis, what is the strongest next change while preserving\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "Read this as a scenario about \"conflict Resolution & Convergence\". Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-052",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: membership preference sync store reports incidents around concurrent updates to same field. What is the primary diagnosis?",
          "options": [
            "Current merge policy in membership preference sync store mismatches concurrent updates to same field, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness."
          ],
          "correct": 0,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For membership preference sync store reports incidents around concurrent updates to same field, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "If you keep \"scenario: membership preference sync store reports incidents around concurrent updates\" in view, the correct answer separates faster. Solve this as chained reasoning where stage two must respect stage one assumptions. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with explicit conflict explainability?",
          "options": [
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Protect invariant-critical writes with stronger coordination, leaving tolerant fields convergent."
          ],
          "correct": 3,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change with explicit conflict explainability, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "This prompt is really about \"after confirming diagnosis, what is the strongest next change with explicit conflict\". Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "The key clue in this question is \"conflict Resolution & Convergence\". Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-053",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: device configuration convergence backend reports incidents around offline edits arriving out of order. What is the primary diagnosis?",
          "options": [
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness.",
            "Current merge policy in device configuration convergence backend mismatches offline edits arriving out of order, causing incorrect convergence."
          ],
          "correct": 3,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For device configuration convergence backend reports incidents around offline edits arriving out of order, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "This prompt is really about \"scenario: device configuration convergence backend reports incidents around offline\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change during prolonged partitions?",
          "options": [
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Use domain-specific merge semantics instead of global last-write-wins for critical fields.",
            "Disable conflict detection to reduce write latency."
          ],
          "correct": 2,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change during prolonged partitions, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "If you keep \"after confirming diagnosis, what is the strongest next change during prolonged\" in view, the correct answer separates faster. Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "Start from \"conflict Resolution & Convergence\", then pressure-test the result against the options. Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-054",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: user profile merge service reports incidents around divergent region writes after partition. What is the primary diagnosis?",
          "options": [
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness.",
            "Current merge policy in user profile merge service mismatches divergent region writes after partition, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists."
          ],
          "correct": 2,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For user profile merge service reports incidents around divergent region writes after partition, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "The key clue in this question is \"scenario: user profile merge service reports incidents around divergent region writes\". Solve this as chained reasoning where stage two must respect stage one assumptions. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. Common pitfall: consumer lag growth under burst traffic."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under retry amplification?",
          "options": [
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Use version/vector metadata to detect concurrency and drive deterministic merge decisions.",
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only."
          ],
          "correct": 1,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change under retry amplification, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "Read this as a scenario about \"after confirming diagnosis, what is the strongest next change under retry amplification\". Do not reset assumptions between stages; carry forward prior constraints directly. The strongest answer explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: assuming recovery speed without operational proof."
        }
      ],
      "detailedExplanation": "If you keep \"conflict Resolution & Convergence\" in view, the correct answer separates faster. Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-055",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: collaborative doc state store reports incidents around duplicate event replay with stale payload. What is the primary diagnosis?",
          "options": [
            "Replay handling is independent from merge correctness.",
            "Current merge policy in collaborative doc state store mismatches duplicate event replay with stale payload, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome."
          ],
          "correct": 1,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For collaborative doc state store reports incidents around duplicate event replay with stale payload, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "The core signal here is \"scenario: collaborative doc state store reports incidents around duplicate event replay\". Do not reset assumptions between stages; carry forward prior constraints directly. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: ambiguous contracts that hide behavior changes."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while minimizing manual intervention?",
          "options": [
            "Use CRDT-style commutative structures where business semantics allow safe convergence.",
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup."
          ],
          "correct": 0,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change while minimizing manual intervention, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Use \"after confirming diagnosis, what is the strongest next change while minimizing manual\" as your starting point, then verify tradeoffs carefully. Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "The core signal here is \"conflict Resolution & Convergence\". Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-056",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: shopping cart sync backend reports incidents around last-write-wins data loss risk. What is the primary diagnosis?",
          "options": [
            "Current merge policy in shopping cart sync backend mismatches last-write-wins data loss risk, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness."
          ],
          "correct": 0,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For shopping cart sync backend reports incidents around last-write-wins data loss risk, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "The decision turns on \"scenario: shopping cart sync backend reports incidents around last-write-wins data loss\". Solve this as chained reasoning where stage two must respect stage one assumptions. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with deterministic outcomes?",
          "options": [
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Make merge handlers idempotent and replay-safe with dedupe/version guards."
          ],
          "correct": 3,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change with deterministic outcomes, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "Start from \"after confirming diagnosis, what is the strongest next change with deterministic\", then pressure-test the result against the options. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "Use \"conflict Resolution & Convergence\" as your starting point, then verify tradeoffs carefully. Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-057",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: inventory reconciliation service reports incidents around merge ambiguity for non-commutative operations. What is the primary diagnosis?",
          "options": [
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness.",
            "Current merge policy in inventory reconciliation service mismatches merge ambiguity for non-commutative operations, causing incorrect convergence."
          ],
          "correct": 3,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For inventory reconciliation service reports incidents around merge ambiguity for non-commutative operations, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Start from \"scenario: inventory reconciliation service reports incidents around merge ambiguity for\", then pressure-test the result against the options. Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under cost constraints?",
          "options": [
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Escalate unresolved conflicts to explicit user/business resolution flow for high-risk data.",
            "Disable conflict detection to reduce write latency."
          ],
          "correct": 2,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change under cost constraints, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "The decision turns on \"after confirming diagnosis, what is the strongest next change under cost constraints\". Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "This prompt is really about \"conflict Resolution & Convergence\". Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-058",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: chat thread state projector reports incidents around compensation event arriving late. What is the primary diagnosis?",
          "options": [
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness.",
            "Current merge policy in chat thread state projector mismatches compensation event arriving late, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists."
          ],
          "correct": 2,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For chat thread state projector reports incidents around compensation event arriving late, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "Use \"scenario: chat thread state projector reports incidents around compensation event\" as your starting point, then verify tradeoffs carefully. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. Common pitfall: consumer lag growth under burst traffic."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change during backfill replay?",
          "options": [
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Partition entities by conflict profile and apply tailored merge policy per class.",
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only."
          ],
          "correct": 1,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change during backfill replay, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "The core signal here is \"after confirming diagnosis, what is the strongest next change during backfill replay\". Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "The decision turns on \"conflict Resolution & Convergence\". Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-059",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: feature-flag state distribution reports incidents around partial convergence under retry backoff. What is the primary diagnosis?",
          "options": [
            "Replay handling is independent from merge correctness.",
            "Current merge policy in feature-flag state distribution mismatches partial convergence under retry backoff, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome."
          ],
          "correct": 1,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For feature-flag state distribution reports incidents around partial convergence under retry backoff, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Read this as a scenario about \"scenario: feature-flag state distribution reports incidents around partial convergence\". Do not reset assumptions between stages; carry forward prior constraints directly. The strongest answer explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: assuming recovery speed without operational proof."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while reducing unresolved-conflict backlog?",
          "options": [
            "Record causal history needed for conflict explanation and auditability.",
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup."
          ],
          "correct": 0,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change while reducing unresolved-conflict backlog, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "The key clue in this question is \"after confirming diagnosis, what is the strongest next change while reducing\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "Read this as a scenario about \"conflict Resolution & Convergence\". Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-060",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: multi-region settings service reports incidents around idempotency gap in merge handlers. What is the primary diagnosis?",
          "options": [
            "Current merge policy in multi-region settings service mismatches idempotency gap in merge handlers, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness."
          ],
          "correct": 0,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For multi-region settings service reports incidents around idempotency gap in merge handlers, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "Read this as a scenario about \"scenario: multi-region settings service reports incidents around idempotency gap in\". Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with canary-safe migration controls?",
          "options": [
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Define compensation ordering semantics so late compensations cannot corrupt newer state."
          ],
          "correct": 3,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change with canary-safe migration controls, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "The key clue in this question is \"after confirming diagnosis, what is the strongest next change with canary-safe\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "Read this as a scenario about \"conflict Resolution & Convergence\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-061",
      "type": "multi-select",
      "question": "Why can global last-write-wins be dangerous? (Select all that apply)",
      "options": [
        "Can silently drop valid concurrent intent",
        "Depends on skewed wall-clock order",
        "Always preserves domain invariants",
        "Can mask business-critical conflicts"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "LWW is simple but often unsafe for invariant-critical or semantically rich fields.",
      "detailedExplanation": "The decision turns on \"global last-write-wins be dangerous? (Select all that apply)\". Avoid pattern guessing and evaluate each candidate directly against the scenario. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-062",
      "type": "multi-select",
      "question": "CRDT-style approaches are best suited for which? (Select all that apply)",
      "options": [
        "Commutative/associative state updates",
        "Convergence without central coordination",
        "Arbitrary non-commutative financial transfers",
        "High-replay distributed updates"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "CRDTs fit naturally convergent data types, not all business operations.",
      "detailedExplanation": "Start from \"cRDT-style approaches are best suited for which? (Select all that apply)\", then pressure-test the result against the options. Avoid pattern guessing and evaluate each candidate directly against the scenario. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-063",
      "type": "multi-select",
      "question": "Replay-safe merge handlers should include which? (Select all that apply)",
      "options": [
        "Idempotency keys",
        "Version/causal checks",
        "Blind overwrite on duplicate events",
        "Deterministic merge output"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Replay safety requires dedupe, ordering checks, and deterministic behavior.",
      "detailedExplanation": "The key clue in this question is \"replay-safe merge handlers should include which? (Select all that apply)\". Validate each option independently; do not select statements that are only partially true. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-064",
      "type": "multi-select",
      "question": "Useful conflict observability includes which? (Select all that apply)",
      "options": [
        "Conflict rate by entity/field",
        "Unresolved conflict age",
        "Only host CPU",
        "Convergence latency distribution"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Conflict operations need direct visibility into rate, age, and convergence timing.",
      "detailedExplanation": "The core signal here is \"useful conflict observability includes which? (Select all that apply)\". Avoid pattern guessing and evaluate each candidate directly against the scenario. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-065",
      "type": "multi-select",
      "question": "When should conflicts escalate to manual/business resolution? (Select all that apply)",
      "options": [
        "Invariant-critical data with ambiguous merge",
        "High-value financial/contract fields",
        "Low-risk commutative counters",
        "Irreconcilable concurrent updates"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Manual escalation is for ambiguous/high-risk conflicts where automation is unsafe.",
      "detailedExplanation": "If you keep \"conflicts escalate to manual/business resolution? (Select all that apply)\" in view, the correct answer separates faster. Treat every option as a separate true/false test under the same constraints. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-066",
      "type": "multi-select",
      "question": "Compensation events can corrupt state unless which are true? (Select all that apply)",
      "options": [
        "Compensations are ordered/validated against current version",
        "Late compensation cannot overwrite newer accepted state",
        "Compensations bypass merge checks",
        "Compensation handlers are idempotent"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Compensations require ordering and idempotent safeguards against stale overwrites.",
      "detailedExplanation": "This prompt is really about \"compensation events can corrupt state unless which are true? (Select all that apply)\". Avoid pattern guessing and evaluate each candidate directly against the scenario. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-067",
      "type": "multi-select",
      "question": "Convergence policy by entity class should consider which? (Select all that apply)",
      "options": [
        "Business criticality",
        "Update concurrency profile",
        "One policy for all entities always",
        "Commutativity of operations"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Entity-specific policy improves correctness/cost balance.",
      "detailedExplanation": "Use \"convergence policy by entity class should consider which? (Select all that apply)\" as your starting point, then verify tradeoffs carefully. Treat every option as a separate true/false test under the same constraints. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-068",
      "type": "multi-select",
      "question": "Signs merge policy is insufficient include which? (Select all that apply)",
      "options": [
        "Recurring state reverted incidents",
        "Large unresolved conflict backlog",
        "Stable convergence SLO with low anomaly rates",
        "Support escalations on lost updates"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Reversions, backlog, and escalations indicate merge policy mismatch.",
      "detailedExplanation": "Read this as a scenario about \"signs merge policy is insufficient include which? (Select all that apply)\". Validate each option independently; do not select statements that are only partially true. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-069",
      "type": "multi-select",
      "question": "To keep convergence explainable, which are useful? (Select all that apply)",
      "options": [
        "Persist merge decision metadata",
        "Expose conflict reason codes",
        "Delete conflicting evidence to simplify logs",
        "Trace causal/version lineage"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Explainability requires durable metadata and lineage visibility.",
      "detailedExplanation": "The decision turns on \"to keep convergence explainable, which are useful? (Select all that apply)\". Avoid pattern guessing and evaluate each candidate directly against the scenario. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-070",
      "type": "multi-select",
      "question": "Which anti-patterns often break eventual convergence? (Select all that apply)",
      "options": [
        "Non-idempotent replay handlers",
        "Hidden schema-dependent merge assumptions",
        "Deterministic merge functions",
        "Ignoring causal metadata in updates"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Replay/causal blind spots and hidden assumptions cause drift.",
      "detailedExplanation": "Use \"anti-patterns often break eventual convergence? (Select all that apply)\" as your starting point, then verify tradeoffs carefully. Validate each option independently; do not select statements that are only partially true. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-071",
      "type": "multi-select",
      "question": "When stronger coordination is preferable to merge logic alone? (Select all that apply)",
      "options": [
        "Hard invariants with high failure cost",
        "Financial transfer uniqueness constraints",
        "Low-risk social counters",
        "Operations that cannot be safely commuted"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Some invariants require stronger coordination than eventual merge semantics.",
      "detailedExplanation": "This prompt is really about \"stronger coordination is preferable to merge logic alone? (Select all that apply)\". Avoid pattern guessing and evaluate each candidate directly against the scenario. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-072",
      "type": "multi-select",
      "question": "Good migration practices for new merge semantics include which? (Select all that apply)",
      "options": [
        "Canary by entity segment",
        "Dual-path validation metrics",
        "Big-bang cutover with no fallback",
        "Rollback criteria for anomaly spikes"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Staged rollout and rollback guardrails reduce migration risk.",
      "detailedExplanation": "If you keep \"good migration practices for new merge semantics include which? (Select all that apply)\" in view, the correct answer separates faster. Treat every option as a separate true/false test under the same constraints. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-073",
      "type": "multi-select",
      "question": "Conflict-resolution SLOs can include which? (Select all that apply)",
      "options": [
        "Max unresolved conflict age",
        "Convergence latency percentile",
        "Only total write QPS",
        "Conflict-loss incident count"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "SLOs should target conflict handling quality, not just throughput.",
      "detailedExplanation": "The core signal here is \"conflict-resolution SLOs can include which? (Select all that apply)\". Validate each option independently; do not select statements that are only partially true. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-074",
      "type": "multi-select",
      "question": "Which fields are often good CRDT candidates? (Select all that apply)",
      "options": [
        "Set membership preferences",
        "Grow-only counters with semantics",
        "Single authoritative legal contract term",
        "Commutative tag updates"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "CRDT fit is strongest for commutative/idempotent state types.",
      "detailedExplanation": "The key clue in this question is \"fields are often good CRDT candidates? (Select all that apply)\". Avoid pattern guessing and evaluate each candidate directly against the scenario. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-075",
      "type": "multi-select",
      "question": "To prevent stale replay overwrite, which controls are useful? (Select all that apply)",
      "options": [
        "Monotonic version guards",
        "Compare-and-set semantics",
        "Accept any later-arrival timestamp blindly",
        "Dedupe state with expiry policy"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Monotonic/CAS + dedupe protects newer state against stale replays.",
      "detailedExplanation": "Start from \"to prevent stale replay overwrite, which controls are useful? (Select all that apply)\", then pressure-test the result against the options. Avoid pattern guessing and evaluate each candidate directly against the scenario. Cache design quality is mostly about correctness boundaries, not only hit rate. Common pitfall: invalidation races under concurrent writes.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-076",
      "type": "multi-select",
      "question": "For offline-first clients, which safeguards improve merge outcomes? (Select all that apply)",
      "options": [
        "Client operation IDs",
        "Server-side conflict classification",
        "Blind overwrite on reconnect",
        "User-visible conflict UI for critical fields"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Offline sync needs operation identity, server classification, and user-visible fallback.",
      "detailedExplanation": "The decision turns on \"for offline-first clients, which safeguards improve merge outcomes? (Select all that\". Validate each option independently; do not select statements that are only partially true. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-077",
      "type": "multi-select",
      "question": "Which can reduce unresolved conflict backlog? (Select all that apply)",
      "options": [
        "Domain-specific auto-merge improvements",
        "Priority triage for high-risk entities",
        "Ignoring aged conflicts indefinitely",
        "Clear ownership for manual resolution queues"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Backlog reduction requires better auto-merge and accountable resolution workflows.",
      "detailedExplanation": "Read this as a scenario about \"reduce unresolved conflict backlog? (Select all that apply)\". Avoid pattern guessing and evaluate each candidate directly against the scenario. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-078",
      "type": "numeric-input",
      "question": "A system processes 3,600,000 updates/day with conflict rate 0.8%. Conflicts/day?",
      "answer": 28800,
      "unit": "updates",
      "tolerance": 0.03,
      "explanation": "0.008*3,600,000=28,800.",
      "detailedExplanation": "Use \"system processes 3,600,000 updates/day with conflict rate 0\" as your starting point, then verify tradeoffs carefully. Normalize units before computing so conversion mistakes do not propagate. Strong answers connect quorum/coordination settings to concrete correctness goals. If values like 3,600 and 000 appear, convert them into one unit basis before comparison. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-079",
      "type": "numeric-input",
      "question": "Unresolved conflicts are 12,000 with resolver throughput 150/min. Minutes to clear backlog (no new conflicts)?",
      "answer": 80,
      "unit": "minutes",
      "tolerance": 0,
      "explanation": "12,000/150=80.",
      "detailedExplanation": "This prompt is really about \"unresolved conflicts are 12,000 with resolver throughput 150/min\". Write the unit conversion path explicitly, then calculate, then sanity-check magnitude. Consistency decisions should be explicit about which conflicts are acceptable and why. Numbers such as 12,000 and 150 should be normalized first so downstream reasoning stays consistent. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-080",
      "type": "numeric-input",
      "question": "Replay duplicate rate is 1.6% on 950,000 events/day. Duplicate events/day?",
      "answer": 15200,
      "unit": "events",
      "tolerance": 0.03,
      "explanation": "0.016*950,000=15,200.",
      "detailedExplanation": "This prompt is really about \"replay duplicate rate is 1\". Write the unit conversion path explicitly, then calculate, then sanity-check magnitude. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Numbers such as 1.6 and 950,000 should be normalized first so downstream reasoning stays consistent. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-081",
      "type": "numeric-input",
      "question": "Conflict auto-resolve succeeds for 91% of 40,000 conflicts/day. Manual conflicts/day?",
      "answer": 3600,
      "unit": "conflicts",
      "tolerance": 0.03,
      "explanation": "9% of 40,000 = 3,600.",
      "detailedExplanation": "Use \"conflict auto-resolve succeeds for 91% of 40,000 conflicts/day\" as your starting point, then verify tradeoffs carefully. Normalize units before computing so conversion mistakes do not propagate. Consistency decisions should be explicit about which conflicts are acceptable and why. If values like 91 and 40,000 appear, convert them into one unit basis before comparison. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-082",
      "type": "numeric-input",
      "question": "Convergence p95 is 28s, SLO target is 20s. Percent over target?",
      "answer": 40,
      "unit": "%",
      "tolerance": 0.3,
      "explanation": "(28-20)/20=40%.",
      "detailedExplanation": "The core signal here is \"convergence p95 is 28s, SLO target is 20s\". Normalize units before computing so conversion mistakes do not propagate. Tie the decision to concrete operational outcomes, not abstract reliability language. If values like 28s and 20s appear, convert them into one unit basis before comparison. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "Percentile",
          "url": "https://en.wikipedia.org/wiki/Percentile"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-083",
      "type": "numeric-input",
      "question": "A merge metadata field adds 36 bytes/update at 55,000 updates/sec. Extra MB/sec (decimal)?",
      "answer": 1.98,
      "unit": "MB/sec",
      "tolerance": 0.08,
      "explanation": "55,000*36=1,980,000 bytes/sec = 1.98 MB/sec.",
      "detailedExplanation": "If you keep \"merge metadata field adds 36 bytes/update at 55,000 updates/sec\" in view, the correct answer separates faster. Keep every transformation in one unit system and check order of magnitude at the end. Strong answers connect quorum/coordination settings to concrete correctness goals. Keep quantities like 36 and 55,000 in aligned units before selecting an answer. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-084",
      "type": "numeric-input",
      "question": "LWW-loss incidents fell from 260/week to 52/week. Percent reduction?",
      "answer": 80,
      "unit": "%",
      "tolerance": 0.2,
      "explanation": "(260-52)/260=80%.",
      "detailedExplanation": "Start from \"lWW-loss incidents fell from 260/week to 52/week\", then pressure-test the result against the options. Normalize units before computing so conversion mistakes do not propagate. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. If values like 260 and 52 appear, convert them into one unit basis before comparison. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-085",
      "type": "numeric-input",
      "question": "Conflict-check path adds 12ms to 35% of 18,000 req/sec. Added req-ms per second?",
      "answer": 75600,
      "unit": "req-ms/sec",
      "tolerance": 0.03,
      "explanation": "18,000*0.35*12 = 75,600 req-ms/sec.",
      "detailedExplanation": "The key clue in this question is \"conflict-check path adds 12ms to 35% of 18,000 req/sec\". Keep every transformation in one unit system and check order of magnitude at the end. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Keep quantities like 12ms and 35 in aligned units before selecting an answer. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-086",
      "type": "numeric-input",
      "question": "If 14% of 120,000 writes/min require strong coordination fallback, fallback writes/min?",
      "answer": 16800,
      "unit": "writes/min",
      "tolerance": 0.02,
      "explanation": "0.14*120,000=16,800.",
      "detailedExplanation": "Read this as a scenario about \"if 14% of 120,000 writes/min require strong coordination fallback, fallback writes/min\". Normalize units before computing so conversion mistakes do not propagate. Consistency decisions should be explicit about which conflicts are acceptable and why. If values like 14 and 120,000 appear, convert them into one unit basis before comparison. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-087",
      "type": "numeric-input",
      "question": "Divergence-alert threshold is 15 minutes; current median unresolved age is 9 minutes. Remaining budget?",
      "answer": 6,
      "unit": "minutes",
      "tolerance": 0,
      "explanation": "15-9=6 minutes.",
      "detailedExplanation": "The decision turns on \"divergence-alert threshold is 15 minutes\". Keep every transformation in one unit system and check order of magnitude at the end. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Keep quantities like 15 minutes and 9 minutes in aligned units before selecting an answer. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-088",
      "type": "numeric-input",
      "question": "A conflict queue receives 480 items/min and resolves 530/min. Net drain rate?",
      "answer": 50,
      "unit": "items/min",
      "tolerance": 0,
      "explanation": "530-480=50 drained per minute.",
      "detailedExplanation": "This prompt is really about \"conflict queue receives 480 items/min and resolves 530/min\". Write the unit conversion path explicitly, then calculate, then sanity-check magnitude. Throughput is only one part; replay behavior and consumer lag handling matter equally. Numbers such as 480 and 530 should be normalized first so downstream reasoning stays consistent. Common pitfall: consumer lag growth under burst traffic.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-089",
      "type": "numeric-input",
      "question": "Compensation misorder incidents are 0.12% of 2,500,000 events/day. Incidents/day?",
      "answer": 3000,
      "unit": "events",
      "tolerance": 0.03,
      "explanation": "0.0012*2,500,000=3,000.",
      "detailedExplanation": "Use \"compensation misorder incidents are 0\" as your starting point, then verify tradeoffs carefully. Normalize units before computing so conversion mistakes do not propagate. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. If values like 0.12 and 2,500 appear, convert them into one unit basis before comparison. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-090",
      "type": "ordering",
      "question": "Order a robust conflict-resolution workflow.",
      "items": [
        "Detect/label conflict type",
        "Apply domain merge policy",
        "Validate resulting invariants",
        "Escalate unresolved high-risk conflicts"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Classify, merge, validate, then escalate if unsafe.",
      "detailedExplanation": "If you keep \"order a robust conflict-resolution workflow\" in view, the correct answer separates faster. Order by relative scale and bottleneck effect, then validate neighboring items. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-091",
      "type": "ordering",
      "question": "Order by increasing overwrite risk.",
      "items": [
        "CAS with version check",
        "Merge with causal metadata",
        "LWW with synchronized clocks assumption",
        "Blind last-arrival overwrite"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Risk rises as causal/version safeguards are removed.",
      "detailedExplanation": "The core signal here is \"order by increasing overwrite risk\". Build the rank from biggest differences first, then refine with adjacent checks. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-092",
      "type": "ordering",
      "question": "Order convergence migration safety.",
      "items": [
        "Canary entity subset",
        "Dual-path compare metrics",
        "Progressive expansion",
        "Retire legacy merge path"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Safe migration uses staged rollout with metric comparison.",
      "detailedExplanation": "Use \"order convergence migration safety\" as your starting point, then verify tradeoffs carefully. Build the rank from biggest differences first, then refine with adjacent checks. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-093",
      "type": "ordering",
      "question": "Order by increasing manual effort.",
      "items": [
        "Deterministic auto-merge",
        "Policy-based merge + occasional review",
        "Frequent manual triage queue",
        "All conflicts manually resolved"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Manual burden rises as automation quality decreases.",
      "detailedExplanation": "This prompt is really about \"order by increasing manual effort\". Order by relative scale and bottleneck effect, then validate neighboring items. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-094",
      "type": "ordering",
      "question": "Order replay protection strength.",
      "items": [
        "Timestamp compare only",
        "Idempotency key check",
        "Idempotency + version monotonic guard",
        "Idempotency + version + causal dependency checks"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Replay safety improves with layered checks.",
      "detailedExplanation": "The decision turns on \"order replay protection strength\". Place obvious extremes first, then sort the middle by pairwise comparison. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-095",
      "type": "ordering",
      "question": "Order by strongest evidence of convergence health.",
      "items": [
        "Low average latency only",
        "Low conflict rate only",
        "Low conflict + low unresolved age",
        "Low conflict + low unresolved age + low loss incidents"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Strong evidence combines rate, age, and correctness outcomes.",
      "detailedExplanation": "Read this as a scenario about \"order by strongest evidence of convergence health\". Build the rank from biggest differences first, then refine with adjacent checks. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-096",
      "type": "ordering",
      "question": "Order conflict policy granularity from coarsest to finest.",
      "items": [
        "Single global merge rule",
        "Per-service merge rule",
        "Per-entity merge rule",
        "Per-field/entity merge rule with escalation paths"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Finer policy granularity better matches domain semantics.",
      "detailedExplanation": "The key clue in this question is \"order conflict policy granularity from coarsest to finest\". Build the rank from biggest differences first, then refine with adjacent checks. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-097",
      "type": "ordering",
      "question": "Order by suitability for commutative updates.",
      "items": [
        "Blind overwrite",
        "Timestamp LWW",
        "Set/counter CRDT merge",
        "Domain-specific commutative CRDT + audit trail"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Commutative semantics become stronger and safer with explicit CRDT policy.",
      "detailedExplanation": "Start from \"order by suitability for commutative updates\", then pressure-test the result against the options. Order by relative scale and bottleneck effect, then validate neighboring items. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-098",
      "type": "ordering",
      "question": "Order incident response for divergence spike.",
      "items": [
        "Scope affected entities",
        "Contain risky writes/paths",
        "Apply merge/replay fix",
        "Add recurrence guardrails and tests"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Scope, contain, fix, and harden.",
      "detailedExplanation": "If you keep \"order incident response for divergence spike\" in view, the correct answer separates faster. Place obvious extremes first, then sort the middle by pairwise comparison. Tie the decision to concrete operational outcomes, not abstract reliability language. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-099",
      "type": "ordering",
      "question": "Order by increasing operational complexity. (Conflict Resolution & Convergence context C)",
      "items": [
        "Simple LWW policy",
        "Entity-tiered merge policy",
        "Entity-tiered + causal metadata",
        "Entity-tiered + causal + manual escalation workflows"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Complexity grows with metadata richness and workflow depth.",
      "detailedExplanation": "The core signal here is \"order by increasing operational complexity\". Build the rank from biggest differences first, then refine with adjacent checks. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-100",
      "type": "ordering",
      "question": "Order by increasing guarantee strength against silent data loss.",
      "items": [
        "Best-effort overwrite",
        "LWW with timestamps",
        "Versioned deterministic merges",
        "Versioned deterministic merges + invariant validation + escalation"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Silent-loss protection improves with explicit checks and escalation.",
      "detailedExplanation": "Use \"order by increasing guarantee strength against silent data loss\" as your starting point, then verify tradeoffs carefully. Order by relative scale and bottleneck effect, then validate neighboring items. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    }
  ]
}
