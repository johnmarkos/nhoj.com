{
  "unit": 8,
  "unitTitle": "Consistency & Coordination",
  "chapter": 7,
  "chapterTitle": "Conflict Resolution & Convergence",
  "chapterDescription": "Designing merge semantics and replay-safe conflict handling for eventually consistent systems with concurrent updates.",
  "problems": [
    {
      "id": "cc-cr-001",
      "type": "multiple-choice",
      "question": "A user profile merge service is facing concurrent updates to same field. Which conflict-resolution/convergence decision is strongest? Recent partition tests exposed merge ambiguity.",
      "options": [
        "Use domain-specific merge semantics instead of global last-write-wins for critical fields.",
        "Standardize conflict resolution on last-write-wins across entities to simplify merge semantics and operations.",
        "Drop unresolved conflicting updates from hot paths and rely on periodic reconciliation to correct drift.",
        "Prioritize replayed events over stored state to speed recovery, then reconcile ordering anomalies in background jobs."
      ],
      "correct": 0,
      "explanation": "Given the observed bottleneck and guardrails, convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A user profile merge service is facing concurrent updates to same field, this is the strongest fit in Conflict Resolution & Convergence.",
      "detailedExplanation": "Generalize from user profile merge service is facing concurrent updates to same field to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Prefer the approach that keeps ordering/acknowledgment behavior predictable under failure. A good message-system answer defines guarantees clearly for both producer and consumer paths. Common pitfall: assuming exactly-once without idempotency.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-002",
      "type": "multiple-choice",
      "question": "A collaborative doc state store is facing offline edits arriving out of order. Which conflict-resolution/convergence decision is strongest? User trust impact is high for this data class.",
      "options": [
        "Standardize conflict resolution on last-write-wins across entities to simplify merge semantics and operations.",
        "Drop unresolved conflicting updates from hot paths and rely on periodic reconciliation to correct drift.",
        "Prioritize replayed events over stored state to speed recovery, then reconcile ordering anomalies in background jobs.",
        "Use version/vector metadata to detect concurrency and drive deterministic merge decisions."
      ],
      "correct": 3,
      "explanation": "From an incident-first perspective, convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A collaborative doc state store is facing offline edits arriving out of order, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Prefer the approach that preserves correctness guarantees for the stated consistency boundary. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-003",
      "type": "multiple-choice",
      "question": "A shopping cart sync backend is facing divergent region writes after partition. Which conflict-resolution/convergence decision is strongest? The system handles offline-first clients at scale.",
      "options": [
        "Drop unresolved conflicting updates from hot paths and rely on periodic reconciliation to correct drift.",
        "Prioritize replayed events over stored state to speed recovery, then reconcile ordering anomalies in background jobs.",
        "Use CRDT-style commutative structures where business semantics allow safe convergence.",
        "Standardize conflict resolution on last-write-wins across entities to simplify merge semantics and operations."
      ],
      "correct": 2,
      "explanation": "Under the stated reliability and cost constraints, convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A shopping cart sync backend is facing divergent region writes after partition, this is the strongest fit in Conflict Resolution & Convergence.",
      "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Reject approaches that ignore delivery semantics or backpressure behavior. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. Common pitfall: consumer lag growth under burst traffic.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-004",
      "type": "multiple-choice",
      "question": "A inventory reconciliation service is facing duplicate event replay with stale payload. Which conflict-resolution/convergence decision is strongest? Current LWW behavior caused silent field loss.",
      "options": [
        "Prioritize replayed events over stored state to speed recovery, then reconcile ordering anomalies in background jobs.",
        "Make merge handlers idempotent and replay-safe with dedupe/version guards.",
        "Standardize conflict resolution on last-write-wins across entities to simplify merge semantics and operations.",
        "Drop unresolved conflicting updates from hot paths and rely on periodic reconciliation to correct drift."
      ],
      "correct": 1,
      "explanation": "Prioritizing blast-radius reduction first, convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A inventory reconciliation service is facing duplicate event replay with stale payload, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Discard options that weaken contract clarity or compatibility over time. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-005",
      "type": "multiple-choice",
      "question": "A chat thread state projector is facing last-write-wins data loss risk. Which conflict-resolution/convergence decision is strongest? Replay rates increased after retry-policy changes.",
      "options": [
        "Escalate unresolved conflicts to explicit user/business resolution flow for high-risk data.",
        "Standardize conflict resolution on last-write-wins across entities to simplify merge semantics and operations.",
        "Drop unresolved conflicting updates from hot paths and rely on periodic reconciliation to correct drift.",
        "Prioritize replayed events over stored state to speed recovery, then reconcile ordering anomalies in background jobs."
      ],
      "correct": 0,
      "explanation": "With latency and correctness objectives explicit, convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A chat thread state projector is facing last-write-wins data loss risk, this is the strongest fit in Conflict Resolution & Convergence.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Prioritize the approach that best protects reliability objectives under stated failure conditions. Tie decisions to concrete operational outcomes, not abstract reliability language. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Retry pattern",
          "url": "https://learn.microsoft.com/en-us/azure/architecture/patterns/retry"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-006",
      "type": "multiple-choice",
      "question": "A feature-flag state distribution is facing merge ambiguity for non-commutative operations. Which conflict-resolution/convergence decision is strongest? Auditability requirements now include conflict rationale.",
      "options": [
        "Standardize conflict resolution on last-write-wins across entities to simplify merge semantics and operations.",
        "Drop unresolved conflicting updates from hot paths and rely on periodic reconciliation to correct drift.",
        "Prioritize replayed events over stored state to speed recovery, then reconcile ordering anomalies in background jobs.",
        "Partition entities by conflict profile and apply tailored merge policy per class."
      ],
      "correct": 3,
      "explanation": "Looking at rollback safety and operational load, convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A feature-flag state distribution is facing merge ambiguity for non-commutative operations, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Eliminate approaches that hand-wave conflict resolution or quorum behavior. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-007",
      "type": "multiple-choice",
      "question": "A multi-region settings service is facing compensation event arriving late. Which conflict-resolution/convergence decision is strongest? Business requires deterministic merge outcomes.",
      "options": [
        "Drop unresolved conflicting updates from hot paths and rely on periodic reconciliation to correct drift.",
        "Prioritize replayed events over stored state to speed recovery, then reconcile ordering anomalies in background jobs.",
        "Record causal history needed for conflict explanation and auditability.",
        "Standardize conflict resolution on last-write-wins across entities to simplify merge semantics and operations."
      ],
      "correct": 2,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A multi-region settings service is facing compensation event arriving late, this is the strongest fit in Conflict Resolution & Convergence.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Reject designs that improve throughput while weakening reliability guarantees. Throughput is only one part; replay behavior and consumer lag handling matter equally. Common pitfall: ordering loss during partition or replay changes.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-008",
      "type": "multiple-choice",
      "question": "A ad campaign config sync is facing partial convergence under retry backoff. Which conflict-resolution/convergence decision is strongest? Some fields are commutative; others are not.",
      "options": [
        "Prioritize replayed events over stored state to speed recovery, then reconcile ordering anomalies in background jobs.",
        "Define compensation ordering semantics so late compensations cannot corrupt newer state.",
        "Standardize conflict resolution on last-write-wins across entities to simplify merge semantics and operations.",
        "Drop unresolved conflicting updates from hot paths and rely on periodic reconciliation to correct drift."
      ],
      "correct": 1,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A ad campaign config sync is facing partial convergence under retry backoff, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Prefer approaches that directly address failure mode, recovery path, and blast radius. Tie decisions to concrete operational outcomes, not abstract reliability language. Common pitfall: meeting average goals while missing tail-risk.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Retry pattern",
          "url": "https://learn.microsoft.com/en-us/azure/architecture/patterns/retry"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-009",
      "type": "multiple-choice",
      "question": "A identity claim convergence pipeline is facing idempotency gap in merge handlers. Which conflict-resolution/convergence decision is strongest? The team needs a safe first migration step.",
      "options": [
        "Bound eventual convergence windows and alert on prolonged divergence.",
        "Standardize conflict resolution on last-write-wins across entities to simplify merge semantics and operations.",
        "Drop unresolved conflicting updates from hot paths and rely on periodic reconciliation to correct drift.",
        "Prioritize replayed events over stored state to speed recovery, then reconcile ordering anomalies in background jobs."
      ],
      "correct": 0,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A identity claim convergence pipeline is facing idempotency gap in merge handlers, this is the strongest fit in Conflict Resolution & Convergence.",
      "detailedExplanation": "Generalize from identity claim convergence pipeline is facing idempotency gap in merge handlers to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Eliminate approaches that hand-wave conflict resolution or quorum behavior. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-010",
      "type": "multiple-choice",
      "question": "A ticket reservation reconciliation is facing conflicting business rule updates. Which conflict-resolution/convergence decision is strongest? Current event payload lacks explicit causality metadata.",
      "options": [
        "Standardize conflict resolution on last-write-wins across entities to simplify merge semantics and operations.",
        "Drop unresolved conflicting updates from hot paths and rely on periodic reconciliation to correct drift.",
        "Prioritize replayed events over stored state to speed recovery, then reconcile ordering anomalies in background jobs.",
        "Protect invariant-critical writes with stronger coordination, leaving tolerant fields convergent."
      ],
      "correct": 3,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A ticket reservation reconciliation is facing conflicting business rule updates, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Discard options that weaken contract clarity or compatibility over time. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-011",
      "type": "multiple-choice",
      "question": "A billing adjustment merger is facing concurrent updates to same field. Which conflict-resolution/convergence decision is strongest? Conflict incidents are intermittent but high impact.",
      "options": [
        "Drop unresolved conflicting updates from hot paths and rely on periodic reconciliation to correct drift.",
        "Prioritize replayed events over stored state to speed recovery, then reconcile ordering anomalies in background jobs.",
        "Use domain-specific merge semantics instead of global last-write-wins for critical fields.",
        "Standardize conflict resolution on last-write-wins across entities to simplify merge semantics and operations."
      ],
      "correct": 2,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A billing adjustment merger is facing concurrent updates to same field, this is the strongest fit in Conflict Resolution & Convergence.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Eliminate approaches that hand-wave conflict resolution or quorum behavior. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-012",
      "type": "multiple-choice",
      "question": "A notification state converger is facing offline edits arriving out of order. Which conflict-resolution/convergence decision is strongest? Compensation events can arrive significantly late.",
      "options": [
        "Prioritize replayed events over stored state to speed recovery, then reconcile ordering anomalies in background jobs.",
        "Use version/vector metadata to detect concurrency and drive deterministic merge decisions.",
        "Standardize conflict resolution on last-write-wins across entities to simplify merge semantics and operations.",
        "Drop unresolved conflicting updates from hot paths and rely on periodic reconciliation to correct drift."
      ],
      "correct": 1,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A notification state converger is facing offline edits arriving out of order, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "Generalize from notification state converger is facing offline edits arriving out of order to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Prefer the approach that preserves correctness guarantees for the stated consistency boundary. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-013",
      "type": "multiple-choice",
      "question": "A comment thread merge service is facing divergent region writes after partition. Which conflict-resolution/convergence decision is strongest? Cross-device edits frequently race in production.",
      "options": [
        "Use CRDT-style commutative structures where business semantics allow safe convergence.",
        "Standardize conflict resolution on last-write-wins across entities to simplify merge semantics and operations.",
        "Drop unresolved conflicting updates from hot paths and rely on periodic reconciliation to correct drift.",
        "Prioritize replayed events over stored state to speed recovery, then reconcile ordering anomalies in background jobs."
      ],
      "correct": 0,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A comment thread merge service is facing divergent region writes after partition, this is the strongest fit in Conflict Resolution & Convergence.",
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Reject designs that improve throughput while weakening reliability guarantees. A good message-system answer defines guarantees clearly for both producer and consumer paths. Common pitfall: consumer lag growth under burst traffic.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-014",
      "type": "multiple-choice",
      "question": "A offline-first mobile sync API is facing duplicate event replay with stale payload. Which conflict-resolution/convergence decision is strongest? Schema evolution introduced merge policy drift.",
      "options": [
        "Standardize conflict resolution on last-write-wins across entities to simplify merge semantics and operations.",
        "Drop unresolved conflicting updates from hot paths and rely on periodic reconciliation to correct drift.",
        "Prioritize replayed events over stored state to speed recovery, then reconcile ordering anomalies in background jobs.",
        "Make merge handlers idempotent and replay-safe with dedupe/version guards."
      ],
      "correct": 3,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A offline-first mobile sync API is facing duplicate event replay with stale payload, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Discard options that weaken contract clarity or compatibility over time. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-015",
      "type": "multiple-choice",
      "question": "A catalog attribute merge path is facing last-write-wins data loss risk. Which conflict-resolution/convergence decision is strongest? Operators need visibility into unresolved conflicts.",
      "options": [
        "Drop unresolved conflicting updates from hot paths and rely on periodic reconciliation to correct drift.",
        "Prioritize replayed events over stored state to speed recovery, then reconcile ordering anomalies in background jobs.",
        "Escalate unresolved conflicts to explicit user/business resolution flow for high-risk data.",
        "Standardize conflict resolution on last-write-wins across entities to simplify merge semantics and operations."
      ],
      "correct": 2,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A catalog attribute merge path is facing last-write-wins data loss risk, this is the strongest fit in Conflict Resolution & Convergence.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Eliminate approaches that hand-wave conflict resolution or quorum behavior. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-016",
      "type": "multiple-choice",
      "question": "A fraud case state reconciler is facing merge ambiguity for non-commutative operations. Which conflict-resolution/convergence decision is strongest? Critical invariants must never be resolved by blind overwrite.",
      "options": [
        "Prioritize replayed events over stored state to speed recovery, then reconcile ordering anomalies in background jobs.",
        "Partition entities by conflict profile and apply tailored merge policy per class.",
        "Standardize conflict resolution on last-write-wins across entities to simplify merge semantics and operations.",
        "Drop unresolved conflicting updates from hot paths and rely on periodic reconciliation to correct drift."
      ],
      "correct": 1,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A fraud case state reconciler is facing merge ambiguity for non-commutative operations, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Eliminate approaches that hand-wave conflict resolution or quorum behavior. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-017",
      "type": "multiple-choice",
      "question": "A support ticket merge workflow is facing compensation event arriving late. Which conflict-resolution/convergence decision is strongest? Current merge code is difficult to reason about.",
      "options": [
        "Record causal history needed for conflict explanation and auditability.",
        "Standardize conflict resolution on last-write-wins across entities to simplify merge semantics and operations.",
        "Drop unresolved conflicting updates from hot paths and rely on periodic reconciliation to correct drift.",
        "Prioritize replayed events over stored state to speed recovery, then reconcile ordering anomalies in background jobs."
      ],
      "correct": 0,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A support ticket merge workflow is facing compensation event arriving late, this is the strongest fit in Conflict Resolution & Convergence.",
      "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Reject designs that improve throughput while weakening reliability guarantees. A good message-system answer defines guarantees clearly for both producer and consumer paths. Common pitfall: consumer lag growth under burst traffic.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-018",
      "type": "multiple-choice",
      "question": "A shipment status convergence service is facing partial convergence under retry backoff. Which conflict-resolution/convergence decision is strongest? Performance constraints discourage global strict coordination.",
      "options": [
        "Standardize conflict resolution on last-write-wins across entities to simplify merge semantics and operations.",
        "Drop unresolved conflicting updates from hot paths and rely on periodic reconciliation to correct drift.",
        "Prioritize replayed events over stored state to speed recovery, then reconcile ordering anomalies in background jobs.",
        "Define compensation ordering semantics so late compensations cannot corrupt newer state."
      ],
      "correct": 3,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A shipment status convergence service is facing partial convergence under retry backoff, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Prefer approaches that directly address failure mode, recovery path, and blast radius. Map the approach to measurable reliability impact such as error-budget burn and recovery behavior. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Retry pattern",
          "url": "https://learn.microsoft.com/en-us/azure/architecture/patterns/retry"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-019",
      "type": "multiple-choice",
      "question": "A membership preference sync store is facing idempotency gap in merge handlers. Which conflict-resolution/convergence decision is strongest? User-facing consistency SLOs were recently added.",
      "options": [
        "Drop unresolved conflicting updates from hot paths and rely on periodic reconciliation to correct drift.",
        "Prioritize replayed events over stored state to speed recovery, then reconcile ordering anomalies in background jobs.",
        "Bound eventual convergence windows and alert on prolonged divergence.",
        "Standardize conflict resolution on last-write-wins across entities to simplify merge semantics and operations."
      ],
      "correct": 2,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A membership preference sync store is facing idempotency gap in merge handlers, this is the strongest fit in Conflict Resolution & Convergence.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Eliminate approaches that hand-wave conflict resolution or quorum behavior. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-020",
      "type": "multiple-choice",
      "question": "A device configuration convergence backend is facing conflicting business rule updates. Which conflict-resolution/convergence decision is strongest? Downstream systems assume converged state within minutes.",
      "options": [
        "Prioritize replayed events over stored state to speed recovery, then reconcile ordering anomalies in background jobs.",
        "Protect invariant-critical writes with stronger coordination, leaving tolerant fields convergent.",
        "Standardize conflict resolution on last-write-wins across entities to simplify merge semantics and operations.",
        "Drop unresolved conflicting updates from hot paths and rely on periodic reconciliation to correct drift."
      ],
      "correct": 1,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A device configuration convergence backend is facing conflicting business rule updates, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Discard choices that violate required invariants during concurrent or failed states. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-021",
      "type": "multiple-choice",
      "question": "A user profile merge service is facing concurrent updates to same field. Which conflict-resolution/convergence decision is strongest? The platform supports dedupe keys and version checks.",
      "options": [
        "Use domain-specific merge semantics instead of global last-write-wins for critical fields.",
        "Standardize conflict resolution on last-write-wins across entities to simplify merge semantics and operations.",
        "Drop unresolved conflicting updates from hot paths and rely on periodic reconciliation to correct drift.",
        "Prioritize replayed events over stored state to speed recovery, then reconcile ordering anomalies in background jobs."
      ],
      "correct": 0,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A user profile merge service is facing concurrent updates to same field, this is the strongest fit in Conflict Resolution & Convergence.",
      "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-022",
      "type": "multiple-choice",
      "question": "A collaborative doc state store is facing offline edits arriving out of order. Which conflict-resolution/convergence decision is strongest? There is no current escalation path for irreconcilable conflicts.",
      "options": [
        "Standardize conflict resolution on last-write-wins across entities to simplify merge semantics and operations.",
        "Drop unresolved conflicting updates from hot paths and rely on periodic reconciliation to correct drift.",
        "Prioritize replayed events over stored state to speed recovery, then reconcile ordering anomalies in background jobs.",
        "Use version/vector metadata to detect concurrency and drive deterministic merge decisions."
      ],
      "correct": 3,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A collaborative doc state store is facing offline edits arriving out of order, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Eliminate approaches that hand-wave conflict resolution or quorum behavior. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-023",
      "type": "multiple-choice",
      "question": "A shopping cart sync backend is facing divergent region writes after partition. Which conflict-resolution/convergence decision is strongest? Some tenants tolerate delay but not silent data loss.",
      "options": [
        "Drop unresolved conflicting updates from hot paths and rely on periodic reconciliation to correct drift.",
        "Prioritize replayed events over stored state to speed recovery, then reconcile ordering anomalies in background jobs.",
        "Use CRDT-style commutative structures where business semantics allow safe convergence.",
        "Standardize conflict resolution on last-write-wins across entities to simplify merge semantics and operations."
      ],
      "correct": 2,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A shopping cart sync backend is facing divergent region writes after partition, this is the strongest fit in Conflict Resolution & Convergence.",
      "detailedExplanation": "Generalize from shopping cart sync backend is facing divergent region writes after partition to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Reject approaches that ignore delivery semantics or backpressure behavior. A good message-system answer defines guarantees clearly for both producer and consumer paths. Common pitfall: consumer lag growth under burst traffic.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-024",
      "type": "multiple-choice",
      "question": "A inventory reconciliation service is facing duplicate event replay with stale payload. Which conflict-resolution/convergence decision is strongest? Replay and reorder are common after failover.",
      "options": [
        "Prioritize replayed events over stored state to speed recovery, then reconcile ordering anomalies in background jobs.",
        "Make merge handlers idempotent and replay-safe with dedupe/version guards.",
        "Standardize conflict resolution on last-write-wins across entities to simplify merge semantics and operations.",
        "Drop unresolved conflicting updates from hot paths and rely on periodic reconciliation to correct drift."
      ],
      "correct": 1,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A inventory reconciliation service is facing duplicate event replay with stale payload, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Reject approaches that sound good in general but do not reduce concrete reliability risk. Map the approach to measurable reliability impact such as error-budget burn and recovery behavior. Common pitfall: meeting average goals while missing tail-risk.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-025",
      "type": "multiple-choice",
      "question": "A chat thread state projector is facing last-write-wins data loss risk. Which conflict-resolution/convergence decision is strongest? A prior patch reduced duplicates but increased drift.",
      "options": [
        "Escalate unresolved conflicts to explicit user/business resolution flow for high-risk data.",
        "Standardize conflict resolution on last-write-wins across entities to simplify merge semantics and operations.",
        "Drop unresolved conflicting updates from hot paths and rely on periodic reconciliation to correct drift.",
        "Prioritize replayed events over stored state to speed recovery, then reconcile ordering anomalies in background jobs."
      ],
      "correct": 0,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A chat thread state projector is facing last-write-wins data loss risk, this is the strongest fit in Conflict Resolution & Convergence.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Eliminate approaches that hand-wave conflict resolution or quorum behavior. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-026",
      "type": "multiple-choice",
      "question": "A feature-flag state distribution is facing merge ambiguity for non-commutative operations. Which conflict-resolution/convergence decision is strongest? The product now supports cross-region active-active writes.",
      "options": [
        "Standardize conflict resolution on last-write-wins across entities to simplify merge semantics and operations.",
        "Drop unresolved conflicting updates from hot paths and rely on periodic reconciliation to correct drift.",
        "Prioritize replayed events over stored state to speed recovery, then reconcile ordering anomalies in background jobs.",
        "Partition entities by conflict profile and apply tailored merge policy per class."
      ],
      "correct": 3,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A feature-flag state distribution is facing merge ambiguity for non-commutative operations, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Discard choices that violate required invariants during concurrent or failed states. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-027",
      "type": "multiple-choice",
      "question": "A multi-region settings service is facing compensation event arriving late. Which conflict-resolution/convergence decision is strongest? Business teams demand explicit merge policy documentation.",
      "options": [
        "Drop unresolved conflicting updates from hot paths and rely on periodic reconciliation to correct drift.",
        "Prioritize replayed events over stored state to speed recovery, then reconcile ordering anomalies in background jobs.",
        "Record causal history needed for conflict explanation and auditability.",
        "Standardize conflict resolution on last-write-wins across entities to simplify merge semantics and operations."
      ],
      "correct": 2,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A multi-region settings service is facing compensation event arriving late, this is the strongest fit in Conflict Resolution & Convergence.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Reject approaches that ignore delivery semantics or backpressure behavior. Throughput is only one part; replay behavior and consumer lag handling matter equally. Common pitfall: ordering loss during partition or replay changes.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-028",
      "type": "multiple-choice",
      "question": "A ad campaign config sync is facing partial convergence under retry backoff. Which conflict-resolution/convergence decision is strongest? Observability now tracks divergence duration by entity.",
      "options": [
        "Prioritize replayed events over stored state to speed recovery, then reconcile ordering anomalies in background jobs.",
        "Define compensation ordering semantics so late compensations cannot corrupt newer state.",
        "Standardize conflict resolution on last-write-wins across entities to simplify merge semantics and operations.",
        "Drop unresolved conflicting updates from hot paths and rely on periodic reconciliation to correct drift."
      ],
      "correct": 1,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A ad campaign config sync is facing partial convergence under retry backoff, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Prioritize the approach that best protects reliability objectives under stated failure conditions. A strong real-world approach explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Retry pattern",
          "url": "https://learn.microsoft.com/en-us/azure/architecture/patterns/retry"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-029",
      "type": "multiple-choice",
      "question": "A identity claim convergence pipeline is facing idempotency gap in merge handlers. Which conflict-resolution/convergence decision is strongest? Conflicts cluster around a few high-write fields.",
      "options": [
        "Bound eventual convergence windows and alert on prolonged divergence.",
        "Standardize conflict resolution on last-write-wins across entities to simplify merge semantics and operations.",
        "Drop unresolved conflicting updates from hot paths and rely on periodic reconciliation to correct drift.",
        "Prioritize replayed events over stored state to speed recovery, then reconcile ordering anomalies in background jobs."
      ],
      "correct": 0,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A identity claim convergence pipeline is facing idempotency gap in merge handlers, this is the strongest fit in Conflict Resolution & Convergence.",
      "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Eliminate approaches that hand-wave conflict resolution or quorum behavior. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-030",
      "type": "multiple-choice",
      "question": "A ticket reservation reconciliation is facing conflicting business rule updates. Which conflict-resolution/convergence decision is strongest? The migration must be canary-friendly and reversible.",
      "options": [
        "Standardize conflict resolution on last-write-wins across entities to simplify merge semantics and operations.",
        "Drop unresolved conflicting updates from hot paths and rely on periodic reconciliation to correct drift.",
        "Prioritize replayed events over stored state to speed recovery, then reconcile ordering anomalies in background jobs.",
        "Protect invariant-critical writes with stronger coordination, leaving tolerant fields convergent."
      ],
      "correct": 3,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A ticket reservation reconciliation is facing conflicting business rule updates, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Discard choices that violate required invariants during concurrent or failed states. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-031",
      "type": "multiple-choice",
      "question": "A billing adjustment merger is facing concurrent updates to same field. Which conflict-resolution/convergence decision is strongest? Client retries may re-send stale updates unexpectedly.",
      "options": [
        "Drop unresolved conflicting updates from hot paths and rely on periodic reconciliation to correct drift.",
        "Prioritize replayed events over stored state to speed recovery, then reconcile ordering anomalies in background jobs.",
        "Use domain-specific merge semantics instead of global last-write-wins for critical fields.",
        "Standardize conflict resolution on last-write-wins across entities to simplify merge semantics and operations."
      ],
      "correct": 2,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A billing adjustment merger is facing concurrent updates to same field, this is the strongest fit in Conflict Resolution & Convergence.",
      "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Prefer approaches that balance hit rate with clear staleness and invalidation behavior. Treat freshness policy and invalidation paths as first-class constraints. Common pitfall: invalidation races under concurrent writes.",
      "references": [
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-032",
      "type": "multiple-choice",
      "question": "A notification state converger is facing offline edits arriving out of order. Which conflict-resolution/convergence decision is strongest? Compensating logic exists but lacks ordering safeguards.",
      "options": [
        "Prioritize replayed events over stored state to speed recovery, then reconcile ordering anomalies in background jobs.",
        "Use version/vector metadata to detect concurrency and drive deterministic merge decisions.",
        "Standardize conflict resolution on last-write-wins across entities to simplify merge semantics and operations.",
        "Drop unresolved conflicting updates from hot paths and rely on periodic reconciliation to correct drift."
      ],
      "correct": 1,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A notification state converger is facing offline edits arriving out of order, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Discard choices that violate required invariants during concurrent or failed states. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-033",
      "type": "multiple-choice",
      "question": "A comment thread merge service is facing divergent region writes after partition. Which conflict-resolution/convergence decision is strongest? Throughput targets remain strict despite stronger merge semantics.",
      "options": [
        "Use CRDT-style commutative structures where business semantics allow safe convergence.",
        "Standardize conflict resolution on last-write-wins across entities to simplify merge semantics and operations.",
        "Drop unresolved conflicting updates from hot paths and rely on periodic reconciliation to correct drift.",
        "Prioritize replayed events over stored state to speed recovery, then reconcile ordering anomalies in background jobs."
      ],
      "correct": 0,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A comment thread merge service is facing divergent region writes after partition, this is the strongest fit in Conflict Resolution & Convergence.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Reject designs that improve throughput while weakening reliability guarantees. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. Common pitfall: ordering loss during partition or replay changes.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-034",
      "type": "multiple-choice",
      "question": "A offline-first mobile sync API is facing duplicate event replay with stale payload. Which conflict-resolution/convergence decision is strongest? Support teams need explainable conflict outcomes.",
      "options": [
        "Standardize conflict resolution on last-write-wins across entities to simplify merge semantics and operations.",
        "Drop unresolved conflicting updates from hot paths and rely on periodic reconciliation to correct drift.",
        "Prioritize replayed events over stored state to speed recovery, then reconcile ordering anomalies in background jobs.",
        "Make merge handlers idempotent and replay-safe with dedupe/version guards."
      ],
      "correct": 3,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A offline-first mobile sync API is facing duplicate event replay with stale payload, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "Generalize from offline-first mobile sync API is facing duplicate event replay with stale payload to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Discard options that weaken contract clarity or compatibility over time. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-035",
      "type": "multiple-choice",
      "question": "A catalog attribute merge path is facing last-write-wins data loss risk. Which conflict-resolution/convergence decision is strongest? Post-incident hardening is part of this scope.",
      "options": [
        "Drop unresolved conflicting updates from hot paths and rely on periodic reconciliation to correct drift.",
        "Prioritize replayed events over stored state to speed recovery, then reconcile ordering anomalies in background jobs.",
        "Escalate unresolved conflicts to explicit user/business resolution flow for high-risk data.",
        "Standardize conflict resolution on last-write-wins across entities to simplify merge semantics and operations."
      ],
      "correct": 2,
      "explanation": "Convergence quality improves when merge policies reflect domain semantics and replay/concurrency realities. For A catalog attribute merge path is facing last-write-wins data loss risk, this is the strongest fit in Conflict Resolution & Convergence.",
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Prefer approaches that directly address failure mode, recovery path, and blast radius. Tie decisions to concrete operational outcomes, not abstract reliability language. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-036",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: shopping cart sync backend reports incidents around last-write-wins data loss risk. What is the primary diagnosis?",
          "options": [
            "Current merge policy in shopping cart sync backend mismatches last-write-wins data loss risk, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness."
          ],
          "correct": 0,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For shopping cart sync backend reports incidents around last-write-wins data loss risk, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while preserving user-visible coherence?",
          "options": [
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Make merge handlers idempotent and replay-safe with dedupe/version guards."
          ],
          "correct": 3,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change while preserving user-visible coherence, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-037",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: inventory reconciliation service reports incidents around merge ambiguity for non-commutative operations. What is the primary diagnosis?",
          "options": [
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness.",
            "Current merge policy in inventory reconciliation service mismatches merge ambiguity for non-commutative operations, causing incorrect convergence."
          ],
          "correct": 3,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For inventory reconciliation service reports incidents around merge ambiguity for non-commutative operations, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Solve this as chained reasoning where stage two must respect stage one assumptions. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under replay-heavy failure recovery?",
          "options": [
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Escalate unresolved conflicts to explicit user/business resolution flow for high-risk data.",
            "Disable conflict detection to reduce write latency."
          ],
          "correct": 2,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change under replay-heavy failure recovery, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Generalize from after confirming diagnosis, what is the strongest next change under replay-heavy to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Do not reset assumptions between stages; carry forward prior constraints directly. Tie decisions to concrete operational outcomes, not abstract reliability language. Common pitfall: meeting average goals while missing tail-risk."
        }
      ],
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-038",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: chat thread state projector reports incidents around compensation event arriving late. What is the primary diagnosis?",
          "options": [
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness.",
            "Current merge policy in chat thread state projector mismatches compensation event arriving late, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists."
          ],
          "correct": 2,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For chat thread state projector reports incidents around compensation event arriving late, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Throughput is only one part; replay behavior and consumer lag handling matter equally. Common pitfall: ordering loss during partition or replay changes."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change during cross-region divergence?",
          "options": [
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Partition entities by conflict profile and apply tailored merge policy per class.",
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only."
          ],
          "correct": 1,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change during cross-region divergence, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-039",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: feature-flag state distribution reports incidents around partial convergence under retry backoff. What is the primary diagnosis?",
          "options": [
            "Replay handling is independent from merge correctness.",
            "Current merge policy in feature-flag state distribution mismatches partial convergence under retry backoff, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome."
          ],
          "correct": 1,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For feature-flag state distribution reports incidents around partial convergence under retry backoff, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Do not reset assumptions between stages; carry forward prior constraints directly. Tie decisions to concrete operational outcomes, not abstract reliability language. Common pitfall: meeting average goals while missing tail-risk."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change without silent data loss?",
          "options": [
            "Record causal history needed for conflict explanation and auditability.",
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup."
          ],
          "correct": 0,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change without silent data loss, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-040",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: multi-region settings service reports incidents around idempotency gap in merge handlers. What is the primary diagnosis?",
          "options": [
            "Current merge policy in multi-region settings service mismatches idempotency gap in merge handlers, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness."
          ],
          "correct": 0,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For multi-region settings service reports incidents around idempotency gap in merge handlers, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with strict auditability needs?",
          "options": [
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Define compensation ordering semantics so late compensations cannot corrupt newer state."
          ],
          "correct": 3,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change with strict auditability needs, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-041",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: ad campaign config sync reports incidents around conflicting business rule updates. What is the primary diagnosis?",
          "options": [
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness.",
            "Current merge policy in ad campaign config sync mismatches conflicting business rule updates, causing incorrect convergence."
          ],
          "correct": 3,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For ad campaign config sync reports incidents around conflicting business rule updates, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under high write concurrency?",
          "options": [
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Bound eventual convergence windows and alert on prolonged divergence.",
            "Disable conflict detection to reduce write latency."
          ],
          "correct": 2,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change under high write concurrency, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-042",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: identity claim convergence pipeline reports incidents around concurrent updates to same field. What is the primary diagnosis?",
          "options": [
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness.",
            "Current merge policy in identity claim convergence pipeline mismatches concurrent updates to same field, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists."
          ],
          "correct": 2,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For identity claim convergence pipeline reports incidents around concurrent updates to same field, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while keeping merge latency acceptable?",
          "options": [
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Protect invariant-critical writes with stronger coordination, leaving tolerant fields convergent.",
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only."
          ],
          "correct": 1,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change while keeping merge latency acceptable, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-043",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: ticket reservation reconciliation reports incidents around offline edits arriving out of order. What is the primary diagnosis?",
          "options": [
            "Replay handling is independent from merge correctness.",
            "Current merge policy in ticket reservation reconciliation mismatches offline edits arriving out of order, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome."
          ],
          "correct": 1,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For ticket reservation reconciliation reports incidents around offline edits arriving out of order, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Generalize from scenario: ticket reservation reconciliation reports incidents around offline edits to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change during compensation reordering?",
          "options": [
            "Use domain-specific merge semantics instead of global last-write-wins for critical fields.",
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup."
          ],
          "correct": 0,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change during compensation reordering, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-044",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: billing adjustment merger reports incidents around divergent region writes after partition. What is the primary diagnosis?",
          "options": [
            "Current merge policy in billing adjustment merger mismatches divergent region writes after partition, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness."
          ],
          "correct": 0,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For billing adjustment merger reports incidents around divergent region writes after partition, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Solve this as chained reasoning where stage two must respect stage one assumptions. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. Common pitfall: ordering loss during partition or replay changes."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with mixed commutative/non-commutative fields?",
          "options": [
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Use version/vector metadata to detect concurrency and drive deterministic merge decisions."
          ],
          "correct": 3,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change with mixed commutative/non-commutative fields, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-045",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: notification state converger reports incidents around duplicate event replay with stale payload. What is the primary diagnosis?",
          "options": [
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness.",
            "Current merge policy in notification state converger mismatches duplicate event replay with stale payload, causing incorrect convergence."
          ],
          "correct": 3,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For notification state converger reports incidents around duplicate event replay with stale payload, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: interface design coupled too tightly to internal implementation."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change before wider rollout?",
          "options": [
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Use CRDT-style commutative structures where business semantics allow safe convergence.",
            "Disable conflict detection to reduce write latency."
          ],
          "correct": 2,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change before wider rollout, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "Generalize from conflict Resolution & Convergence to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-046",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: comment thread merge service reports incidents around last-write-wins data loss risk. What is the primary diagnosis?",
          "options": [
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness.",
            "Current merge policy in comment thread merge service mismatches last-write-wins data loss risk, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists."
          ],
          "correct": 2,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For comment thread merge service reports incidents around last-write-wins data loss risk, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under offline client resync storms?",
          "options": [
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Make merge handlers idempotent and replay-safe with dedupe/version guards.",
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only."
          ],
          "correct": 1,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change under offline client resync storms, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "Generalize from after confirming diagnosis, what is the strongest next change under offline client to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-047",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: offline-first mobile sync API reports incidents around merge ambiguity for non-commutative operations. What is the primary diagnosis?",
          "options": [
            "Replay handling is independent from merge correctness.",
            "Current merge policy in offline-first mobile sync API mismatches merge ambiguity for non-commutative operations, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome."
          ],
          "correct": 1,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For offline-first mobile sync API reports incidents around merge ambiguity for non-commutative operations, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: interface design coupled too tightly to internal implementation."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while controlling operational complexity?",
          "options": [
            "Escalate unresolved conflicts to explicit user/business resolution flow for high-risk data.",
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup."
          ],
          "correct": 0,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change while controlling operational complexity, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-048",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: catalog attribute merge path reports incidents around compensation event arriving late. What is the primary diagnosis?",
          "options": [
            "Current merge policy in catalog attribute merge path mismatches compensation event arriving late, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness."
          ],
          "correct": 0,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For catalog attribute merge path reports incidents around compensation event arriving late, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Solve this as chained reasoning where stage two must respect stage one assumptions. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. Common pitfall: ordering loss during partition or replay changes."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with bounded convergence SLO?",
          "options": [
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Partition entities by conflict profile and apply tailored merge policy per class."
          ],
          "correct": 3,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change with bounded convergence SLO, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Do not reset assumptions between stages; carry forward prior constraints directly. Map the approach to measurable reliability impact such as error-budget burn and recovery behavior. Common pitfall: meeting average goals while missing tail-risk."
        }
      ],
      "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-049",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: fraud case state reconciler reports incidents around partial convergence under retry backoff. What is the primary diagnosis?",
          "options": [
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness.",
            "Current merge policy in fraud case state reconciler mismatches partial convergence under retry backoff, causing incorrect convergence."
          ],
          "correct": 3,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For fraud case state reconciler reports incidents around partial convergence under retry backoff, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. A strong real-world approach explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: assuming recovery speed without operational proof."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change during schema migration?",
          "options": [
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Record causal history needed for conflict explanation and auditability.",
            "Disable conflict detection to reduce write latency."
          ],
          "correct": 2,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change during schema migration, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-050",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: support ticket merge workflow reports incidents around idempotency gap in merge handlers. What is the primary diagnosis?",
          "options": [
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness.",
            "Current merge policy in support ticket merge workflow mismatches idempotency gap in merge handlers, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists."
          ],
          "correct": 2,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For support ticket merge workflow reports incidents around idempotency gap in merge handlers, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "Generalize from scenario: support ticket merge workflow reports incidents around idempotency gap in to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under tenant-specific merge policies?",
          "options": [
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Define compensation ordering semantics so late compensations cannot corrupt newer state.",
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only."
          ],
          "correct": 1,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change under tenant-specific merge policies, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-051",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: shipment status convergence service reports incidents around conflicting business rule updates. What is the primary diagnosis?",
          "options": [
            "Replay handling is independent from merge correctness.",
            "Current merge policy in shipment status convergence service mismatches conflicting business rule updates, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome."
          ],
          "correct": 1,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For shipment status convergence service reports incidents around conflicting business rule updates, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while preserving invariants?",
          "options": [
            "Bound eventual convergence windows and alert on prolonged divergence.",
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup."
          ],
          "correct": 0,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change while preserving invariants, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-052",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: membership preference sync store reports incidents around concurrent updates to same field. What is the primary diagnosis?",
          "options": [
            "Current merge policy in membership preference sync store mismatches concurrent updates to same field, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness."
          ],
          "correct": 0,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For membership preference sync store reports incidents around concurrent updates to same field, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Solve this as chained reasoning where stage two must respect stage one assumptions. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with explicit conflict explainability?",
          "options": [
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Protect invariant-critical writes with stronger coordination, leaving tolerant fields convergent."
          ],
          "correct": 3,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change with explicit conflict explainability, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-053",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: device configuration convergence backend reports incidents around offline edits arriving out of order. What is the primary diagnosis?",
          "options": [
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness.",
            "Current merge policy in device configuration convergence backend mismatches offline edits arriving out of order, causing incorrect convergence."
          ],
          "correct": 3,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For device configuration convergence backend reports incidents around offline edits arriving out of order, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change during prolonged partitions?",
          "options": [
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Use domain-specific merge semantics instead of global last-write-wins for critical fields.",
            "Disable conflict detection to reduce write latency."
          ],
          "correct": 2,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change during prolonged partitions, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-054",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: user profile merge service reports incidents around divergent region writes after partition. What is the primary diagnosis?",
          "options": [
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness.",
            "Current merge policy in user profile merge service mismatches divergent region writes after partition, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists."
          ],
          "correct": 2,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For user profile merge service reports incidents around divergent region writes after partition, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Solve this as chained reasoning where stage two must respect stage one assumptions. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. Common pitfall: consumer lag growth under burst traffic."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under retry amplification?",
          "options": [
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Use version/vector metadata to detect concurrency and drive deterministic merge decisions.",
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only."
          ],
          "correct": 1,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change under retry amplification, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Do not reset assumptions between stages; carry forward prior constraints directly. A strong real-world approach explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: assuming recovery speed without operational proof."
        }
      ],
      "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-055",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: collaborative doc state store reports incidents around duplicate event replay with stale payload. What is the primary diagnosis?",
          "options": [
            "Replay handling is independent from merge correctness.",
            "Current merge policy in collaborative doc state store mismatches duplicate event replay with stale payload, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome."
          ],
          "correct": 1,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For collaborative doc state store reports incidents around duplicate event replay with stale payload, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Do not reset assumptions between stages; carry forward prior constraints directly. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: ambiguous contracts that hide behavior changes."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while minimizing manual intervention?",
          "options": [
            "Use CRDT-style commutative structures where business semantics allow safe convergence.",
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup."
          ],
          "correct": 0,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change while minimizing manual intervention, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Generalize from after confirming diagnosis, what is the strongest next change while minimizing manual to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-056",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: shopping cart sync backend reports incidents around last-write-wins data loss risk. What is the primary diagnosis?",
          "options": [
            "Current merge policy in shopping cart sync backend mismatches last-write-wins data loss risk, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness."
          ],
          "correct": 0,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For shopping cart sync backend reports incidents around last-write-wins data loss risk, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Solve this as chained reasoning where stage two must respect stage one assumptions. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with deterministic outcomes?",
          "options": [
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Make merge handlers idempotent and replay-safe with dedupe/version guards."
          ],
          "correct": 3,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change with deterministic outcomes, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "Generalize from conflict Resolution & Convergence to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-057",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: inventory reconciliation service reports incidents around merge ambiguity for non-commutative operations. What is the primary diagnosis?",
          "options": [
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness.",
            "Current merge policy in inventory reconciliation service mismatches merge ambiguity for non-commutative operations, causing incorrect convergence."
          ],
          "correct": 3,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For inventory reconciliation service reports incidents around merge ambiguity for non-commutative operations, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under cost constraints?",
          "options": [
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Escalate unresolved conflicts to explicit user/business resolution flow for high-risk data.",
            "Disable conflict detection to reduce write latency."
          ],
          "correct": 2,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change under cost constraints, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-058",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: chat thread state projector reports incidents around compensation event arriving late. What is the primary diagnosis?",
          "options": [
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness.",
            "Current merge policy in chat thread state projector mismatches compensation event arriving late, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists."
          ],
          "correct": 2,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For chat thread state projector reports incidents around compensation event arriving late, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "Generalize from scenario: chat thread state projector reports incidents around compensation event to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. Common pitfall: consumer lag growth under burst traffic."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change during backfill replay?",
          "options": [
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Partition entities by conflict profile and apply tailored merge policy per class.",
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only."
          ],
          "correct": 1,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change during backfill replay, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-059",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: feature-flag state distribution reports incidents around partial convergence under retry backoff. What is the primary diagnosis?",
          "options": [
            "Replay handling is independent from merge correctness.",
            "Current merge policy in feature-flag state distribution mismatches partial convergence under retry backoff, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome."
          ],
          "correct": 1,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For feature-flag state distribution reports incidents around partial convergence under retry backoff, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Do not reset assumptions between stages; carry forward prior constraints directly. A strong real-world approach explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: assuming recovery speed without operational proof."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while reducing unresolved-conflict backlog?",
          "options": [
            "Record causal history needed for conflict explanation and auditability.",
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup."
          ],
          "correct": 0,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change while reducing unresolved-conflict backlog, this is the strongest fit in Conflict Resolution & Convergence. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-060",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: multi-region settings service reports incidents around idempotency gap in merge handlers. What is the primary diagnosis?",
          "options": [
            "Current merge policy in multi-region settings service mismatches idempotency gap in merge handlers, causing incorrect convergence.",
            "Conflict anomalies are acceptable if eventual state exists.",
            "LWW always preserves most important business outcome.",
            "Replay handling is independent from merge correctness."
          ],
          "correct": 0,
          "explanation": "The issue stems from mismatched merge semantics versus domain correctness needs. For multi-region settings service reports incidents around idempotency gap in merge handlers, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with canary-safe migration controls?",
          "options": [
            "Disable conflict detection to reduce write latency.",
            "Resolve all conflicts with newest wall-clock timestamp only.",
            "Ignore unresolved conflicts until quarterly cleanup.",
            "Define compensation ordering semantics so late compensations cannot corrupt newer state."
          ],
          "correct": 3,
          "explanation": "Adopt explicit merge semantics and replay-safe guards aligned to data criticality. For After confirming diagnosis, what is the strongest next change with canary-safe migration controls, this is the strongest fit in Conflict Resolution & Convergence.",
          "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-061",
      "type": "multi-select",
      "question": "Why can global last-write-wins be dangerous? (Select all that apply)",
      "options": [
        "Can silently drop valid concurrent intent",
        "Depends on skewed wall-clock order",
        "Always preserves domain invariants",
        "Can mask business-critical conflicts"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "LWW is simple but often unsafe for invariant-critical or semantically rich fields.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Anchor decisions in explicit constraints, invariants, and observable failure signals rather than intuition. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-062",
      "type": "multi-select",
      "question": "CRDT-style approaches are best suited for which? (Select all that apply)",
      "options": [
        "Commutative/associative state updates",
        "Convergence without central coordination",
        "Arbitrary non-commutative financial transfers",
        "High-replay distributed updates"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "CRDTs fit naturally convergent data types, not all business operations.",
      "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Anchor decisions in explicit constraints, invariants, and observable failure signals rather than intuition. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-063",
      "type": "multi-select",
      "question": "Replay-safe merge handlers should include which? (Select all that apply)",
      "options": [
        "Idempotency keys",
        "Version/causal checks",
        "Blind overwrite on duplicate events",
        "Deterministic merge output"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Replay safety requires dedupe, ordering checks, and deterministic behavior.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Validate each proposed control independently and avoid partially true claims that fail under realistic load. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-064",
      "type": "multi-select",
      "question": "Useful conflict observability includes which? (Select all that apply)",
      "options": [
        "Conflict rate by entity/field",
        "Unresolved conflict age",
        "Only host CPU",
        "Convergence latency distribution"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Conflict operations need direct visibility into rate, age, and convergence timing.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Anchor decisions in explicit constraints, invariants, and observable failure signals rather than intuition. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-065",
      "type": "multi-select",
      "question": "When should conflicts escalate to manual/business resolution? (Select all that apply)",
      "options": [
        "Invariant-critical data with ambiguous merge",
        "High-value financial/contract fields",
        "Low-risk commutative counters",
        "Irreconcilable concurrent updates"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Manual escalation is for ambiguous/high-risk conflicts where automation is unsafe.",
      "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Evaluate each candidate approach independently under the same constraints. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-066",
      "type": "multi-select",
      "question": "Compensation events can corrupt state unless which are true? (Select all that apply)",
      "options": [
        "Compensations are ordered/validated against current version",
        "Late compensation cannot overwrite newer accepted state",
        "Compensations bypass merge checks",
        "Compensation handlers are idempotent"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Compensations require ordering and idempotent safeguards against stale overwrites.",
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Anchor decisions in explicit constraints, invariants, and observable failure signals rather than intuition. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-067",
      "type": "multi-select",
      "question": "Convergence policy by entity class should consider which? (Select all that apply)",
      "options": [
        "Business criticality",
        "Update concurrency profile",
        "One policy for all entities always",
        "Commutativity of operations"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Entity-specific policy improves correctness/cost balance.",
      "detailedExplanation": "Generalize from convergence policy by entity class should consider which? (Select all that apply) to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Evaluate each candidate approach independently under the same constraints. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-068",
      "type": "multi-select",
      "question": "Signs merge policy is insufficient include which? (Select all that apply)",
      "options": [
        "Recurring state reverted incidents",
        "Large unresolved conflict backlog",
        "Stable convergence SLO with low anomaly rates",
        "Support escalations on lost updates"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Reversions, backlog, and escalations indicate merge policy mismatch.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Validate each proposed control independently and avoid partially true claims that fail under realistic load. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-069",
      "type": "multi-select",
      "question": "To keep convergence explainable, which are useful? (Select all that apply)",
      "options": [
        "Persist merge decision metadata",
        "Expose conflict reason codes",
        "Delete conflicting evidence to simplify logs",
        "Trace causal/version lineage"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Explainability requires durable metadata and lineage visibility.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Anchor decisions in explicit constraints, invariants, and observable failure signals rather than intuition. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-070",
      "type": "multi-select",
      "question": "Which anti-patterns often break eventual convergence? (Select all that apply)",
      "options": [
        "Non-idempotent replay handlers",
        "Hidden schema-dependent merge assumptions",
        "Deterministic merge functions",
        "Ignoring causal metadata in updates"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Replay/causal blind spots and hidden assumptions cause drift.",
      "detailedExplanation": "Generalize from anti-patterns often break eventual convergence? (Select all that apply) to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Validate each proposed control independently and avoid partially true claims that fail under realistic load. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-071",
      "type": "multi-select",
      "question": "When stronger coordination is preferable to merge logic alone? (Select all that apply)",
      "options": [
        "Hard invariants with high failure cost",
        "Financial transfer uniqueness constraints",
        "Low-risk social counters",
        "Operations that cannot be safely commuted"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Some invariants require stronger coordination than eventual merge semantics.",
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Anchor decisions in explicit constraints, invariants, and observable failure signals rather than intuition. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-072",
      "type": "multi-select",
      "question": "Good migration practices for new merge semantics include which? (Select all that apply)",
      "options": [
        "Canary by entity segment",
        "Dual-path validation metrics",
        "Big-bang cutover with no fallback",
        "Rollback criteria for anomaly spikes"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Staged rollout and rollback guardrails reduce migration risk.",
      "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Evaluate each candidate approach independently under the same constraints. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-073",
      "type": "multi-select",
      "question": "Conflict-resolution SLOs can include which? (Select all that apply)",
      "options": [
        "Max unresolved conflict age",
        "Convergence latency percentile",
        "Only total write QPS",
        "Conflict-loss incident count"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "SLOs should target conflict handling quality, not just throughput.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Validate each proposed control independently and avoid partially true claims that fail under realistic load. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-074",
      "type": "multi-select",
      "question": "Which fields are often good CRDT candidates? (Select all that apply)",
      "options": [
        "Set membership preferences",
        "Grow-only counters with semantics",
        "Single authoritative legal contract term",
        "Commutative tag updates"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "CRDT fit is strongest for commutative/idempotent state types.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Anchor decisions in explicit constraints, invariants, and observable failure signals rather than intuition. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-075",
      "type": "multi-select",
      "question": "To prevent stale replay overwrite, which controls are useful? (Select all that apply)",
      "options": [
        "Monotonic version guards",
        "Compare-and-set semantics",
        "Accept any later-arrival timestamp blindly",
        "Dedupe state with expiry policy"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Monotonic/CAS + dedupe protects newer state against stale replays.",
      "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Anchor decisions in explicit constraints, invariants, and observable failure signals rather than intuition. Cache design quality is mostly about correctness boundaries, not only hit rate. Common pitfall: invalidation races under concurrent writes.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-076",
      "type": "multi-select",
      "question": "For offline-first clients, which safeguards improve merge outcomes? (Select all that apply)",
      "options": [
        "Client operation IDs",
        "Server-side conflict classification",
        "Blind overwrite on reconnect",
        "User-visible conflict UI for critical fields"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Offline sync needs operation identity, server classification, and user-visible fallback.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Validate each proposed control independently and avoid partially true claims that fail under realistic load. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-077",
      "type": "multi-select",
      "question": "Which can reduce unresolved conflict backlog? (Select all that apply)",
      "options": [
        "Domain-specific auto-merge improvements",
        "Priority triage for high-risk entities",
        "Ignoring aged conflicts indefinitely",
        "Clear ownership for manual resolution queues"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Backlog reduction requires better auto-merge and accountable resolution workflows.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Anchor decisions in explicit constraints, invariants, and observable failure signals rather than intuition. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-078",
      "type": "numeric-input",
      "question": "A system processes 3,600,000 updates/day with conflict rate 0.8%. Conflicts/day?",
      "answer": 28800,
      "unit": "updates",
      "tolerance": 0.03,
      "explanation": "0.008*3,600,000=28,800.",
      "detailedExplanation": "Generalize from system processes 3,600,000 updates/day with conflict rate 0 to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Normalize units before computing so conversion mistakes do not propagate. Strong answers connect quorum/coordination settings to concrete correctness goals. If values like 3,600 and 000 appear, convert them into one unit basis before comparison. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-079",
      "type": "numeric-input",
      "question": "Unresolved conflicts are 12,000 with resolver throughput 150/min. Minutes to clear backlog (no new conflicts)?",
      "answer": 80,
      "unit": "minutes",
      "tolerance": 0,
      "explanation": "12,000/150=80.",
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Write the unit conversion path explicitly, then calculate, then sanity-check magnitude. Consistency decisions should be explicit about which conflicts are acceptable and why. Numbers such as 12,000 and 150 should be normalized first so downstream reasoning stays consistent. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-080",
      "type": "numeric-input",
      "question": "Replay duplicate rate is 1.6% on 950,000 events/day. Duplicate events/day?",
      "answer": 15200,
      "unit": "events",
      "tolerance": 0.03,
      "explanation": "0.016*950,000=15,200.",
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Write the unit conversion path explicitly, then calculate, then sanity-check magnitude. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Numbers such as 1.6 and 950,000 should be normalized first so downstream reasoning stays consistent. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-081",
      "type": "numeric-input",
      "question": "Conflict auto-resolve succeeds for 91% of 40,000 conflicts/day. Manual conflicts/day?",
      "answer": 3600,
      "unit": "conflicts",
      "tolerance": 0.03,
      "explanation": "9% of 40,000 = 3,600.",
      "detailedExplanation": "Generalize from conflict auto-resolve succeeds for 91% of 40,000 conflicts/day to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Normalize units before computing so conversion mistakes do not propagate. Consistency decisions should be explicit about which conflicts are acceptable and why. If values like 91 and 40,000 appear, convert them into one unit basis before comparison. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-082",
      "type": "numeric-input",
      "question": "Convergence p95 is 28s, SLO target is 20s. Percent over target?",
      "answer": 40,
      "unit": "%",
      "tolerance": 0.3,
      "explanation": "(28-20)/20=40%.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Normalize units before computing so conversion mistakes do not propagate. Tie decisions to concrete operational outcomes, not abstract reliability language. If values like 28s and 20s appear, convert them into one unit basis before comparison. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "Percentile",
          "url": "https://en.wikipedia.org/wiki/Percentile"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-083",
      "type": "numeric-input",
      "question": "A merge metadata field adds 36 bytes/update at 55,000 updates/sec. Extra MB/sec (decimal)?",
      "answer": 1.98,
      "unit": "MB/sec",
      "tolerance": 0.08,
      "explanation": "55,000*36=1,980,000 bytes/sec = 1.98 MB/sec.",
      "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Keep every transformation in one unit system and check order of magnitude at the end. Strong answers connect quorum/coordination settings to concrete correctness goals. Keep quantities like 36 and 55,000 in aligned units before deciding on an implementation approach. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-084",
      "type": "numeric-input",
      "question": "LWW-loss incidents fell from 260/week to 52/week. Percent reduction?",
      "answer": 80,
      "unit": "%",
      "tolerance": 0.2,
      "explanation": "(260-52)/260=80%.",
      "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Normalize units before computing so conversion mistakes do not propagate. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. If values like 260 and 52 appear, convert them into one unit basis before comparison. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-085",
      "type": "numeric-input",
      "question": "Conflict-check path adds 12ms to 35% of 18,000 req/sec. Added req-ms per second?",
      "answer": 75600,
      "unit": "req-ms/sec",
      "tolerance": 0.03,
      "explanation": "18,000*0.35*12 = 75,600 req-ms/sec.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Keep every transformation in one unit system and check order of magnitude at the end. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Keep quantities like 12ms and 35 in aligned units before deciding on an implementation approach. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-086",
      "type": "numeric-input",
      "question": "If 14% of 120,000 writes/min require strong coordination fallback, fallback writes/min?",
      "answer": 16800,
      "unit": "writes/min",
      "tolerance": 0.02,
      "explanation": "0.14*120,000=16,800.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Normalize units before computing so conversion mistakes do not propagate. Consistency decisions should be explicit about which conflicts are acceptable and why. If values like 14 and 120,000 appear, convert them into one unit basis before comparison. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-087",
      "type": "numeric-input",
      "question": "Divergence-alert threshold is 15 minutes; current median unresolved age is 9 minutes. Remaining budget?",
      "answer": 6,
      "unit": "minutes",
      "tolerance": 0,
      "explanation": "15-9=6 minutes.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Keep every transformation in one unit system and check order of magnitude at the end. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Keep quantities like 15 minutes and 9 minutes in aligned units before deciding on an implementation approach. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-088",
      "type": "numeric-input",
      "question": "A conflict queue receives 480 items/min and resolves 530/min. Net drain rate?",
      "answer": 50,
      "unit": "items/min",
      "tolerance": 0,
      "explanation": "530-480=50 drained per minute.",
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Write the unit conversion path explicitly, then calculate, then sanity-check magnitude. Throughput is only one part; replay behavior and consumer lag handling matter equally. Numbers such as 480 and 530 should be normalized first so downstream reasoning stays consistent. Common pitfall: consumer lag growth under burst traffic.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-089",
      "type": "numeric-input",
      "question": "Compensation misorder incidents are 0.12% of 2,500,000 events/day. Incidents/day?",
      "answer": 3000,
      "unit": "events",
      "tolerance": 0.03,
      "explanation": "0.0012*2,500,000=3,000.",
      "detailedExplanation": "Generalize from compensation misorder incidents are 0 to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Normalize units before computing so conversion mistakes do not propagate. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. If values like 0.12 and 2,500 appear, convert them into one unit basis before comparison. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-090",
      "type": "ordering",
      "question": "Order a robust conflict-resolution workflow.",
      "items": [
        "Detect/label conflict type",
        "Apply domain merge policy",
        "Validate resulting invariants",
        "Escalate unresolved high-risk conflicts"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Classify, merge, validate, then escalate if unsafe.",
      "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Order by relative scale and bottleneck effect, then validate neighboring items. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-091",
      "type": "ordering",
      "question": "Order by increasing overwrite risk.",
      "items": [
        "CAS with version check",
        "Merge with causal metadata",
        "LWW with synchronized clocks assumption",
        "Blind last-arrival overwrite"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Risk rises as causal/version safeguards are removed.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Build the rank from biggest differences first, then refine with adjacent checks. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-092",
      "type": "ordering",
      "question": "Order convergence migration safety.",
      "items": [
        "Canary entity subset",
        "Dual-path compare metrics",
        "Progressive expansion",
        "Retire legacy merge path"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Safe migration uses staged rollout with metric comparison.",
      "detailedExplanation": "Generalize from order convergence migration safety to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Build the rank from biggest differences first, then refine with adjacent checks. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-093",
      "type": "ordering",
      "question": "Order by increasing manual effort.",
      "items": [
        "Deterministic auto-merge",
        "Policy-based merge + occasional review",
        "Frequent manual triage queue",
        "All conflicts manually resolved"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Manual burden rises as automation quality decreases.",
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Order by relative scale and bottleneck effect, then validate neighboring items. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-094",
      "type": "ordering",
      "question": "Order replay protection strength.",
      "items": [
        "Timestamp compare only",
        "Idempotency key check",
        "Idempotency + version monotonic guard",
        "Idempotency + version + causal dependency checks"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Replay safety improves with layered checks.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Place obvious extremes first, then sort the middle by pairwise comparison. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-095",
      "type": "ordering",
      "question": "Order by strongest evidence of convergence health.",
      "items": [
        "Low average latency only",
        "Low conflict rate only",
        "Low conflict + low unresolved age",
        "Low conflict + low unresolved age + low loss incidents"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Strong evidence combines rate, age, and correctness outcomes.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Build the rank from biggest differences first, then refine with adjacent checks. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-096",
      "type": "ordering",
      "question": "Order conflict policy granularity from coarsest to finest.",
      "items": [
        "Single global merge rule",
        "Per-service merge rule",
        "Per-entity merge rule",
        "Per-field/entity merge rule with escalation paths"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Finer policy granularity better matches domain semantics.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Build the rank from biggest differences first, then refine with adjacent checks. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-097",
      "type": "ordering",
      "question": "Order by suitability for commutative updates.",
      "items": [
        "Blind overwrite",
        "Timestamp LWW",
        "Set/counter CRDT merge",
        "Domain-specific commutative CRDT + audit trail"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Commutative semantics become stronger and safer with explicit CRDT policy.",
      "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Order by relative scale and bottleneck effect, then validate neighboring items. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-098",
      "type": "ordering",
      "question": "Order incident response for divergence spike.",
      "items": [
        "Scope affected entities",
        "Contain risky writes/paths",
        "Apply merge/replay fix",
        "Add recurrence guardrails and tests"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Scope, contain, fix, and harden.",
      "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Place obvious extremes first, then sort the middle by pairwise comparison. Tie decisions to concrete operational outcomes, not abstract reliability language. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-099",
      "type": "ordering",
      "question": "Order by increasing operational complexity. (Conflict Resolution & Convergence context C)",
      "items": [
        "Simple LWW policy",
        "Entity-tiered merge policy",
        "Entity-tiered + causal metadata",
        "Entity-tiered + causal + manual escalation workflows"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Complexity grows with metadata richness and workflow depth.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Build the rank from biggest differences first, then refine with adjacent checks. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    },
    {
      "id": "cc-cr-100",
      "type": "ordering",
      "question": "Order by increasing guarantee strength against silent data loss.",
      "items": [
        "Best-effort overwrite",
        "LWW with timestamps",
        "Versioned deterministic merges",
        "Versioned deterministic merges + invariant validation + escalation"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Silent-loss protection improves with explicit checks and escalation.",
      "detailedExplanation": "Generalize from order by increasing guarantee strength against silent data loss to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Order by relative scale and bottleneck effect, then validate neighboring items. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": [
        "consistency-coordination",
        "conflict-resolution-and-convergence"
      ],
      "difficulty": "senior"
    }
  ]
}
