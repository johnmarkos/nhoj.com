{
  "unit": 8,
  "unitTitle": "Consistency & Coordination",
  "chapter": 1,
  "chapterTitle": "Consistency Models Fundamentals",
  "chapterDescription": "Core consistency guarantees and trade-offs for read/write behavior, user-visible anomalies, and invariant-critical paths in distributed systems.",
  "problems": [
    {
      "id": "cc-cm-001",
      "type": "multiple-choice",
      "question": "A global profile service is facing read-your-writes expectations. Which consistency-model decision is strongest? Recent user reports mention stale profile values after edits.",
      "options": [
        "Require linearizable reads on critical write-followed-by-read paths and scope them narrowly.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics."
      ],
      "correct": 0,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. For A global profile service is facing read-your-writes expectations, this option best addresses the stated constraints in Consistency Models Fundamentals.",
      "detailedExplanation": "Start from \"global profile service is facing read-your-writes expectations\", then pressure-test the result against the options. Prefer the choice that balances hit rate with clear staleness and invalidation behavior. Treat freshness policy and invalidation paths as first-class constraints. Common pitfall: hot-key skew causing uneven load.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-002",
      "type": "multiple-choice",
      "question": "A payment authorization API is facing strict no-stale-read checkout rule. Which consistency-model decision is strongest? This regression appears most during regional failover windows.",
      "options": [
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Use read-your-writes/session consistency for user-facing state while keeping less critical paths eventually consistent."
      ],
      "correct": 3,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. For A payment authorization API is facing strict no-stale-read checkout rule, this choice most directly resolves the stated failure mode in Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "The decision turns on \"payment authorization API is facing strict no-stale-read checkout rule\". Prioritize the option that best protects the reliability objective under the stated failure conditions. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-003",
      "type": "multiple-choice",
      "question": "A social feed timeline API is facing cross-device session updates. Which consistency-model decision is strongest? The team must preserve low latency on non-critical reads.",
      "options": [
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Prefer causal consistency where related updates must preserve happens-before relationships.",
        "Standardize all reads as eventually consistent with no exception handling."
      ],
      "correct": 2,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. For A social feed timeline API is facing cross-device session updates, this mitigation aligns best with the scenario constraints in Consistency Models Fundamentals.",
      "detailedExplanation": "Read this as a scenario about \"social feed timeline API is facing cross-device session updates\". Eliminate designs that create ambiguous API semantics or brittle versioning paths. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-004",
      "type": "multiple-choice",
      "question": "An inventory reservation service is facing multi-region replica lag. Which consistency-model decision is strongest? Critical checkout invariants are now under stricter scrutiny.",
      "options": [
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Pin critical reads to leader/quorum paths when stale data is unacceptable.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency."
      ],
      "correct": 1,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. For an inventory reservation service is facing multi-region replica lag, this response is the most defensible call for Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "Use \"inventory reservation service is facing multi-region replica lag\" as your starting point, then verify tradeoffs carefully. Discard choices that violate required invariants during concurrent or failed states. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-005",
      "type": "multiple-choice",
      "question": "A messaging inbox API is facing partition tolerance during failover. Which consistency-model decision is strongest? Multi-device sessions amplify inconsistency visibility.",
      "options": [
        "Adopt tunable consistency with stronger writes for invariant-critical entities.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics."
      ],
      "correct": 0,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. For A messaging inbox API is facing partition tolerance during failover, this option best addresses the stated constraints in Consistency Models Fundamentals.",
      "detailedExplanation": "This prompt is really about \"messaging inbox API is facing partition tolerance during failover\". Eliminate answers that do not directly address the failure mode, recovery path, or blast radius. The strongest answer explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-006",
      "type": "multiple-choice",
      "question": "A feature-flag delivery API is facing high write burst with follower reads. Which consistency-model decision is strongest? Replica lag spikes during write bursts expose weak guarantees.",
      "options": [
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Separate strict correctness endpoints from low-latency eventually consistent read endpoints."
      ],
      "correct": 3,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. For A feature-flag delivery API is facing high write burst with follower reads, this choice most directly resolves the stated failure mode in Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "If you keep \"feature-flag delivery API is facing high write burst with follower reads\" in view, the correct answer separates faster. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-007",
      "type": "multiple-choice",
      "question": "A ride dispatch state service is facing causal update chains between services. Which consistency-model decision is strongest? Support tickets describe data “time travel” behavior.",
      "options": [
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Use monotonic-read guarantees to prevent time-travel user experiences across devices.",
        "Standardize all reads as eventually consistent with no exception handling."
      ],
      "correct": 2,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. For A ride dispatch state service is facing causal update chains between services, this mitigation aligns best with the scenario constraints in Consistency Models Fundamentals.",
      "detailedExplanation": "The core signal here is \"ride dispatch state service is facing causal update chains between services\". Discard choices that violate required invariants during concurrent or failed states. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-008",
      "type": "multiple-choice",
      "question": "A support ticket backend is facing client retry/reorder behavior. Which consistency-model decision is strongest? Incident review requires explicit endpoint-level contracts.",
      "options": [
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Apply bounded-staleness policy with explicit freshness budgets and fallback behavior.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency."
      ],
      "correct": 1,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. For A support ticket backend is facing client retry/reorder behavior, this response is the most defensible call for Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "The key clue in this question is \"support ticket backend is facing client retry/reorder behavior\". Reject choices that sound good generally but do not reduce the concrete reliability risk in this scenario. Tie the decision to concrete operational outcomes, not abstract reliability language. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-009",
      "type": "multiple-choice",
      "question": "An ad campaign manager is facing low-latency read requirement. Which consistency-model decision is strongest? The fix should avoid over-strengthening every endpoint.",
      "options": [
        "Use session stickiness plus tokenized version checks to enforce user-visible consistency guarantees.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics."
      ],
      "correct": 0,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. For an ad campaign manager is facing low-latency read requirement, this option best addresses the stated constraints in Consistency Models Fundamentals.",
      "detailedExplanation": "Start from \"ad campaign manager is facing low-latency read requirement\", then pressure-test the result against the options. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-010",
      "type": "multiple-choice",
      "question": "An analytics query endpoint is facing audit correctness requirement. Which consistency-model decision is strongest? Audit stakeholders require deterministic critical-path behavior.",
      "options": [
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Design explicit degradation mode that trades freshness for availability on non-critical reads."
      ],
      "correct": 3,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. For an analytics query endpoint is facing audit correctness requirement, this choice most directly resolves the stated failure mode in Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "The core signal here is \"analytics query endpoint is facing audit correctness requirement\". Discard options that weaken contract clarity or compatibility over time. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-011",
      "type": "multiple-choice",
      "question": "A document collaboration API is facing read-your-writes expectations. Which consistency-model decision is strongest? Recent traffic growth increased follower-read usage.",
      "options": [
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Require linearizable reads on critical write-followed-by-read paths and scope them narrowly.",
        "Standardize all reads as eventually consistent with no exception handling."
      ],
      "correct": 2,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. For A document collaboration API is facing read-your-writes expectations, this mitigation aligns best with the scenario constraints in Consistency Models Fundamentals.",
      "detailedExplanation": "If you keep \"document collaboration API is facing read-your-writes expectations\" in view, the correct answer separates faster. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-012",
      "type": "multiple-choice",
      "question": "A bank transfer ledger API is facing strict no-stale-read checkout rule. Which consistency-model decision is strongest? The service mixes critical and non-critical entities.",
      "options": [
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Use read-your-writes/session consistency for user-facing state while keeping less critical paths eventually consistent.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency."
      ],
      "correct": 1,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. For A bank transfer ledger API is facing strict no-stale-read checkout rule, this response is the most defensible call for Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "This prompt is really about \"bank transfer ledger API is facing strict no-stale-read checkout rule\". Eliminate designs that create ambiguous API semantics or brittle versioning paths. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-013",
      "type": "multiple-choice",
      "question": "A shopping cart service is facing cross-device session updates. Which consistency-model decision is strongest? Client retries increase reordering risk across regions.",
      "options": [
        "Prefer causal consistency where related updates must preserve happens-before relationships.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics."
      ],
      "correct": 0,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. For A shopping cart service is facing cross-device session updates, this option best addresses the stated constraints in Consistency Models Fundamentals.",
      "detailedExplanation": "Use \"shopping cart service is facing cross-device session updates\" as your starting point, then verify tradeoffs carefully. Eliminate approaches that hand-wave conflict resolution or quorum behavior. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-014",
      "type": "multiple-choice",
      "question": "A notification preference API is facing multi-region replica lag. Which consistency-model decision is strongest? On-call reports stale reads concentrated in one path.",
      "options": [
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Pin critical reads to leader/quorum paths when stale data is unacceptable."
      ],
      "correct": 3,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. For A notification preference API is facing multi-region replica lag, this choice most directly resolves the stated failure mode in Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "Read this as a scenario about \"notification preference API is facing multi-region replica lag\". Prefer the choice that keeps client behavior explicit while preserving evolvability. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-015",
      "type": "multiple-choice",
      "question": "A fraud decision API is facing partition tolerance during failover. Which consistency-model decision is strongest? A quick mitigation is needed before full architecture changes.",
      "options": [
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Adopt tunable consistency with stronger writes for invariant-critical entities.",
        "Standardize all reads as eventually consistent with no exception handling."
      ],
      "correct": 2,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. For A fraud decision API is facing partition tolerance during failover, this mitigation aligns best with the scenario constraints in Consistency Models Fundamentals.",
      "detailedExplanation": "The decision turns on \"fraud decision API is facing partition tolerance during failover\". Prioritize the option that best protects the reliability objective under the stated failure conditions. Tie the decision to concrete operational outcomes, not abstract reliability language. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-016",
      "type": "multiple-choice",
      "question": "A game session coordinator is facing high write burst with follower reads. Which consistency-model decision is strongest? The current API docs do not define freshness semantics clearly.",
      "options": [
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Separate strict correctness endpoints from low-latency eventually consistent read endpoints.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency."
      ],
      "correct": 1,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. For A game session coordinator is facing high write burst with follower reads, this response is the most defensible call for Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "Start from \"game session coordinator is facing high write burst with follower reads\", then pressure-test the result against the options. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-017",
      "type": "multiple-choice",
      "question": "A identity profile API is facing causal update chains between services. Which consistency-model decision is strongest? Cost constraints rule out global strictness everywhere.",
      "options": [
        "Use monotonic-read guarantees to prevent time-travel user experiences across devices.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics."
      ],
      "correct": 0,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. For A identity profile API is facing causal update chains between services, this option best addresses the stated constraints in Consistency Models Fundamentals.",
      "detailedExplanation": "The key clue in this question is \"identity profile API is facing causal update chains between services\". Eliminate designs that create ambiguous API semantics or brittle versioning paths. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-018",
      "type": "multiple-choice",
      "question": "A catalog availability API is facing client retry/reorder behavior. Which consistency-model decision is strongest? The UI requires clear behavior when freshness is uncertain.",
      "options": [
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Apply bounded-staleness policy with explicit freshness budgets and fallback behavior."
      ],
      "correct": 3,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. For A catalog availability API is facing client retry/reorder behavior, this choice most directly resolves the stated failure mode in Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "The core signal here is \"catalog availability API is facing client retry/reorder behavior\". Eliminate answers that do not directly address the failure mode, recovery path, or blast radius. The strongest answer explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-019",
      "type": "multiple-choice",
      "question": "An order tracking service is facing low-latency read requirement. Which consistency-model decision is strongest? SLOs now track monotonic-read violations explicitly.",
      "options": [
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Use session stickiness plus tokenized version checks to enforce user-visible consistency guarantees.",
        "Standardize all reads as eventually consistent with no exception handling."
      ],
      "correct": 2,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. For an order tracking service is facing low-latency read requirement, this mitigation aligns best with the scenario constraints in Consistency Models Fundamentals.",
      "detailedExplanation": "If you keep \"order tracking service is facing low-latency read requirement\" in view, the correct answer separates faster. Discard choices that violate required invariants during concurrent or failed states. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-020",
      "type": "multiple-choice",
      "question": "A customer settings API is facing audit correctness requirement. Which consistency-model decision is strongest? Teams disagree on whether session guarantees are required.",
      "options": [
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Design explicit degradation mode that trades freshness for availability on non-critical reads.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency."
      ],
      "correct": 1,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. For A customer settings API is facing audit correctness requirement, this response is the most defensible call for Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "If you keep \"customer settings API is facing audit correctness requirement\" in view, the correct answer separates faster. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-021",
      "type": "multiple-choice",
      "question": "A global profile service is facing read-your-writes expectations. Which consistency-model decision is strongest? Cross-service update chains are creating causal confusion.",
      "options": [
        "Require linearizable reads on critical write-followed-by-read paths and scope them narrowly.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics."
      ],
      "correct": 0,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. For A global profile service is facing read-your-writes expectations, this option best addresses the stated constraints in Consistency Models Fundamentals.",
      "detailedExplanation": "The core signal here is \"global profile service is facing read-your-writes expectations\". Discard choices that violate required invariants during concurrent or failed states. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-022",
      "type": "multiple-choice",
      "question": "A payment authorization API is facing strict no-stale-read checkout rule. Which consistency-model decision is strongest? The platform can enforce version-token routing decisions.",
      "options": [
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Use read-your-writes/session consistency for user-facing state while keeping less critical paths eventually consistent."
      ],
      "correct": 3,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. For A payment authorization API is facing strict no-stale-read checkout rule, this choice most directly resolves the stated failure mode in Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "Use \"payment authorization API is facing strict no-stale-read checkout rule\" as your starting point, then verify tradeoffs carefully. Prefer the choice that keeps client behavior explicit while preserving evolvability. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-023",
      "type": "multiple-choice",
      "question": "A social feed timeline API is facing cross-device session updates. Which consistency-model decision is strongest? Business impact is tied to incorrect post-write reads.",
      "options": [
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Prefer causal consistency where related updates must preserve happens-before relationships.",
        "Standardize all reads as eventually consistent with no exception handling."
      ],
      "correct": 2,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. For A social feed timeline API is facing cross-device session updates, this mitigation aligns best with the scenario constraints in Consistency Models Fundamentals.",
      "detailedExplanation": "This prompt is really about \"social feed timeline API is facing cross-device session updates\". Discard options that weaken contract clarity or compatibility over time. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-024",
      "type": "multiple-choice",
      "question": "An inventory reservation service is facing multi-region replica lag. Which consistency-model decision is strongest? Some endpoints can tolerate bounded staleness if explicit.",
      "options": [
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Pin critical reads to leader/quorum paths when stale data is unacceptable.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency."
      ],
      "correct": 1,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. For an inventory reservation service is facing multi-region replica lag, this response is the most defensible call for Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "The decision turns on \"inventory reservation service is facing multi-region replica lag\". Eliminate approaches that hand-wave conflict resolution or quorum behavior. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-025",
      "type": "multiple-choice",
      "question": "A messaging inbox API is facing partition tolerance during failover. Which consistency-model decision is strongest? The incident occurs mainly on follower-heavy traffic.",
      "options": [
        "Adopt tunable consistency with stronger writes for invariant-critical entities.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics."
      ],
      "correct": 0,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. For A messaging inbox API is facing partition tolerance during failover, this option best addresses the stated constraints in Consistency Models Fundamentals.",
      "detailedExplanation": "Read this as a scenario about \"messaging inbox API is facing partition tolerance during failover\". Reject choices that sound good generally but do not reduce the concrete reliability risk in this scenario. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: meeting average goals while missing tail-risk.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-026",
      "type": "multiple-choice",
      "question": "A feature-flag delivery API is facing high write burst with follower reads. Which consistency-model decision is strongest? Failback events temporarily widen staleness windows.",
      "options": [
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Separate strict correctness endpoints from low-latency eventually consistent read endpoints."
      ],
      "correct": 3,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. For A feature-flag delivery API is facing high write burst with follower reads, this choice most directly resolves the stated failure mode in Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "The key clue in this question is \"feature-flag delivery API is facing high write burst with follower reads\". Prefer the choice that keeps client behavior explicit while preserving evolvability. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-027",
      "type": "multiple-choice",
      "question": "A ride dispatch state service is facing causal update chains between services. Which consistency-model decision is strongest? Critical endpoints are a minority of total traffic.",
      "options": [
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Use monotonic-read guarantees to prevent time-travel user experiences across devices.",
        "Standardize all reads as eventually consistent with no exception handling."
      ],
      "correct": 2,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. For A ride dispatch state service is facing causal update chains between services, this mitigation aligns best with the scenario constraints in Consistency Models Fundamentals.",
      "detailedExplanation": "Start from \"ride dispatch state service is facing causal update chains between services\", then pressure-test the result against the options. Prefer the option that preserves correctness guarantees for the stated consistency boundary. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-028",
      "type": "multiple-choice",
      "question": "A support ticket backend is facing client retry/reorder behavior. Which consistency-model decision is strongest? Engineering leadership requested measurable consistency SLOs.",
      "options": [
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Apply bounded-staleness policy with explicit freshness budgets and fallback behavior.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency."
      ],
      "correct": 1,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. For A support ticket backend is facing client retry/reorder behavior, this response is the most defensible call for Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "If you keep \"support ticket backend is facing client retry/reorder behavior\" in view, the correct answer separates faster. Eliminate answers that do not directly address the failure mode, recovery path, or blast radius. The strongest answer explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: meeting average goals while missing tail-risk.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Retry pattern",
          "url": "https://learn.microsoft.com/en-us/azure/architecture/patterns/retry"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-029",
      "type": "multiple-choice",
      "question": "An ad campaign manager is facing low-latency read requirement. Which consistency-model decision is strongest? The solution must preserve availability under partial failure.",
      "options": [
        "Use session stickiness plus tokenized version checks to enforce user-visible consistency guarantees.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics."
      ],
      "correct": 0,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. For an ad campaign manager is facing low-latency read requirement, this option best addresses the stated constraints in Consistency Models Fundamentals.",
      "detailedExplanation": "The core signal here is \"ad campaign manager is facing low-latency read requirement\". Reject choices that sound good generally but do not reduce the concrete reliability risk in this scenario. The strongest answer explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-030",
      "type": "multiple-choice",
      "question": "An analytics query endpoint is facing audit correctness requirement. Which consistency-model decision is strongest? Convergence eventually happens but user trust is degraded.",
      "options": [
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Design explicit degradation mode that trades freshness for availability on non-critical reads."
      ],
      "correct": 3,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. For an analytics query endpoint is facing audit correctness requirement, this choice most directly resolves the stated failure mode in Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "This prompt is really about \"analytics query endpoint is facing audit correctness requirement\". Prefer the choice that keeps client behavior explicit while preserving evolvability. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-031",
      "type": "multiple-choice",
      "question": "A document collaboration API is facing read-your-writes expectations. Which consistency-model decision is strongest? Current behavior differs by region for the same user action.",
      "options": [
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Require linearizable reads on critical write-followed-by-read paths and scope them narrowly.",
        "Standardize all reads as eventually consistent with no exception handling."
      ],
      "correct": 2,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. For A document collaboration API is facing read-your-writes expectations, this mitigation aligns best with the scenario constraints in Consistency Models Fundamentals.",
      "detailedExplanation": "Use \"document collaboration API is facing read-your-writes expectations\" as your starting point, then verify tradeoffs carefully. Discard options that weaken contract clarity or compatibility over time. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-032",
      "type": "multiple-choice",
      "question": "A bank transfer ledger API is facing strict no-stale-read checkout rule. Which consistency-model decision is strongest? Mitigation should be canary-safe and reversible.",
      "options": [
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Use read-your-writes/session consistency for user-facing state while keeping less critical paths eventually consistent.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency."
      ],
      "correct": 1,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. For A bank transfer ledger API is facing strict no-stale-read checkout rule, this response is the most defensible call for Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "The core signal here is \"bank transfer ledger API is facing strict no-stale-read checkout rule\". Discard options that weaken contract clarity or compatibility over time. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-033",
      "type": "multiple-choice",
      "question": "A shopping cart service is facing cross-device session updates. Which consistency-model decision is strongest? Error semantics for stale vs unavailable need to be explicit.",
      "options": [
        "Prefer causal consistency where related updates must preserve happens-before relationships.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics."
      ],
      "correct": 0,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. For A shopping cart service is facing cross-device session updates, this option best addresses the stated constraints in Consistency Models Fundamentals.",
      "detailedExplanation": "If you keep \"shopping cart service is facing cross-device session updates\" in view, the correct answer separates faster. Reject options that improve speed but weaken freshness or invalidation correctness. Treat freshness policy and invalidation paths as first-class constraints. Common pitfall: hot-key skew causing uneven load.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-034",
      "type": "multiple-choice",
      "question": "A notification preference API is facing multi-region replica lag. Which consistency-model decision is strongest? The team wants a principled consistency rubric, not ad hoc fixes.",
      "options": [
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Pin critical reads to leader/quorum paths when stale data is unacceptable."
      ],
      "correct": 3,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. For A notification preference API is facing multi-region replica lag, this choice most directly resolves the stated failure mode in Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "Start from \"notification preference API is facing multi-region replica lag\", then pressure-test the result against the options. Prefer the choice that keeps client behavior explicit while preserving evolvability. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-035",
      "type": "multiple-choice",
      "question": "A fraud decision API is facing partition tolerance during failover. Which consistency-model decision is strongest? Post-incident prevention is required in the first rollout.",
      "options": [
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Adopt tunable consistency with stronger writes for invariant-critical entities.",
        "Standardize all reads as eventually consistent with no exception handling."
      ],
      "correct": 2,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. For A fraud decision API is facing partition tolerance during failover, this mitigation aligns best with the scenario constraints in Consistency Models Fundamentals.",
      "detailedExplanation": "The key clue in this question is \"fraud decision API is facing partition tolerance during failover\". Prioritize the option that best protects the reliability objective under the stated failure conditions. Tie the decision to concrete operational outcomes, not abstract reliability language. Common pitfall: meeting average goals while missing tail-risk.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-036",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: inventory reservation service is seeing issues around partition tolerance during failover. What is the most likely diagnosis?",
          "options": [
            "The current model for inventory reservation service does not match partition tolerance during failover, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees."
          ],
          "correct": 0,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. For inventory reservation service is seeing issues around partition tolerance during failover, this response is the most defensible call for Consistency Models Fundamentals.",
          "detailedExplanation": "Read this as a scenario about \"scenario: inventory reservation service is seeing issues around partition tolerance\". Solve this as chained reasoning where stage two must respect stage one assumptions. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: meeting average goals while missing tail-risk."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest while keeping p99 under target?",
          "options": [
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Prefer causal consistency where related updates must preserve happens-before relationships."
          ],
          "correct": 3,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. For the follow-up change decision while keeping p99 under target, this option best addresses the stated constraints in Consistency Models Fundamentals.",
          "detailedExplanation": "The key clue in this question is \"after confirming diagnosis, which next change is strongest while keeping p99 under\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. The strongest answer explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: assuming recovery speed without operational proof."
        }
      ],
      "detailedExplanation": "Read this as a scenario about \"consistency Models Fundamentals\". Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-037",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: messaging inbox API is seeing issues around high write burst with follower reads. What is the most likely diagnosis?",
          "options": [
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for messaging inbox API does not match high write burst with follower reads, causing user-visible anomalies."
          ],
          "correct": 3,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. For messaging inbox API is seeing issues around high write burst with follower reads, this choice most directly resolves the stated failure mode in Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Use \"scenario: messaging inbox API is seeing issues around high write burst with follower\" as your starting point, then verify tradeoffs carefully. Solve this as chained reasoning where stage two must respect stage one assumptions. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: interface design coupled too tightly to internal implementation."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest without violating checkout correctness?",
          "options": [
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Pin critical reads to leader/quorum paths when stale data is unacceptable.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI."
          ],
          "correct": 2,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. For the follow-up change decision without violating checkout correctness, this mitigation aligns best with the scenario constraints in Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "The core signal here is \"after confirming diagnosis, which next change is strongest without violating checkout\". Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "The decision turns on \"consistency Models Fundamentals\". Solve this as chained reasoning where stage two must respect stage one assumptions. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-038",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: feature-flag delivery API is seeing issues around causal update chains between services. What is the most likely diagnosis?",
          "options": [
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for feature-flag delivery API does not match causal update chains between services, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good."
          ],
          "correct": 2,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. For feature-flag delivery API is seeing issues around causal update chains between services, this response is the most defensible call for Consistency Models Fundamentals.",
          "detailedExplanation": "Start from \"scenario: feature-flag delivery API is seeing issues around causal update chains\", then pressure-test the result against the options. Do not reset assumptions between stages; carry forward prior constraints directly. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: ambiguous contracts that hide behavior changes."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest under replica lag spikes?",
          "options": [
            "Do nothing and rely on passive replica convergence only.",
            "Adopt tunable consistency with stronger writes for invariant-critical entities.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement."
          ],
          "correct": 1,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. For the follow-up change decision under replica lag spikes, this option best addresses the stated constraints in Consistency Models Fundamentals.",
          "detailedExplanation": "The decision turns on \"after confirming diagnosis, which next change is strongest under replica lag spikes\". Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "This prompt is really about \"consistency Models Fundamentals\". Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-039",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: ride dispatch state service is seeing issues around client retry/reorder behavior. What is the most likely diagnosis?",
          "options": [
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for ride dispatch state service does not match client retry/reorder behavior, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches."
          ],
          "correct": 1,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. For ride dispatch state service is seeing issues around client retry/reorder behavior, this choice most directly resolves the stated failure mode in Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "The decision turns on \"scenario: ride dispatch state service is seeing issues around client retry/reorder\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: meeting average goals while missing tail-risk."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest during regional failover?",
          "options": [
            "Separate strict correctness endpoints from low-latency eventually consistent read endpoints.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only."
          ],
          "correct": 0,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. For the follow-up change decision during regional failover, this mitigation aligns best with the scenario constraints in Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Start from \"after confirming diagnosis, which next change is strongest during regional failover\", then pressure-test the result against the options. Solve this as chained reasoning where stage two must respect stage one assumptions. Tie the decision to concrete operational outcomes, not abstract reliability language. Common pitfall: assuming recovery speed without operational proof."
        }
      ],
      "detailedExplanation": "Use \"consistency Models Fundamentals\" as your starting point, then verify tradeoffs carefully. Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-040",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: support ticket backend is seeing issues around low-latency read requirement. What is the most likely diagnosis?",
          "options": [
            "The current model for support ticket backend does not match low-latency read requirement, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees."
          ],
          "correct": 0,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. For support ticket backend is seeing issues around low-latency read requirement, this response is the most defensible call for Consistency Models Fundamentals.",
          "detailedExplanation": "The decision turns on \"scenario: support ticket backend is seeing issues around low-latency read requirement\". Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest with mobile multi-device clients?",
          "options": [
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Use monotonic-read guarantees to prevent time-travel user experiences across devices."
          ],
          "correct": 3,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. For the follow-up change decision with mobile multi-device clients, this option best addresses the stated constraints in Consistency Models Fundamentals.",
          "detailedExplanation": "Start from \"after confirming diagnosis, which next change is strongest with mobile multi-device\", then pressure-test the result against the options. Solve this as chained reasoning where stage two must respect stage one assumptions. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "Use \"consistency Models Fundamentals\" as your starting point, then verify tradeoffs carefully. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-041",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: ad campaign manager is seeing issues around audit correctness requirement. What is the most likely diagnosis?",
          "options": [
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for ad campaign manager does not match audit correctness requirement, causing user-visible anomalies."
          ],
          "correct": 3,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. For ad campaign manager is seeing issues around audit correctness requirement, this choice most directly resolves the stated failure mode in Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Start from \"scenario: ad campaign manager is seeing issues around audit correctness requirement\", then pressure-test the result against the options. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest while limiting quorum read cost?",
          "options": [
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Apply bounded-staleness policy with explicit freshness budgets and fallback behavior.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI."
          ],
          "correct": 2,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. For the follow-up change decision while limiting quorum read cost, this mitigation aligns best with the scenario constraints in Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "The decision turns on \"after confirming diagnosis, which next change is strongest while limiting quorum read\". Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "This prompt is really about \"consistency Models Fundamentals\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-042",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: analytics query endpoint is seeing issues around read-your-writes expectations. What is the most likely diagnosis?",
          "options": [
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for analytics query endpoint does not match read-your-writes expectations, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good."
          ],
          "correct": 2,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. For analytics query endpoint is seeing issues around read-your-writes expectations, this response is the most defensible call for Consistency Models Fundamentals.",
          "detailedExplanation": "The key clue in this question is \"scenario: analytics query endpoint is seeing issues around read-your-writes expectations\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: interface design coupled too tightly to internal implementation."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest under intermittent partitions?",
          "options": [
            "Do nothing and rely on passive replica convergence only.",
            "Use session stickiness plus tokenized version checks to enforce user-visible consistency guarantees.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement."
          ],
          "correct": 1,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. For the follow-up change decision under intermittent partitions, this option best addresses the stated constraints in Consistency Models Fundamentals.",
          "detailedExplanation": "Read this as a scenario about \"after confirming diagnosis, which next change is strongest under intermittent partitions\". Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "If you keep \"consistency Models Fundamentals\" in view, the correct answer separates faster. Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-043",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: document collaboration API is seeing issues around strict no-stale-read checkout rule. What is the most likely diagnosis?",
          "options": [
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for document collaboration API does not match strict no-stale-read checkout rule, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches."
          ],
          "correct": 1,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. For document collaboration API is seeing issues around strict no-stale-read checkout rule, this choice most directly resolves the stated failure mode in Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "The core signal here is \"scenario: document collaboration API is seeing issues around strict no-stale-read\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: interface design coupled too tightly to internal implementation."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest without forcing global sync everywhere?",
          "options": [
            "Design explicit degradation mode that trades freshness for availability on non-critical reads.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only."
          ],
          "correct": 0,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. For the follow-up change decision without forcing global sync everywhere, this mitigation aligns best with the scenario constraints in Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Use \"after confirming diagnosis, which next change is strongest without forcing global sync\" as your starting point, then verify tradeoffs carefully. Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "The core signal here is \"consistency Models Fundamentals\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-044",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: bank transfer ledger API is seeing issues around cross-device session updates. What is the most likely diagnosis?",
          "options": [
            "The current model for bank transfer ledger API does not match cross-device session updates, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees."
          ],
          "correct": 0,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. For bank transfer ledger API is seeing issues around cross-device session updates, this response is the most defensible call for Consistency Models Fundamentals.",
          "detailedExplanation": "If you keep \"scenario: bank transfer ledger API is seeing issues around cross-device session updates\" in view, the correct answer separates faster. Solve this as chained reasoning where stage two must respect stage one assumptions. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: breaking clients during version evolution."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest during burst traffic windows?",
          "options": [
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Require linearizable reads on critical write-followed-by-read paths and scope them narrowly."
          ],
          "correct": 3,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. For the follow-up change decision during burst traffic windows, this option best addresses the stated constraints in Consistency Models Fundamentals.",
          "detailedExplanation": "This prompt is really about \"after confirming diagnosis, which next change is strongest during burst traffic windows\". Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "The key clue in this question is \"consistency Models Fundamentals\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-045",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: shopping cart service is seeing issues around multi-region replica lag. What is the most likely diagnosis?",
          "options": [
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for shopping cart service does not match multi-region replica lag, causing user-visible anomalies."
          ],
          "correct": 3,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. For shopping cart service is seeing issues around multi-region replica lag, this choice most directly resolves the stated failure mode in Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "This prompt is really about \"scenario: shopping cart service is seeing issues around multi-region replica lag\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest with strict audit surfaces?",
          "options": [
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Use read-your-writes/session consistency for user-facing state while keeping less critical paths eventually consistent.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI."
          ],
          "correct": 2,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. For the follow-up change decision with strict audit surfaces, this mitigation aligns best with the scenario constraints in Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "If you keep \"after confirming diagnosis, which next change is strongest with strict audit surfaces\" in view, the correct answer separates faster. Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "Start from \"consistency Models Fundamentals\", then pressure-test the result against the options. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-046",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: notification preference API is seeing issues around partition tolerance during failover. What is the most likely diagnosis?",
          "options": [
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for notification preference API does not match partition tolerance during failover, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good."
          ],
          "correct": 2,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. For notification preference API is seeing issues around partition tolerance during failover, this response is the most defensible call for Consistency Models Fundamentals.",
          "detailedExplanation": "Use \"scenario: notification preference API is seeing issues around partition tolerance\" as your starting point, then verify tradeoffs carefully. Solve this as chained reasoning where stage two must respect stage one assumptions. Tie the decision to concrete operational outcomes, not abstract reliability language. Common pitfall: meeting average goals while missing tail-risk."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest while preserving availability goals?",
          "options": [
            "Do nothing and rely on passive replica convergence only.",
            "Prefer causal consistency where related updates must preserve happens-before relationships.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement."
          ],
          "correct": 1,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. For the follow-up change decision while preserving availability goals, this option best addresses the stated constraints in Consistency Models Fundamentals.",
          "detailedExplanation": "The core signal here is \"after confirming diagnosis, which next change is strongest while preserving\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: assuming recovery speed without operational proof."
        }
      ],
      "detailedExplanation": "The decision turns on \"consistency Models Fundamentals\". Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-047",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: fraud decision API is seeing issues around high write burst with follower reads. What is the most likely diagnosis?",
          "options": [
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for fraud decision API does not match high write burst with follower reads, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches."
          ],
          "correct": 1,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. For fraud decision API is seeing issues around high write burst with follower reads, this choice most directly resolves the stated failure mode in Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Read this as a scenario about \"scenario: fraud decision API is seeing issues around high write burst with follower\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: ambiguous contracts that hide behavior changes."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest under edge-cache refresh delays?",
          "options": [
            "Pin critical reads to leader/quorum paths when stale data is unacceptable.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only."
          ],
          "correct": 0,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. For the follow-up change decision under edge-cache refresh delays, this mitigation aligns best with the scenario constraints in Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "The key clue in this question is \"after confirming diagnosis, which next change is strongest under edge-cache refresh\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Treat freshness policy and invalidation paths as first-class constraints. Common pitfall: stale data despite high hit rates."
        }
      ],
      "detailedExplanation": "Read this as a scenario about \"consistency Models Fundamentals\". Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-048",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: game session coordinator is seeing issues around causal update chains between services. What is the most likely diagnosis?",
          "options": [
            "The current model for game session coordinator does not match causal update chains between services, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees."
          ],
          "correct": 0,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. For game session coordinator is seeing issues around causal update chains between services, this response is the most defensible call for Consistency Models Fundamentals.",
          "detailedExplanation": "The decision turns on \"scenario: game session coordinator is seeing issues around causal update chains between\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest with mixed critical/non-critical entities?",
          "options": [
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Adopt tunable consistency with stronger writes for invariant-critical entities."
          ],
          "correct": 3,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. For the follow-up change decision with mixed critical/non-critical entities, this option best addresses the stated constraints in Consistency Models Fundamentals.",
          "detailedExplanation": "Start from \"after confirming diagnosis, which next change is strongest with mixed\", then pressure-test the result against the options. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "Use \"consistency Models Fundamentals\" as your starting point, then verify tradeoffs carefully. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-049",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: identity profile API is seeing issues around client retry/reorder behavior. What is the most likely diagnosis?",
          "options": [
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for identity profile API does not match client retry/reorder behavior, causing user-visible anomalies."
          ],
          "correct": 3,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. For identity profile API is seeing issues around client retry/reorder behavior, this choice most directly resolves the stated failure mode in Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Start from \"scenario: identity profile API is seeing issues around client retry/reorder behavior\", then pressure-test the result against the options. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: assuming recovery speed without operational proof."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest without causing user time-travel reads?",
          "options": [
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Separate strict correctness endpoints from low-latency eventually consistent read endpoints.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI."
          ],
          "correct": 2,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. For the follow-up change decision without causing user time-travel reads, this mitigation aligns best with the scenario constraints in Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "The decision turns on \"after confirming diagnosis, which next change is strongest without causing user\". Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "This prompt is really about \"consistency Models Fundamentals\". Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-050",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: catalog availability API is seeing issues around low-latency read requirement. What is the most likely diagnosis?",
          "options": [
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for catalog availability API does not match low-latency read requirement, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good."
          ],
          "correct": 2,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. For catalog availability API is seeing issues around low-latency read requirement, this response is the most defensible call for Consistency Models Fundamentals.",
          "detailedExplanation": "Read this as a scenario about \"scenario: catalog availability API is seeing issues around low-latency read requirement\". Solve this as chained reasoning where stage two must respect stage one assumptions. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: assuming recovery speed without operational proof."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest under retry reordering behavior?",
          "options": [
            "Do nothing and rely on passive replica convergence only.",
            "Use monotonic-read guarantees to prevent time-travel user experiences across devices.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement."
          ],
          "correct": 1,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. For the follow-up change decision under retry reordering behavior, this option best addresses the stated constraints in Consistency Models Fundamentals.",
          "detailedExplanation": "The key clue in this question is \"after confirming diagnosis, which next change is strongest under retry reordering\". Solve this as chained reasoning where stage two must respect stage one assumptions. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: assuming recovery speed without operational proof."
        }
      ],
      "detailedExplanation": "Read this as a scenario about \"consistency Models Fundamentals\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-051",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: order tracking service is seeing issues around audit correctness requirement. What is the most likely diagnosis?",
          "options": [
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for order tracking service does not match audit correctness requirement, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches."
          ],
          "correct": 1,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. For order tracking service is seeing issues around audit correctness requirement, this choice most directly resolves the stated failure mode in Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Use \"scenario: order tracking service is seeing issues around audit correctness requirement\" as your starting point, then verify tradeoffs carefully. Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest with constrained backend capacity?",
          "options": [
            "Apply bounded-staleness policy with explicit freshness budgets and fallback behavior.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only."
          ],
          "correct": 0,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. For the follow-up change decision with constrained backend capacity, this mitigation aligns best with the scenario constraints in Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "The core signal here is \"after confirming diagnosis, which next change is strongest with constrained backend\". Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "The decision turns on \"consistency Models Fundamentals\". Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-052",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: customer settings API is seeing issues around read-your-writes expectations. What is the most likely diagnosis?",
          "options": [
            "The current model for customer settings API does not match read-your-writes expectations, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees."
          ],
          "correct": 0,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. For customer settings API is seeing issues around read-your-writes expectations, this response is the most defensible call for Consistency Models Fundamentals.",
          "detailedExplanation": "This prompt is really about \"scenario: customer settings API is seeing issues around read-your-writes expectations\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: interface design coupled too tightly to internal implementation."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest while controlling stale-read risk?",
          "options": [
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Use session stickiness plus tokenized version checks to enforce user-visible consistency guarantees."
          ],
          "correct": 3,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. For the follow-up change decision while controlling stale-read risk, this option best addresses the stated constraints in Consistency Models Fundamentals.",
          "detailedExplanation": "If you keep \"after confirming diagnosis, which next change is strongest while controlling stale-read\" in view, the correct answer separates faster. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Cache design quality is mostly about correctness boundaries, not only hit rate. Common pitfall: invalidation races under concurrent writes."
        }
      ],
      "detailedExplanation": "Start from \"consistency Models Fundamentals\", then pressure-test the result against the options. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-053",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: global profile service is seeing issues around strict no-stale-read checkout rule. What is the most likely diagnosis?",
          "options": [
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for global profile service does not match strict no-stale-read checkout rule, causing user-visible anomalies."
          ],
          "correct": 3,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. For global profile service is seeing issues around strict no-stale-read checkout rule, this choice most directly resolves the stated failure mode in Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "If you keep \"scenario: global profile service is seeing issues around strict no-stale-read checkout\" in view, the correct answer separates faster. Solve this as chained reasoning where stage two must respect stage one assumptions. A strong caching answer names staleness limits, invalidation behavior, and keying strategy. Common pitfall: invalidation races under concurrent writes."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest during dependency brownouts?",
          "options": [
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Design explicit degradation mode that trades freshness for availability on non-critical reads.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI."
          ],
          "correct": 2,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. For the follow-up change decision during dependency brownouts, this mitigation aligns best with the scenario constraints in Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "This prompt is really about \"after confirming diagnosis, which next change is strongest during dependency brownouts\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "The key clue in this question is \"consistency Models Fundamentals\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-054",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: payment authorization API is seeing issues around cross-device session updates. What is the most likely diagnosis?",
          "options": [
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for payment authorization API does not match cross-device session updates, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good."
          ],
          "correct": 2,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. For payment authorization API is seeing issues around cross-device session updates, this response is the most defensible call for Consistency Models Fundamentals.",
          "detailedExplanation": "The core signal here is \"scenario: payment authorization API is seeing issues around cross-device session updates\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: ambiguous contracts that hide behavior changes."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest with tenant-isolation constraints?",
          "options": [
            "Do nothing and rely on passive replica convergence only.",
            "Require linearizable reads on critical write-followed-by-read paths and scope them narrowly.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement."
          ],
          "correct": 1,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. For the follow-up change decision with tenant-isolation constraints, this option best addresses the stated constraints in Consistency Models Fundamentals.",
          "detailedExplanation": "Use \"after confirming diagnosis, which next change is strongest with tenant-isolation\" as your starting point, then verify tradeoffs carefully. Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "The core signal here is \"consistency Models Fundamentals\". Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-055",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: social feed timeline API is seeing issues around multi-region replica lag. What is the most likely diagnosis?",
          "options": [
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for social feed timeline API does not match multi-region replica lag, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches."
          ],
          "correct": 1,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. For social feed timeline API is seeing issues around multi-region replica lag, this choice most directly resolves the stated failure mode in Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "The key clue in this question is \"scenario: social feed timeline API is seeing issues around multi-region replica lag\". Solve this as chained reasoning where stage two must respect stage one assumptions. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: interface design coupled too tightly to internal implementation."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest before wider rollout?",
          "options": [
            "Use read-your-writes/session consistency for user-facing state while keeping less critical paths eventually consistent.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only."
          ],
          "correct": 0,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. For the follow-up change decision before wider rollout, this mitigation aligns best with the scenario constraints in Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Read this as a scenario about \"after confirming diagnosis, which next change is strongest before wider rollout\". Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "If you keep \"consistency Models Fundamentals\" in view, the correct answer separates faster. Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-056",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: inventory reservation service is seeing issues around partition tolerance during failover. What is the most likely diagnosis?",
          "options": [
            "The current model for inventory reservation service does not match partition tolerance during failover, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees."
          ],
          "correct": 0,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. For inventory reservation service is seeing issues around partition tolerance during failover, this response is the most defensible call for Consistency Models Fundamentals.",
          "detailedExplanation": "Start from \"scenario: inventory reservation service is seeing issues around partition tolerance\", then pressure-test the result against the options. Do not reset assumptions between stages; carry forward prior constraints directly. The strongest answer explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: retry storms during partial failure."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest with clear error semantics?",
          "options": [
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Prefer causal consistency where related updates must preserve happens-before relationships."
          ],
          "correct": 3,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. For the follow-up change decision with clear error semantics, this option best addresses the stated constraints in Consistency Models Fundamentals.",
          "detailedExplanation": "The decision turns on \"after confirming diagnosis, which next change is strongest with clear error semantics\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "This prompt is really about \"consistency Models Fundamentals\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-057",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: messaging inbox API is seeing issues around high write burst with follower reads. What is the most likely diagnosis?",
          "options": [
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for messaging inbox API does not match high write burst with follower reads, causing user-visible anomalies."
          ],
          "correct": 3,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. For messaging inbox API is seeing issues around high write burst with follower reads, this choice most directly resolves the stated failure mode in Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "The decision turns on \"scenario: messaging inbox API is seeing issues around high write burst with follower\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: breaking clients during version evolution."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest under backlog recovery pressure?",
          "options": [
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Pin critical reads to leader/quorum paths when stale data is unacceptable.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI."
          ],
          "correct": 2,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. For the follow-up change decision under backlog recovery pressure, this mitigation aligns best with the scenario constraints in Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Start from \"after confirming diagnosis, which next change is strongest under backlog recovery\", then pressure-test the result against the options. Solve this as chained reasoning where stage two must respect stage one assumptions. Tie the decision to concrete operational outcomes, not abstract reliability language. Common pitfall: meeting average goals while missing tail-risk."
        }
      ],
      "detailedExplanation": "Use \"consistency Models Fundamentals\" as your starting point, then verify tradeoffs carefully. Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-058",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: feature-flag delivery API is seeing issues around causal update chains between services. What is the most likely diagnosis?",
          "options": [
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for feature-flag delivery API does not match causal update chains between services, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good."
          ],
          "correct": 2,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. For feature-flag delivery API is seeing issues around causal update chains between services, this response is the most defensible call for Consistency Models Fundamentals.",
          "detailedExplanation": "Read this as a scenario about \"scenario: feature-flag delivery API is seeing issues around causal update chains\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: interface design coupled too tightly to internal implementation."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest while preserving write throughput?",
          "options": [
            "Do nothing and rely on passive replica convergence only.",
            "Adopt tunable consistency with stronger writes for invariant-critical entities.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement."
          ],
          "correct": 1,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. For the follow-up change decision while preserving write throughput, this option best addresses the stated constraints in Consistency Models Fundamentals.",
          "detailedExplanation": "The key clue in this question is \"after confirming diagnosis, which next change is strongest while preserving write\". Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "Read this as a scenario about \"consistency Models Fundamentals\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-059",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: ride dispatch state service is seeing issues around client retry/reorder behavior. What is the most likely diagnosis?",
          "options": [
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for ride dispatch state service does not match client retry/reorder behavior, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches."
          ],
          "correct": 1,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. For ride dispatch state service is seeing issues around client retry/reorder behavior, this choice most directly resolves the stated failure mode in Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Use \"scenario: ride dispatch state service is seeing issues around client retry/reorder\" as your starting point, then verify tradeoffs carefully. Solve this as chained reasoning where stage two must respect stage one assumptions. Tie the decision to concrete operational outcomes, not abstract reliability language. Common pitfall: meeting average goals while missing tail-risk."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest during incident containment?",
          "options": [
            "Separate strict correctness endpoints from low-latency eventually consistent read endpoints.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only."
          ],
          "correct": 0,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. For the follow-up change decision during incident containment, this mitigation aligns best with the scenario constraints in Consistency Models Fundamentals. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "The core signal here is \"after confirming diagnosis, which next change is strongest during incident containment\". Do not reset assumptions between stages; carry forward prior constraints directly. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: meeting average goals while missing tail-risk."
        }
      ],
      "detailedExplanation": "The decision turns on \"consistency Models Fundamentals\". Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-060",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: support ticket backend is seeing issues around low-latency read requirement. What is the most likely diagnosis?",
          "options": [
            "The current model for support ticket backend does not match low-latency read requirement, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees."
          ],
          "correct": 0,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. For support ticket backend is seeing issues around low-latency read requirement, this response is the most defensible call for Consistency Models Fundamentals.",
          "detailedExplanation": "Use \"scenario: support ticket backend is seeing issues around low-latency read requirement\" as your starting point, then verify tradeoffs carefully. Solve this as chained reasoning where stage two must respect stage one assumptions. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest with explicit freshness SLOs?",
          "options": [
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Use monotonic-read guarantees to prevent time-travel user experiences across devices."
          ],
          "correct": 3,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. For the follow-up change decision with explicit freshness SLOs, this option best addresses the stated constraints in Consistency Models Fundamentals.",
          "detailedExplanation": "The core signal here is \"after confirming diagnosis, which next change is strongest with explicit freshness SLOs\". Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "The decision turns on \"consistency Models Fundamentals\". Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-061",
      "type": "multi-select",
      "question": "Which are common user-facing anomalies under weak consistency? (Select all that apply)",
      "options": [
        "Read-your-write missing immediately after update",
        "Non-monotonic reads across requests",
        "Guaranteed strict serial order for all operations",
        "Conflicting views across devices"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Weak consistency can produce stale, non-monotonic, or divergent views.",
      "detailedExplanation": "Read this as a scenario about \"common user-facing anomalies under weak consistency? (Select all that apply)\". Treat every option as a separate true/false test under the same constraints. A strong caching answer names staleness limits, invalidation behavior, and keying strategy. Common pitfall: hot-key skew causing uneven load.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-062",
      "type": "multi-select",
      "question": "When is linearizability typically justified? (Select all that apply)",
      "options": [
        "Financial invariants and double-spend prevention",
        "Inventory oversell prevention at checkout",
        "All analytics dashboard reads",
        "Critical leader-election state"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Use strongest guarantees where correctness failures are high cost.",
      "detailedExplanation": "The key clue in this question is \"linearizability typically justified? (Select all that apply)\". Validate each option independently; do not select statements that are only partially true. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-063",
      "type": "multi-select",
      "question": "Session guarantees include which? (Select all that apply)",
      "options": [
        "Read-your-writes",
        "Monotonic reads",
        "Global serializability by default",
        "Writes-follow-reads"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Session guarantees are client-scoped and weaker than global serializability.",
      "detailedExplanation": "Start from \"session guarantees include which? (Select all that apply)\", then pressure-test the result against the options. Avoid pattern guessing and evaluate each candidate directly against the scenario. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-064",
      "type": "multi-select",
      "question": "Which are valid trade-offs of quorum reads/writes? (Select all that apply)",
      "options": [
        "Lower stale-read risk with stronger quorums",
        "Higher latency on critical paths",
        "No impact on availability under failures",
        "Can tune by endpoint criticality"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Quorums trade latency/availability for freshness and correctness.",
      "detailedExplanation": "If you keep \"valid trade-offs of quorum reads/writes? (Select all that apply)\" in view, the correct answer separates faster. Validate each option independently; do not select statements that are only partially true. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-065",
      "type": "multi-select",
      "question": "Causal consistency is most helpful when which conditions apply? (Select all that apply)",
      "options": [
        "Operations have happens-before dependencies",
        "Users expect reply-after-post ordering",
        "Independent analytics counters only",
        "Cross-service workflow order matters"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Causality preserves dependent update order without full linearizability.",
      "detailedExplanation": "The core signal here is \"causal consistency is most helpful when which conditions apply? (Select all that apply)\". Avoid pattern guessing and evaluate each candidate directly against the scenario. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-066",
      "type": "multi-select",
      "question": "Which strategies reduce stale-read impact without global strictness? (Select all that apply)",
      "options": [
        "Bounded staleness + freshness metadata",
        "Leader reads for critical endpoints",
        "Disable replication entirely",
        "Read repair and anti-entropy"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Targeted controls reduce stale anomalies while retaining scale benefits.",
      "detailedExplanation": "Use \"strategies reduce stale-read impact without global strictness? (Select all that apply)\" as your starting point, then verify tradeoffs carefully. Treat every option as a separate true/false test under the same constraints. Cache design quality is mostly about correctness boundaries, not only hit rate. Common pitfall: stale data despite high hit rates.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-067",
      "type": "multi-select",
      "question": "Signs that consistency requirements are underspecified include which? (Select all that apply)",
      "options": [
        "Frequent product bug reports about “data reverted”",
        "No documented endpoint freshness policy",
        "Clear entity-level invariants and SLAs",
        "Conflicting assumptions between teams"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Underspecification leads to inconsistent implementations and user confusion.",
      "detailedExplanation": "This prompt is really about \"signs that consistency requirements are underspecified include which? (Select all that\". Avoid pattern guessing and evaluate each candidate directly against the scenario. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-068",
      "type": "multi-select",
      "question": "Which are good practices for mixing consistency models by endpoint? (Select all that apply)",
      "options": [
        "Document guarantees per endpoint",
        "Use stronger guarantees only where invariants demand",
        "Hide all consistency errors from clients",
        "Expose freshness semantics in API contracts"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Explicit contracts and selective strictness keep systems understandable and efficient.",
      "detailedExplanation": "The decision turns on \"good practices for mixing consistency models by endpoint? (Select all that apply)\". Avoid pattern guessing and evaluate each candidate directly against the scenario. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-069",
      "type": "multi-select",
      "question": "What can increase non-monotonic read risk? (Select all that apply)",
      "options": [
        "Load balancing reads across lagging replicas",
        "No session stickiness or version tracking",
        "Always reading from leader",
        "Replica lag spikes during failover"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Replica lag and unconstrained replica selection cause time-travel read experiences.",
      "detailedExplanation": "Read this as a scenario about \"increase non-monotonic read risk? (Select all that apply)\". Avoid pattern guessing and evaluate each candidate directly against the scenario. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-070",
      "type": "multi-select",
      "question": "Which controls help preserve read-your-writes in replicated systems? (Select all that apply)",
      "options": [
        "Session token with last-seen write version",
        "Leader read on immediate follow-up requests",
        "Random follower read with no version check",
        "Sticky session within freshness window"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Version tracking or routing constraints protect immediate post-write reads.",
      "detailedExplanation": "Start from \"controls help preserve read-your-writes in replicated systems? (Select all that apply)\", then pressure-test the result against the options. Validate each option independently; do not select statements that are only partially true. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-071",
      "type": "multi-select",
      "question": "Eventual consistency can still be acceptable when which are true? (Select all that apply)",
      "options": [
        "Data is non-critical or tolerant to delay",
        "UI communicates pending convergence state",
        "Hard invariants require instant global agreement",
        "Compensating logic handles temporary divergence"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Eventual consistency is viable when delays are tolerable and explicitly managed.",
      "detailedExplanation": "The key clue in this question is \"eventual consistency can still be acceptable when which are true? (Select all that\". Avoid pattern guessing and evaluate each candidate directly against the scenario. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-072",
      "type": "multi-select",
      "question": "Which are realistic costs of strongest consistency on all paths? (Select all that apply)",
      "options": [
        "Higher latency",
        "Reduced availability during partitions",
        "Guaranteed lower cloud cost",
        "Throughput constraints on write-heavy workloads"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Strong consistency everywhere often overpays in latency and availability.",
      "detailedExplanation": "Read this as a scenario about \"realistic costs of strongest consistency on all paths? (Select all that apply)\". Avoid pattern guessing and evaluate each candidate directly against the scenario. The strongest answer explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-073",
      "type": "multi-select",
      "question": "Which practices improve consistency incident triage? (Select all that apply)",
      "options": [
        "Tag reads with replica/version metadata",
        "Track stale-read rate and monotonic-read violations",
        "Only monitor CPU utilization",
        "Correlate anomalies with replication lag"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Version and lag telemetry enables concrete consistency diagnosis.",
      "detailedExplanation": "The decision turns on \"practices improve consistency incident triage? (Select all that apply)\". Treat every option as a separate true/false test under the same constraints. The strongest answer explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-074",
      "type": "multi-select",
      "question": "For user profile edits across devices, which patterns help UX consistency? (Select all that apply)",
      "options": [
        "Read-your-writes session guarantee",
        "Monotonic reads across sessions",
        "Blind cache refresh without versioning",
        "Conflict-visible merge semantics when needed"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Session guarantees and explicit merge semantics reduce surprising regressions.",
      "detailedExplanation": "This prompt is really about \"for user profile edits across devices, which patterns help UX consistency? (Select all\". Avoid pattern guessing and evaluate each candidate directly against the scenario. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-075",
      "type": "multi-select",
      "question": "Which are valid consistency SLO dimensions? (Select all that apply)",
      "options": [
        "Freshness bound (max staleness)",
        "Monotonic-read violation rate",
        "Color palette consistency score",
        "Read-your-write success rate"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Consistency SLOs should be measurable by freshness and anomaly rates.",
      "detailedExplanation": "Use \"valid consistency SLO dimensions? (Select all that apply)\" as your starting point, then verify tradeoffs carefully. Treat every option as a separate true/false test under the same constraints. The strongest answer explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-076",
      "type": "multi-select",
      "question": "During failover, which choices reduce correctness risk? (Select all that apply) (Consistency Models Fundamentals context)",
      "options": [
        "Temporary stronger read path for critical entities",
        "Explicit degraded mode for non-critical reads",
        "Disable all write validation checks",
        "Clear client semantics for stale/unavailable states"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Failover policies should protect invariants and make degraded semantics explicit.",
      "detailedExplanation": "The core signal here is \"during failover, which choices reduce correctness risk? (Select all that apply)\". Avoid pattern guessing and evaluate each candidate directly against the scenario. The strongest answer explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-077",
      "type": "multi-select",
      "question": "Which anti-patterns often cause consistency bugs at scale? (Select all that apply)",
      "options": [
        "Assuming replica lag is always negligible",
        "Mixing write/read paths without guarantee mapping",
        "Per-endpoint guarantee documentation",
        "Using one global default without domain review"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Implicit assumptions and undocumented guarantees create latent consistency failures.",
      "detailedExplanation": "If you keep \"anti-patterns often cause consistency bugs at scale? (Select all that apply)\" in view, the correct answer separates faster. Treat every option as a separate true/false test under the same constraints. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-078",
      "type": "numeric-input",
      "question": "Write rate is 6,000 writes/sec and replica lag is 2.5 seconds. Approximate unreplicated writes in lag window?",
      "answer": 15000,
      "unit": "writes",
      "tolerance": 0.02,
      "explanation": "6,000 * 2.5 = 15,000 writes.",
      "detailedExplanation": "Start from \"write rate is 6,000 writes/sec and replica lag is 2\", then pressure-test the result against the options. Normalize units before computing so conversion mistakes do not propagate. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. If values like 6,000 and 2.5 seconds appear, convert them into one unit basis before comparison. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-079",
      "type": "numeric-input",
      "question": "An endpoint sees 2,000,000 reads/day. Measured stale-read rate is 0.3%. How many stale reads/day?",
      "answer": 6000,
      "unit": "reads",
      "tolerance": 0.02,
      "explanation": "0.003 * 2,000,000 = 6,000.",
      "detailedExplanation": "The key clue in this question is \"endpoint sees 2,000,000 reads/day\". Write the unit conversion path explicitly, then calculate, then sanity-check magnitude. Interface decisions should be justified by contract stability and client impact over time. Numbers such as 2,000 and 000 should be normalized first so downstream reasoning stays consistent. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-080",
      "type": "numeric-input",
      "question": "Follower lag p99 is 900ms. Freshness SLO is <= 500ms. By what percent is p99 over SLO?",
      "answer": 80,
      "unit": "%",
      "tolerance": 0.5,
      "explanation": "(900-500)/500 = 80% over SLO.",
      "detailedExplanation": "The key clue in this question is \"follower lag p99 is 900ms\". Normalize units before computing so conversion mistakes do not propagate. Tie the decision to concrete operational outcomes, not abstract reliability language. If values like 900ms and 500ms appear, convert them into one unit basis before comparison. Common pitfall: meeting average goals while missing tail-risk.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-081",
      "type": "numeric-input",
      "question": "A quorum setup uses 5 replicas. Minimum reads+writes quorum sum needed to avoid stale overlap (strict majority condition)?",
      "answer": 6,
      "unit": "quorum-sum",
      "tolerance": 0,
      "explanation": "Need R + W > N, so greater than 5 means minimum sum 6.",
      "detailedExplanation": "Start from \"quorum setup uses 5 replicas\", then pressure-test the result against the options. Write the unit conversion path explicitly, then calculate, then sanity-check magnitude. Cache design quality is mostly about correctness boundaries, not only hit rate. Numbers such as 5 and 6 should be normalized first so downstream reasoning stays consistent. Common pitfall: stale data despite high hit rates.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-082",
      "type": "numeric-input",
      "question": "A client performs 1,200 write-then-read flows/min. Read-your-write success is 97.5%. Failures per minute?",
      "answer": 30,
      "unit": "flows",
      "tolerance": 0.02,
      "explanation": "2.5% of 1,200 = 30 failures/min.",
      "detailedExplanation": "The decision turns on \"client performs 1,200 write-then-read flows/min\". Keep every transformation in one unit system and check order of magnitude at the end. Strong answers connect quorum/coordination settings to concrete correctness goals. Keep quantities like 1,200 and 97.5 in aligned units before selecting an answer. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-083",
      "type": "numeric-input",
      "question": "Monotonic-read violation rate is 0.08% across 4,500,000 reads/day. Violations/day?",
      "answer": 3600,
      "unit": "reads",
      "tolerance": 0.03,
      "explanation": "0.0008 * 4,500,000 = 3,600.",
      "detailedExplanation": "Read this as a scenario about \"monotonic-read violation rate is 0\". Keep every transformation in one unit system and check order of magnitude at the end. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Keep quantities like 0.08 and 4,500 in aligned units before selecting an answer. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-084",
      "type": "numeric-input",
      "question": "A critical path currently does 300ms reads from follower. Leader reads would be 420ms. Percent latency increase?",
      "answer": 40,
      "unit": "%",
      "tolerance": 0.3,
      "explanation": "(420-300)/300 = 40% increase.",
      "detailedExplanation": "Use \"critical path currently does 300ms reads from follower\" as your starting point, then verify tradeoffs carefully. Write the unit conversion path explicitly, then calculate, then sanity-check magnitude. Consistency decisions should be explicit about which conflicts are acceptable and why. Numbers such as 300ms and 420ms should be normalized first so downstream reasoning stays consistent. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-085",
      "type": "numeric-input",
      "question": "An app enforces 2-second bounded staleness. Observed lag is 1.6s. Remaining staleness budget?",
      "answer": 0.4,
      "unit": "seconds",
      "tolerance": 0.05,
      "explanation": "2.0 - 1.6 = 0.4 seconds.",
      "detailedExplanation": "This prompt is really about \"app enforces 2-second bounded staleness\". Keep every transformation in one unit system and check order of magnitude at the end. Strong answers connect quorum/coordination settings to concrete correctness goals. Keep quantities like 2 and 1.6s in aligned units before selecting an answer. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-086",
      "type": "numeric-input",
      "question": "A service has 24 replicas across regions; 3 are unhealthy. What percent of replicas remain healthy?",
      "answer": 87.5,
      "unit": "%",
      "tolerance": 0.3,
      "explanation": "21/24 = 87.5%.",
      "detailedExplanation": "If you keep \"service has 24 replicas across regions\" in view, the correct answer separates faster. Keep every transformation in one unit system and check order of magnitude at the end. Consistency decisions should be explicit about which conflicts are acceptable and why. Keep quantities like 24 and 3 in aligned units before selecting an answer. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-087",
      "type": "numeric-input",
      "question": "A strict-consistency endpoint handles 9,000 requests/min at $0.0004/request. Cost per hour?",
      "answer": 216,
      "unit": "USD",
      "tolerance": 0.02,
      "explanation": "9,000*60 = 540,000 req/hr; *0.0004 = $216/hr.",
      "detailedExplanation": "The core signal here is \"strict-consistency endpoint handles 9,000 requests/min at $0\". Write the unit conversion path explicitly, then calculate, then sanity-check magnitude. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Numbers such as 9,000 and 0.0004 should be normalized first so downstream reasoning stays consistent. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-088",
      "type": "numeric-input",
      "question": "Cross-device profile sync sees 72,000 reads/hour; 1.2% are non-monotonic. Non-monotonic reads/hour?",
      "answer": 864,
      "unit": "reads",
      "tolerance": 0.03,
      "explanation": "0.012 * 72,000 = 864.",
      "detailedExplanation": "The key clue in this question is \"cross-device profile sync sees 72,000 reads/hour\". Keep every transformation in one unit system and check order of magnitude at the end. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Keep quantities like 72,000 and 1.2 in aligned units before selecting an answer. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-089",
      "type": "numeric-input",
      "question": "A follower catch-up process replays 1,800 ops/sec. Backlog is 540,000 ops. Seconds to catch up (no new writes)?",
      "answer": 300,
      "unit": "seconds",
      "tolerance": 0,
      "explanation": "540,000 / 1,800 = 300 seconds.",
      "detailedExplanation": "Start from \"follower catch-up process replays 1,800 ops/sec\", then pressure-test the result against the options. Write the unit conversion path explicitly, then calculate, then sanity-check magnitude. Consistency decisions should be explicit about which conflicts are acceptable and why. Numbers such as 1,800 and 540,000 should be normalized first so downstream reasoning stays consistent. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-090",
      "type": "ordering",
      "question": "Order a consistency-design workflow from first to last.",
      "items": [
        "Define entity invariants and user semantics",
        "Map guarantees per endpoint",
        "Implement routing/quorum/session controls",
        "Measure anomaly rates and refine"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Start with semantics, then enforce and measure.",
      "detailedExplanation": "The core signal here is \"order a consistency-design workflow from first to last\". Place obvious extremes first, then sort the middle by pairwise comparison. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-091",
      "type": "ordering",
      "question": "Order by increasing consistency strength (typical).",
      "items": [
        "Eventual consistency",
        "Causal consistency",
        "Sequential consistency",
        "Linearizability"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Guarantee strength generally increases along this path.",
      "detailedExplanation": "If you keep \"order by increasing consistency strength (typical)\" in view, the correct answer separates faster. Order by relative scale and bottleneck effect, then validate neighboring items. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-092",
      "type": "ordering",
      "question": "Order by likely latency cost from lowest to highest.",
      "items": [
        "Local eventual follower read",
        "Bounded-staleness read with checks",
        "Leader/quorum read for critical path",
        "Global synchronous path across regions"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Stronger, broader coordination typically costs more latency.",
      "detailedExplanation": "This prompt is really about \"order by likely latency cost from lowest to highest\". Build the rank from biggest differences first, then refine with adjacent checks. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-093",
      "type": "ordering",
      "question": "Order incident triage for stale-read complaints.",
      "items": [
        "Confirm affected endpoints and semantics",
        "Correlate with lag/route/version telemetry",
        "Apply targeted stronger read policy",
        "Backfill tests/alerts for recurrence"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Scope, diagnose, mitigate, then harden.",
      "detailedExplanation": "Use \"order incident triage for stale-read complaints\" as your starting point, then verify tradeoffs carefully. Place obvious extremes first, then sort the middle by pairwise comparison. The strongest answer explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-094",
      "type": "ordering",
      "question": "Order by strongest to weakest fit for strict financial invariants.",
      "items": [
        "Linearizable critical writes/reads",
        "Quorum path with strong overlap",
        "Causal-only path",
        "Eventually consistent follower reads"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Invariant-critical flows need stronger guarantees.",
      "detailedExplanation": "Read this as a scenario about \"order by strongest to weakest fit for strict financial invariants\". Order by relative scale and bottleneck effect, then validate neighboring items. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-095",
      "type": "ordering",
      "question": "Order user session guarantees by increasing scope.",
      "items": [
        "Read-your-writes",
        "Monotonic reads",
        "Writes-follow-reads",
        "Global serializable behavior"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Session guarantees are client-scoped; global serial behavior is broader.",
      "detailedExplanation": "The decision turns on \"order user session guarantees by increasing scope\". Place obvious extremes first, then sort the middle by pairwise comparison. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-096",
      "type": "ordering",
      "question": "Order rollout safety for consistency changes.",
      "items": [
        "Canary affected endpoints",
        "Monitor freshness/anomaly SLOs",
        "Expand traffic gradually",
        "Finalize policy docs and guardrails"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Progressive rollout with telemetry limits blast radius.",
      "detailedExplanation": "Start from \"order rollout safety for consistency changes\", then pressure-test the result against the options. Order by relative scale and bottleneck effect, then validate neighboring items. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-097",
      "type": "ordering",
      "question": "Order by increasing stale-read risk (typical).",
      "items": [
        "Leader read after write",
        "Version-checked follower read",
        "Random follower read with moderate lag",
        "Cross-region follower read with no version check"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Risk rises as routing/version constraints weaken.",
      "detailedExplanation": "The key clue in this question is \"order by increasing stale-read risk (typical)\". Place obvious extremes first, then sort the middle by pairwise comparison. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-098",
      "type": "ordering",
      "question": "Order consistency-contract maturity.",
      "items": [
        "Implicit assumptions only",
        "Informal endpoint comments",
        "Documented per-endpoint guarantees",
        "Documented guarantees with automated conformance tests"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Maturity increases with explicit, testable contracts.",
      "detailedExplanation": "The core signal here is \"order consistency-contract maturity\". Place obvious extremes first, then sort the middle by pairwise comparison. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-099",
      "type": "ordering",
      "question": "Order by increasing tolerance to partitions (availability-biased view).",
      "items": [
        "Globally synchronous strict path",
        "Quorum-based strict path",
        "Session-level guarantees with fallbacks",
        "Eventually consistent local-availability path"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Availability under partitions generally increases as strict coordination is reduced.",
      "detailedExplanation": "If you keep \"order by increasing tolerance to partitions (availability-biased view)\" in view, the correct answer separates faster. Order by relative scale and bottleneck effect, then validate neighboring items. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: meeting average goals while missing tail-risk.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    },
    {
      "id": "cc-cm-100",
      "type": "ordering",
      "question": "Order mitigation choices from fastest tactical to slowest structural.",
      "items": [
        "Route critical reads to leader temporarily",
        "Enable version-token checks for sessions",
        "Introduce endpoint-specific tunable consistency policy",
        "Re-architect data ownership boundaries"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Immediate routing fixes are fastest; architecture shifts take longest.",
      "detailedExplanation": "Start from \"order mitigation choices from fastest tactical to slowest structural\", then pressure-test the result against the options. Order by relative scale and bottleneck effect, then validate neighboring items. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "consistency-models-fundamentals"],
      "difficulty": "senior"
    }
  ]
}
