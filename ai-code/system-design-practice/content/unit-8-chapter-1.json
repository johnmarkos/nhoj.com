{
  "unit": 8,
  "unitTitle": "Consistency & Coordination",
  "chapter": 1,
  "chapterTitle": "Consistency Models Fundamentals",
  "chapterDescription": "Core consistency guarantees and trade-offs for read/write behavior, user-visible anomalies, and invariant-critical paths in distributed systems.",
  "problems": [
    {
      "id": "cc-cm-001",
      "type": "multiple-choice",
      "question": "A global profile service is facing read-your-writes expectations. Which consistency-model decision is strongest? Recent user reports mention stale profile values after edits.",
      "options": [
        "Require linearizable reads on critical write-followed-by-read paths and scope them narrowly.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics."
      ],
      "correct": 0,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-002",
      "type": "multiple-choice",
      "question": "A payment authorization API is facing strict no-stale-read checkout rule. Which consistency-model decision is strongest? This regression appears most during regional failover windows.",
      "options": [
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Use read-your-writes/session consistency for user-facing state while keeping less critical paths eventually consistent."
      ],
      "correct": 3,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-003",
      "type": "multiple-choice",
      "question": "A social feed timeline API is facing cross-device session updates. Which consistency-model decision is strongest? The team must preserve low latency on non-critical reads.",
      "options": [
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Prefer causal consistency where related updates must preserve happens-before relationships.",
        "Standardize all reads as eventually consistent with no exception handling."
      ],
      "correct": 2,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. Convert targets into concrete counts and time budgets first, then reason about whether incident frequency and recovery time can satisfy them.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-004",
      "type": "multiple-choice",
      "question": "A inventory reservation service is facing multi-region replica lag. Which consistency-model decision is strongest? Critical checkout invariants are now under stricter scrutiny.",
      "options": [
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Pin critical reads to leader/quorum paths when stale data is unacceptable.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency."
      ],
      "correct": 1,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-005",
      "type": "multiple-choice",
      "question": "A messaging inbox API is facing partition tolerance during failover. Which consistency-model decision is strongest? Multi-device sessions amplify inconsistency visibility.",
      "options": [
        "Adopt tunable consistency with stronger writes for invariant-critical entities.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics."
      ],
      "correct": 0,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ]
    },
    {
      "id": "cc-cm-006",
      "type": "multiple-choice",
      "question": "A feature-flag delivery API is facing high write burst with follower reads. Which consistency-model decision is strongest? Replica lag spikes during write bursts expose weak guarantees.",
      "options": [
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Separate strict correctness endpoints from low-latency eventually consistent read endpoints."
      ],
      "correct": 3,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-007",
      "type": "multiple-choice",
      "question": "A ride dispatch state service is facing causal update chains between services. Which consistency-model decision is strongest? Support tickets describe data “time travel” behavior.",
      "options": [
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Use monotonic-read guarantees to prevent time-travel user experiences across devices.",
        "Standardize all reads as eventually consistent with no exception handling."
      ],
      "correct": 2,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-008",
      "type": "multiple-choice",
      "question": "A support ticket backend is facing client retry/reorder behavior. Which consistency-model decision is strongest? Incident review requires explicit endpoint-level contracts.",
      "options": [
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Apply bounded-staleness policy with explicit freshness budgets and fallback behavior.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency."
      ],
      "correct": 1,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. Convert targets into concrete counts and time budgets first, then reason about whether incident frequency and recovery time can satisfy them.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        }
      ]
    },
    {
      "id": "cc-cm-009",
      "type": "multiple-choice",
      "question": "A ad campaign manager is facing low-latency read requirement. Which consistency-model decision is strongest? The fix should avoid over-strengthening every endpoint.",
      "options": [
        "Use session stickiness plus tokenized version checks to enforce user-visible consistency guarantees.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics."
      ],
      "correct": 0,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. Convert targets into concrete counts and time budgets first, then reason about whether incident frequency and recovery time can satisfy them.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-010",
      "type": "multiple-choice",
      "question": "A analytics query endpoint is facing audit correctness requirement. Which consistency-model decision is strongest? Audit stakeholders require deterministic critical-path behavior.",
      "options": [
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Design explicit degradation mode that trades freshness for availability on non-critical reads."
      ],
      "correct": 3,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-011",
      "type": "multiple-choice",
      "question": "A document collaboration API is facing read-your-writes expectations. Which consistency-model decision is strongest? Recent traffic growth increased follower-read usage.",
      "options": [
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Require linearizable reads on critical write-followed-by-read paths and scope them narrowly.",
        "Standardize all reads as eventually consistent with no exception handling."
      ],
      "correct": 2,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-012",
      "type": "multiple-choice",
      "question": "A bank transfer ledger API is facing strict no-stale-read checkout rule. Which consistency-model decision is strongest? The service mixes critical and non-critical entities.",
      "options": [
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Use read-your-writes/session consistency for user-facing state while keeping less critical paths eventually consistent.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency."
      ],
      "correct": 1,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-013",
      "type": "multiple-choice",
      "question": "A shopping cart service is facing cross-device session updates. Which consistency-model decision is strongest? Client retries increase reordering risk across regions.",
      "options": [
        "Prefer causal consistency where related updates must preserve happens-before relationships.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics."
      ],
      "correct": 0,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-014",
      "type": "multiple-choice",
      "question": "A notification preference API is facing multi-region replica lag. Which consistency-model decision is strongest? On-call reports stale reads concentrated in one path.",
      "options": [
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Pin critical reads to leader/quorum paths when stale data is unacceptable."
      ],
      "correct": 3,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-015",
      "type": "multiple-choice",
      "question": "A fraud decision API is facing partition tolerance during failover. Which consistency-model decision is strongest? A quick mitigation is needed before full architecture changes.",
      "options": [
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Adopt tunable consistency with stronger writes for invariant-critical entities.",
        "Standardize all reads as eventually consistent with no exception handling."
      ],
      "correct": 2,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ]
    },
    {
      "id": "cc-cm-016",
      "type": "multiple-choice",
      "question": "A game session coordinator is facing high write burst with follower reads. Which consistency-model decision is strongest? The current API docs do not define freshness semantics clearly.",
      "options": [
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Separate strict correctness endpoints from low-latency eventually consistent read endpoints.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency."
      ],
      "correct": 1,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-017",
      "type": "multiple-choice",
      "question": "A identity profile API is facing causal update chains between services. Which consistency-model decision is strongest? Cost constraints rule out global strictness everywhere.",
      "options": [
        "Use monotonic-read guarantees to prevent time-travel user experiences across devices.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics."
      ],
      "correct": 0,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-018",
      "type": "multiple-choice",
      "question": "A catalog availability API is facing client retry/reorder behavior. Which consistency-model decision is strongest? The UI requires clear behavior when freshness is uncertain.",
      "options": [
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Apply bounded-staleness policy with explicit freshness budgets and fallback behavior."
      ],
      "correct": 3,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. Convert targets into concrete counts and time budgets first, then reason about whether incident frequency and recovery time can satisfy them.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        }
      ]
    },
    {
      "id": "cc-cm-019",
      "type": "multiple-choice",
      "question": "A order tracking service is facing low-latency read requirement. Which consistency-model decision is strongest? SLOs now track monotonic-read violations explicitly.",
      "options": [
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Use session stickiness plus tokenized version checks to enforce user-visible consistency guarantees.",
        "Standardize all reads as eventually consistent with no exception handling."
      ],
      "correct": 2,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. Convert targets into concrete counts and time budgets first, then reason about whether incident frequency and recovery time can satisfy them.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-020",
      "type": "multiple-choice",
      "question": "A customer settings API is facing audit correctness requirement. Which consistency-model decision is strongest? Teams disagree on whether session guarantees are required.",
      "options": [
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Design explicit degradation mode that trades freshness for availability on non-critical reads.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency."
      ],
      "correct": 1,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-021",
      "type": "multiple-choice",
      "question": "A global profile service is facing read-your-writes expectations. Which consistency-model decision is strongest? Cross-service update chains are creating causal confusion.",
      "options": [
        "Require linearizable reads on critical write-followed-by-read paths and scope them narrowly.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics."
      ],
      "correct": 0,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-022",
      "type": "multiple-choice",
      "question": "A payment authorization API is facing strict no-stale-read checkout rule. Which consistency-model decision is strongest? The platform can enforce version-token routing decisions.",
      "options": [
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Use read-your-writes/session consistency for user-facing state while keeping less critical paths eventually consistent."
      ],
      "correct": 3,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-023",
      "type": "multiple-choice",
      "question": "A social feed timeline API is facing cross-device session updates. Which consistency-model decision is strongest? Business impact is tied to incorrect post-write reads.",
      "options": [
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Prefer causal consistency where related updates must preserve happens-before relationships.",
        "Standardize all reads as eventually consistent with no exception handling."
      ],
      "correct": 2,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-024",
      "type": "multiple-choice",
      "question": "A inventory reservation service is facing multi-region replica lag. Which consistency-model decision is strongest? Some endpoints can tolerate bounded staleness if explicit.",
      "options": [
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Pin critical reads to leader/quorum paths when stale data is unacceptable.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency."
      ],
      "correct": 1,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-025",
      "type": "multiple-choice",
      "question": "A messaging inbox API is facing partition tolerance during failover. Which consistency-model decision is strongest? The incident occurs mainly on follower-heavy traffic.",
      "options": [
        "Adopt tunable consistency with stronger writes for invariant-critical entities.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics."
      ],
      "correct": 0,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. Convert targets into concrete counts and time budgets first, then reason about whether incident frequency and recovery time can satisfy them.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        }
      ]
    },
    {
      "id": "cc-cm-026",
      "type": "multiple-choice",
      "question": "A feature-flag delivery API is facing high write burst with follower reads. Which consistency-model decision is strongest? Failback events temporarily widen staleness windows.",
      "options": [
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Separate strict correctness endpoints from low-latency eventually consistent read endpoints."
      ],
      "correct": 3,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-027",
      "type": "multiple-choice",
      "question": "A ride dispatch state service is facing causal update chains between services. Which consistency-model decision is strongest? Critical endpoints are a minority of total traffic.",
      "options": [
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Use monotonic-read guarantees to prevent time-travel user experiences across devices.",
        "Standardize all reads as eventually consistent with no exception handling."
      ],
      "correct": 2,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-028",
      "type": "multiple-choice",
      "question": "A support ticket backend is facing client retry/reorder behavior. Which consistency-model decision is strongest? Engineering leadership requested measurable consistency SLOs.",
      "options": [
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Apply bounded-staleness policy with explicit freshness budgets and fallback behavior.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency."
      ],
      "correct": 1,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. Message systems should be evaluated on delivery semantics, ordering scope, replay behavior, and backpressure handling under failure.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Retry pattern",
          "url": "https://learn.microsoft.com/en-us/azure/architecture/patterns/retry"
        }
      ]
    },
    {
      "id": "cc-cm-029",
      "type": "multiple-choice",
      "question": "A ad campaign manager is facing low-latency read requirement. Which consistency-model decision is strongest? The solution must preserve availability under partial failure.",
      "options": [
        "Use session stickiness plus tokenized version checks to enforce user-visible consistency guarantees.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics."
      ],
      "correct": 0,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. Convert targets into concrete counts and time budgets first, then reason about whether incident frequency and recovery time can satisfy them.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-030",
      "type": "multiple-choice",
      "question": "A analytics query endpoint is facing audit correctness requirement. Which consistency-model decision is strongest? Convergence eventually happens but user trust is degraded.",
      "options": [
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Design explicit degradation mode that trades freshness for availability on non-critical reads."
      ],
      "correct": 3,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-031",
      "type": "multiple-choice",
      "question": "A document collaboration API is facing read-your-writes expectations. Which consistency-model decision is strongest? Current behavior differs by region for the same user action.",
      "options": [
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Require linearizable reads on critical write-followed-by-read paths and scope them narrowly.",
        "Standardize all reads as eventually consistent with no exception handling."
      ],
      "correct": 2,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-032",
      "type": "multiple-choice",
      "question": "A bank transfer ledger API is facing strict no-stale-read checkout rule. Which consistency-model decision is strongest? Mitigation should be canary-safe and reversible.",
      "options": [
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Use read-your-writes/session consistency for user-facing state while keeping less critical paths eventually consistent.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency."
      ],
      "correct": 1,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-033",
      "type": "multiple-choice",
      "question": "A shopping cart service is facing cross-device session updates. Which consistency-model decision is strongest? Error semantics for stale vs unavailable need to be explicit.",
      "options": [
        "Prefer causal consistency where related updates must preserve happens-before relationships.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics."
      ],
      "correct": 0,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-034",
      "type": "multiple-choice",
      "question": "A notification preference API is facing multi-region replica lag. Which consistency-model decision is strongest? The team wants a principled consistency rubric, not ad hoc fixes.",
      "options": [
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Pin critical reads to leader/quorum paths when stale data is unacceptable."
      ],
      "correct": 3,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-035",
      "type": "multiple-choice",
      "question": "A fraud decision API is facing partition tolerance during failover. Which consistency-model decision is strongest? Post-incident prevention is required in the first rollout.",
      "options": [
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Adopt tunable consistency with stronger writes for invariant-critical entities.",
        "Standardize all reads as eventually consistent with no exception handling."
      ],
      "correct": 2,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere. Convert targets into concrete counts and time budgets first, then reason about whether incident frequency and recovery time can satisfy them.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        }
      ]
    },
    {
      "id": "cc-cm-036",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: inventory reservation service is seeing issues around partition tolerance during failover. What is the most likely diagnosis?",
          "options": [
            "The current model for inventory reservation service does not match partition tolerance during failover, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees."
          ],
          "correct": 0,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. Message systems should be evaluated on delivery semantics, ordering scope, replay behavior, and backpressure handling under failure."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest while keeping p99 under target?",
          "options": [
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Prefer causal consistency where related updates must preserve happens-before relationships."
          ],
          "correct": 3,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. Convert targets into concrete counts and time budgets first, then reason about whether incident frequency and recovery time can satisfy them."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-037",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: messaging inbox API is seeing issues around high write burst with follower reads. What is the most likely diagnosis?",
          "options": [
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for messaging inbox API does not match high write burst with follower reads, causing user-visible anomalies."
          ],
          "correct": 3,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest without violating checkout correctness?",
          "options": [
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Pin critical reads to leader/quorum paths when stale data is unacceptable.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI."
          ],
          "correct": 2,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-038",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: feature-flag delivery API is seeing issues around causal update chains between services. What is the most likely diagnosis?",
          "options": [
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for feature-flag delivery API does not match causal update chains between services, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good."
          ],
          "correct": 2,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest under replica lag spikes?",
          "options": [
            "Do nothing and rely on passive replica convergence only.",
            "Adopt tunable consistency with stronger writes for invariant-critical entities.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement."
          ],
          "correct": 1,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-039",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: ride dispatch state service is seeing issues around client retry/reorder behavior. What is the most likely diagnosis?",
          "options": [
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for ride dispatch state service does not match client retry/reorder behavior, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches."
          ],
          "correct": 1,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. Message systems should be evaluated on delivery semantics, ordering scope, replay behavior, and backpressure handling under failure."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest during regional failover?",
          "options": [
            "Separate strict correctness endpoints from low-latency eventually consistent read endpoints.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only."
          ],
          "correct": 0,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-040",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: support ticket backend is seeing issues around low-latency read requirement. What is the most likely diagnosis?",
          "options": [
            "The current model for support ticket backend does not match low-latency read requirement, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees."
          ],
          "correct": 0,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. Convert targets into concrete counts and time budgets first, then reason about whether incident frequency and recovery time can satisfy them."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest with mobile multi-device clients?",
          "options": [
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Use monotonic-read guarantees to prevent time-travel user experiences across devices."
          ],
          "correct": 3,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-041",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: ad campaign manager is seeing issues around audit correctness requirement. What is the most likely diagnosis?",
          "options": [
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for ad campaign manager does not match audit correctness requirement, causing user-visible anomalies."
          ],
          "correct": 3,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest while limiting quorum read cost?",
          "options": [
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Apply bounded-staleness policy with explicit freshness budgets and fallback behavior.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI."
          ],
          "correct": 2,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-042",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: analytics query endpoint is seeing issues around read-your-writes expectations. What is the most likely diagnosis?",
          "options": [
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for analytics query endpoint does not match read-your-writes expectations, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good."
          ],
          "correct": 2,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest under intermittent partitions?",
          "options": [
            "Do nothing and rely on passive replica convergence only.",
            "Use session stickiness plus tokenized version checks to enforce user-visible consistency guarantees.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement."
          ],
          "correct": 1,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-043",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: document collaboration API is seeing issues around strict no-stale-read checkout rule. What is the most likely diagnosis?",
          "options": [
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for document collaboration API does not match strict no-stale-read checkout rule, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches."
          ],
          "correct": 1,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest without forcing global sync everywhere?",
          "options": [
            "Design explicit degradation mode that trades freshness for availability on non-critical reads.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only."
          ],
          "correct": 0,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-044",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: bank transfer ledger API is seeing issues around cross-device session updates. What is the most likely diagnosis?",
          "options": [
            "The current model for bank transfer ledger API does not match cross-device session updates, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees."
          ],
          "correct": 0,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest during burst traffic windows?",
          "options": [
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Require linearizable reads on critical write-followed-by-read paths and scope them narrowly."
          ],
          "correct": 3,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-045",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: shopping cart service is seeing issues around multi-region replica lag. What is the most likely diagnosis?",
          "options": [
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for shopping cart service does not match multi-region replica lag, causing user-visible anomalies."
          ],
          "correct": 3,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest with strict audit surfaces?",
          "options": [
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Use read-your-writes/session consistency for user-facing state while keeping less critical paths eventually consistent.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI."
          ],
          "correct": 2,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-046",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: notification preference API is seeing issues around partition tolerance during failover. What is the most likely diagnosis?",
          "options": [
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for notification preference API does not match partition tolerance during failover, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good."
          ],
          "correct": 2,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest while preserving availability goals?",
          "options": [
            "Do nothing and rely on passive replica convergence only.",
            "Prefer causal consistency where related updates must preserve happens-before relationships.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement."
          ],
          "correct": 1,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. Convert targets into concrete counts and time budgets first, then reason about whether incident frequency and recovery time can satisfy them."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-047",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: fraud decision API is seeing issues around high write burst with follower reads. What is the most likely diagnosis?",
          "options": [
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for fraud decision API does not match high write burst with follower reads, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches."
          ],
          "correct": 1,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest under edge-cache refresh delays?",
          "options": [
            "Pin critical reads to leader/quorum paths when stale data is unacceptable.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only."
          ],
          "correct": 0,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. A strong caching answer specifies key design, invalidation behavior, and the acceptable staleness window, not just a cache hit-rate target."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-048",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: game session coordinator is seeing issues around causal update chains between services. What is the most likely diagnosis?",
          "options": [
            "The current model for game session coordinator does not match causal update chains between services, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees."
          ],
          "correct": 0,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest with mixed critical/non-critical entities?",
          "options": [
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Adopt tunable consistency with stronger writes for invariant-critical entities."
          ],
          "correct": 3,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-049",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: identity profile API is seeing issues around client retry/reorder behavior. What is the most likely diagnosis?",
          "options": [
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for identity profile API does not match client retry/reorder behavior, causing user-visible anomalies."
          ],
          "correct": 3,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest without causing user time-travel reads?",
          "options": [
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Separate strict correctness endpoints from low-latency eventually consistent read endpoints.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI."
          ],
          "correct": 2,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-050",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: catalog availability API is seeing issues around low-latency read requirement. What is the most likely diagnosis?",
          "options": [
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for catalog availability API does not match low-latency read requirement, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good."
          ],
          "correct": 2,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. Convert targets into concrete counts and time budgets first, then reason about whether incident frequency and recovery time can satisfy them."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest under retry reordering behavior?",
          "options": [
            "Do nothing and rely on passive replica convergence only.",
            "Use monotonic-read guarantees to prevent time-travel user experiences across devices.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement."
          ],
          "correct": 1,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. Message systems should be evaluated on delivery semantics, ordering scope, replay behavior, and backpressure handling under failure."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-051",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: order tracking service is seeing issues around audit correctness requirement. What is the most likely diagnosis?",
          "options": [
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for order tracking service does not match audit correctness requirement, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches."
          ],
          "correct": 1,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest with constrained backend capacity?",
          "options": [
            "Apply bounded-staleness policy with explicit freshness budgets and fallback behavior.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only."
          ],
          "correct": 0,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-052",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: customer settings API is seeing issues around read-your-writes expectations. What is the most likely diagnosis?",
          "options": [
            "The current model for customer settings API does not match read-your-writes expectations, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees."
          ],
          "correct": 0,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest while controlling stale-read risk?",
          "options": [
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Use session stickiness plus tokenized version checks to enforce user-visible consistency guarantees."
          ],
          "correct": 3,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-053",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: global profile service is seeing issues around strict no-stale-read checkout rule. What is the most likely diagnosis?",
          "options": [
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for global profile service does not match strict no-stale-read checkout rule, causing user-visible anomalies."
          ],
          "correct": 3,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest during dependency brownouts?",
          "options": [
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Design explicit degradation mode that trades freshness for availability on non-critical reads.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI."
          ],
          "correct": 2,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-054",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: payment authorization API is seeing issues around cross-device session updates. What is the most likely diagnosis?",
          "options": [
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for payment authorization API does not match cross-device session updates, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good."
          ],
          "correct": 2,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest with tenant-isolation constraints?",
          "options": [
            "Do nothing and rely on passive replica convergence only.",
            "Require linearizable reads on critical write-followed-by-read paths and scope them narrowly.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement."
          ],
          "correct": 1,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-055",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: social feed timeline API is seeing issues around multi-region replica lag. What is the most likely diagnosis?",
          "options": [
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for social feed timeline API does not match multi-region replica lag, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches."
          ],
          "correct": 1,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest before wider rollout?",
          "options": [
            "Use read-your-writes/session consistency for user-facing state while keeping less critical paths eventually consistent.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only."
          ],
          "correct": 0,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-056",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: inventory reservation service is seeing issues around partition tolerance during failover. What is the most likely diagnosis?",
          "options": [
            "The current model for inventory reservation service does not match partition tolerance during failover, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees."
          ],
          "correct": 0,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. Message systems should be evaluated on delivery semantics, ordering scope, replay behavior, and backpressure handling under failure."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest with clear error semantics?",
          "options": [
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Prefer causal consistency where related updates must preserve happens-before relationships."
          ],
          "correct": 3,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-057",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: messaging inbox API is seeing issues around high write burst with follower reads. What is the most likely diagnosis?",
          "options": [
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for messaging inbox API does not match high write burst with follower reads, causing user-visible anomalies."
          ],
          "correct": 3,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest under backlog recovery pressure?",
          "options": [
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Pin critical reads to leader/quorum paths when stale data is unacceptable.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI."
          ],
          "correct": 2,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-058",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: feature-flag delivery API is seeing issues around causal update chains between services. What is the most likely diagnosis?",
          "options": [
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for feature-flag delivery API does not match causal update chains between services, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good."
          ],
          "correct": 2,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest while preserving write throughput?",
          "options": [
            "Do nothing and rely on passive replica convergence only.",
            "Adopt tunable consistency with stronger writes for invariant-critical entities.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement."
          ],
          "correct": 1,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-059",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: ride dispatch state service is seeing issues around client retry/reorder behavior. What is the most likely diagnosis?",
          "options": [
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for ride dispatch state service does not match client retry/reorder behavior, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches."
          ],
          "correct": 1,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. Message systems should be evaluated on delivery semantics, ordering scope, replay behavior, and backpressure handling under failure."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest during incident containment?",
          "options": [
            "Separate strict correctness endpoints from low-latency eventually consistent read endpoints.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only."
          ],
          "correct": 0,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. Convert targets into concrete counts and time budgets first, then reason about whether incident frequency and recovery time can satisfy them."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-060",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: support ticket backend is seeing issues around low-latency read requirement. What is the most likely diagnosis?",
          "options": [
            "The current model for support ticket backend does not match low-latency read requirement, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees."
          ],
          "correct": 0,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level. Convert targets into concrete counts and time budgets first, then reason about whether incident frequency and recovery time can satisfy them."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest with explicit freshness SLOs?",
          "options": [
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Use monotonic-read guarantees to prevent time-travel user experiences across devices."
          ],
          "correct": 3,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-061",
      "type": "multi-select",
      "question": "Which are common user-facing anomalies under weak consistency? (Select all that apply)",
      "options": [
        "Read-your-write missing immediately after update",
        "Non-monotonic reads across requests",
        "Guaranteed strict serial order for all operations",
        "Conflicting views across devices"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Weak consistency can produce stale, non-monotonic, or divergent views.",
      "detailedExplanation": "Weak consistency can produce stale, non-monotonic, or divergent views. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-062",
      "type": "multi-select",
      "question": "When is linearizability typically justified? (Select all that apply)",
      "options": [
        "Financial invariants and double-spend prevention",
        "Inventory oversell prevention at checkout",
        "All analytics dashboard reads",
        "Critical leader-election state"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Use strongest guarantees where correctness failures are high cost.",
      "detailedExplanation": "Use strongest guarantees where correctness failures are high cost. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-063",
      "type": "multi-select",
      "question": "Session guarantees include which? (Select all that apply)",
      "options": [
        "Read-your-writes",
        "Monotonic reads",
        "Global serializability by default",
        "Writes-follow-reads"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Session guarantees are client-scoped and weaker than global serializability.",
      "detailedExplanation": "Session guarantees are client-scoped and weaker than global serializability. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-064",
      "type": "multi-select",
      "question": "Which are valid trade-offs of quorum reads/writes? (Select all that apply)",
      "options": [
        "Lower stale-read risk with stronger quorums",
        "Higher latency on critical paths",
        "No impact on availability under failures",
        "Can tune by endpoint criticality"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Quorums trade latency/availability for freshness and correctness.",
      "detailedExplanation": "Quorums trade latency/availability for freshness and correctness. Convert targets into concrete counts and time budgets first, then reason about whether incident frequency and recovery time can satisfy them.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-065",
      "type": "multi-select",
      "question": "Causal consistency is most helpful when which conditions apply? (Select all that apply)",
      "options": [
        "Operations have happens-before dependencies",
        "Users expect reply-after-post ordering",
        "Independent analytics counters only",
        "Cross-service workflow order matters"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Causality preserves dependent update order without full linearizability.",
      "detailedExplanation": "Causality preserves dependent update order without full linearizability. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-066",
      "type": "multi-select",
      "question": "Which strategies reduce stale-read impact without global strictness? (Select all that apply)",
      "options": [
        "Bounded staleness + freshness metadata",
        "Leader reads for critical endpoints",
        "Disable replication entirely",
        "Read repair and anti-entropy"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Targeted controls reduce stale anomalies while retaining scale benefits.",
      "detailedExplanation": "Targeted controls reduce stale anomalies while retaining scale benefits. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-067",
      "type": "multi-select",
      "question": "Signs that consistency requirements are underspecified include which? (Select all that apply)",
      "options": [
        "Frequent product bug reports about “data reverted”",
        "No documented endpoint freshness policy",
        "Clear entity-level invariants and SLAs",
        "Conflicting assumptions between teams"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Underspecification leads to inconsistent implementations and user confusion.",
      "detailedExplanation": "Underspecification leads to inconsistent implementations and user confusion. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-068",
      "type": "multi-select",
      "question": "Which are good practices for mixing consistency models by endpoint? (Select all that apply)",
      "options": [
        "Document guarantees per endpoint",
        "Use stronger guarantees only where invariants demand",
        "Hide all consistency errors from clients",
        "Expose freshness semantics in API contracts"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Explicit contracts and selective strictness keep systems understandable and efficient.",
      "detailedExplanation": "Explicit contracts and selective strictness keep systems understandable and efficient. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-069",
      "type": "multi-select",
      "question": "What can increase non-monotonic read risk? (Select all that apply)",
      "options": [
        "Load balancing reads across lagging replicas",
        "No session stickiness or version tracking",
        "Always reading from leader",
        "Replica lag spikes during failover"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Replica lag and unconstrained replica selection cause time-travel read experiences.",
      "detailedExplanation": "Replica lag and unconstrained replica selection cause time-travel read experiences. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-070",
      "type": "multi-select",
      "question": "Which controls help preserve read-your-writes in replicated systems? (Select all that apply)",
      "options": [
        "Session token with last-seen write version",
        "Leader read on immediate follow-up requests",
        "Random follower read with no version check",
        "Sticky session within freshness window"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Version tracking or routing constraints protect immediate post-write reads.",
      "detailedExplanation": "Version tracking or routing constraints protect immediate post-write reads. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-071",
      "type": "multi-select",
      "question": "Eventual consistency can still be acceptable when which are true? (Select all that apply)",
      "options": [
        "Data is non-critical or tolerant to delay",
        "UI communicates pending convergence state",
        "Hard invariants require instant global agreement",
        "Compensating logic handles temporary divergence"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Eventual consistency is viable when delays are tolerable and explicitly managed.",
      "detailedExplanation": "Eventual consistency is viable when delays are tolerable and explicitly managed. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-072",
      "type": "multi-select",
      "question": "Which are realistic costs of strongest consistency on all paths? (Select all that apply)",
      "options": [
        "Higher latency",
        "Reduced availability during partitions",
        "Guaranteed lower cloud cost",
        "Throughput constraints on write-heavy workloads"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Strong consistency everywhere often overpays in latency and availability.",
      "detailedExplanation": "Strong consistency everywhere often overpays in latency and availability. Convert targets into concrete counts and time budgets first, then reason about whether incident frequency and recovery time can satisfy them.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-073",
      "type": "multi-select",
      "question": "Which practices improve consistency incident triage? (Select all that apply)",
      "options": [
        "Tag reads with replica/version metadata",
        "Track stale-read rate and monotonic-read violations",
        "Only monitor CPU utilization",
        "Correlate anomalies with replication lag"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Version and lag telemetry enables concrete consistency diagnosis.",
      "detailedExplanation": "Version and lag telemetry enables concrete consistency diagnosis. Convert targets into concrete counts and time budgets first, then reason about whether incident frequency and recovery time can satisfy them.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        }
      ]
    },
    {
      "id": "cc-cm-074",
      "type": "multi-select",
      "question": "For user profile edits across devices, which patterns help UX consistency? (Select all that apply)",
      "options": [
        "Read-your-writes session guarantee",
        "Monotonic reads across sessions",
        "Blind cache refresh without versioning",
        "Conflict-visible merge semantics when needed"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Session guarantees and explicit merge semantics reduce surprising regressions.",
      "detailedExplanation": "Session guarantees and explicit merge semantics reduce surprising regressions. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-075",
      "type": "multi-select",
      "question": "Which are valid consistency SLO dimensions? (Select all that apply)",
      "options": [
        "Freshness bound (max staleness)",
        "Monotonic-read violation rate",
        "Color palette consistency score",
        "Read-your-write success rate"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Consistency SLOs should be measurable by freshness and anomaly rates.",
      "detailedExplanation": "Consistency SLOs should be measurable by freshness and anomaly rates. Convert targets into concrete counts and time budgets first, then reason about whether incident frequency and recovery time can satisfy them.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-076",
      "type": "multi-select",
      "question": "During failover, which choices reduce correctness risk? (Select all that apply)",
      "options": [
        "Temporary stronger read path for critical entities",
        "Explicit degraded mode for non-critical reads",
        "Disable all write validation checks",
        "Clear client semantics for stale/unavailable states"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Failover policies should protect invariants and make degraded semantics explicit.",
      "detailedExplanation": "Failover policies should protect invariants and make degraded semantics explicit. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-077",
      "type": "multi-select",
      "question": "Which anti-patterns often cause consistency bugs at scale? (Select all that apply)",
      "options": [
        "Assuming replica lag is always negligible",
        "Mixing write/read paths without guarantee mapping",
        "Per-endpoint guarantee documentation",
        "Using one global default without domain review"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Implicit assumptions and undocumented guarantees create latent consistency failures.",
      "detailedExplanation": "Implicit assumptions and undocumented guarantees create latent consistency failures. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-078",
      "type": "numeric-input",
      "question": "Write rate is 6,000 writes/sec and replica lag is 2.5 seconds. Approximate unreplicated writes in lag window?",
      "answer": 15000,
      "unit": "writes",
      "tolerance": 0.02,
      "explanation": "6,000 * 2.5 = 15,000 writes.",
      "detailedExplanation": "6,000 * 2.5 = 15,000 writes. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-079",
      "type": "numeric-input",
      "question": "An endpoint sees 2,000,000 reads/day. Measured stale-read rate is 0.3%. How many stale reads/day?",
      "answer": 6000,
      "unit": "reads",
      "tolerance": 0.02,
      "explanation": "0.003 * 2,000,000 = 6,000.",
      "detailedExplanation": "0.003 * 2,000,000 = 6,000. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-080",
      "type": "numeric-input",
      "question": "Follower lag p99 is 900ms. Freshness SLO is <= 500ms. By what percent is p99 over SLO?",
      "answer": 80,
      "unit": "%",
      "tolerance": 0.5,
      "explanation": "(900-500)/500 = 80% over SLO.",
      "detailedExplanation": "(900-500)/500 = 80% over SLO. Convert targets into concrete counts and time budgets first, then reason about whether incident frequency and recovery time can satisfy them.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-081",
      "type": "numeric-input",
      "question": "A quorum setup uses 5 replicas. Minimum reads+writes quorum sum needed to avoid stale overlap (strict majority condition)?",
      "answer": 6,
      "unit": "quorum-sum",
      "tolerance": 0,
      "explanation": "Need R + W > N, so greater than 5 means minimum sum 6.",
      "detailedExplanation": "Need R + W > N, so greater than 5 means minimum sum 6. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-082",
      "type": "numeric-input",
      "question": "A client performs 1,200 write-then-read flows/min. Read-your-write success is 97.5%. Failures per minute?",
      "answer": 30,
      "unit": "flows",
      "tolerance": 0.02,
      "explanation": "2.5% of 1,200 = 30 failures/min.",
      "detailedExplanation": "2.5% of 1,200 = 30 failures/min. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-083",
      "type": "numeric-input",
      "question": "Monotonic-read violation rate is 0.08% across 4,500,000 reads/day. Violations/day?",
      "answer": 3600,
      "unit": "reads",
      "tolerance": 0.03,
      "explanation": "0.0008 * 4,500,000 = 3,600.",
      "detailedExplanation": "0.0008 * 4,500,000 = 3,600. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-084",
      "type": "numeric-input",
      "question": "A critical path currently does 300ms reads from follower. Leader reads would be 420ms. Percent latency increase?",
      "answer": 40,
      "unit": "%",
      "tolerance": 0.3,
      "explanation": "(420-300)/300 = 40% increase.",
      "detailedExplanation": "(420-300)/300 = 40% increase. Convert targets into concrete counts and time budgets first, then reason about whether incident frequency and recovery time can satisfy them.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-085",
      "type": "numeric-input",
      "question": "An app enforces 2-second bounded staleness. Observed lag is 1.6s. Remaining staleness budget?",
      "answer": 0.4,
      "unit": "seconds",
      "tolerance": 0.05,
      "explanation": "2.0 - 1.6 = 0.4 seconds.",
      "detailedExplanation": "2.0 - 1.6 = 0.4 seconds. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-086",
      "type": "numeric-input",
      "question": "A service has 24 replicas across regions; 3 are unhealthy. What percent of replicas remain healthy?",
      "answer": 87.5,
      "unit": "%",
      "tolerance": 0.3,
      "explanation": "21/24 = 87.5%.",
      "detailedExplanation": "21/24 = 87.5%. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-087",
      "type": "numeric-input",
      "question": "A strict-consistency endpoint handles 9,000 requests/min at $0.0004/request. Cost per hour?",
      "answer": 216,
      "unit": "USD",
      "tolerance": 0.02,
      "explanation": "9,000*60 = 540,000 req/hr; *0.0004 = $216/hr.",
      "detailedExplanation": "9,000*60 = 540,000 req/hr; *0.0004 = $216/hr. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-088",
      "type": "numeric-input",
      "question": "Cross-device profile sync sees 72,000 reads/hour; 1.2% are non-monotonic. Non-monotonic reads/hour?",
      "answer": 864,
      "unit": "reads",
      "tolerance": 0.03,
      "explanation": "0.012 * 72,000 = 864.",
      "detailedExplanation": "0.012 * 72,000 = 864. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-089",
      "type": "numeric-input",
      "question": "A follower catch-up process replays 1,800 ops/sec. Backlog is 540,000 ops. Seconds to catch up (no new writes)?",
      "answer": 300,
      "unit": "seconds",
      "tolerance": 0,
      "explanation": "540,000 / 1,800 = 300 seconds.",
      "detailedExplanation": "540,000 / 1,800 = 300 seconds. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-090",
      "type": "ordering",
      "question": "Order a consistency-design workflow from first to last.",
      "items": [
        "Define entity invariants and user semantics",
        "Map guarantees per endpoint",
        "Implement routing/quorum/session controls",
        "Measure anomaly rates and refine"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Start with semantics, then enforce and measure.",
      "detailedExplanation": "Start with semantics, then enforce and measure. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-091",
      "type": "ordering",
      "question": "Order by increasing consistency strength (typical).",
      "items": [
        "Eventual consistency",
        "Causal consistency",
        "Sequential consistency",
        "Linearizability"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Guarantee strength generally increases along this path.",
      "detailedExplanation": "Guarantee strength generally increases along this path. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-092",
      "type": "ordering",
      "question": "Order by likely latency cost from lowest to highest.",
      "items": [
        "Local eventual follower read",
        "Bounded-staleness read with checks",
        "Leader/quorum read for critical path",
        "Global synchronous path across regions"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Stronger, broader coordination typically costs more latency.",
      "detailedExplanation": "Stronger, broader coordination typically costs more latency. Convert targets into concrete counts and time budgets first, then reason about whether incident frequency and recovery time can satisfy them.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-093",
      "type": "ordering",
      "question": "Order incident triage for stale-read complaints.",
      "items": [
        "Confirm affected endpoints and semantics",
        "Correlate with lag/route/version telemetry",
        "Apply targeted stronger read policy",
        "Backfill tests/alerts for recurrence"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Scope, diagnose, mitigate, then harden.",
      "detailedExplanation": "Scope, diagnose, mitigate, then harden. Convert targets into concrete counts and time budgets first, then reason about whether incident frequency and recovery time can satisfy them.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-094",
      "type": "ordering",
      "question": "Order by strongest to weakest fit for strict financial invariants.",
      "items": [
        "Linearizable critical writes/reads",
        "Quorum path with strong overlap",
        "Causal-only path",
        "Eventually consistent follower reads"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Invariant-critical flows need stronger guarantees.",
      "detailedExplanation": "Invariant-critical flows need stronger guarantees. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-095",
      "type": "ordering",
      "question": "Order user session guarantees by increasing scope.",
      "items": [
        "Read-your-writes",
        "Monotonic reads",
        "Writes-follow-reads",
        "Global serializable behavior"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Session guarantees are client-scoped; global serial behavior is broader.",
      "detailedExplanation": "Session guarantees are client-scoped; global serial behavior is broader. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-096",
      "type": "ordering",
      "question": "Order rollout safety for consistency changes.",
      "items": [
        "Canary affected endpoints",
        "Monitor freshness/anomaly SLOs",
        "Expand traffic gradually",
        "Finalize policy docs and guardrails"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Progressive rollout with telemetry limits blast radius.",
      "detailedExplanation": "Progressive rollout with telemetry limits blast radius. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-097",
      "type": "ordering",
      "question": "Order by increasing stale-read risk (typical).",
      "items": [
        "Leader read after write",
        "Version-checked follower read",
        "Random follower read with moderate lag",
        "Cross-region follower read with no version check"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Risk rises as routing/version constraints weaken.",
      "detailedExplanation": "Risk rises as routing/version constraints weaken. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-098",
      "type": "ordering",
      "question": "Order consistency-contract maturity.",
      "items": [
        "Implicit assumptions only",
        "Informal endpoint comments",
        "Documented per-endpoint guarantees",
        "Documented guarantees with automated conformance tests"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Maturity increases with explicit, testable contracts.",
      "detailedExplanation": "Maturity increases with explicit, testable contracts. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-099",
      "type": "ordering",
      "question": "Order by increasing tolerance to partitions (availability-biased view).",
      "items": [
        "Globally synchronous strict path",
        "Quorum-based strict path",
        "Session-level guarantees with fallbacks",
        "Eventually consistent local-availability path"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Availability under partitions generally increases as strict coordination is reduced.",
      "detailedExplanation": "Availability under partitions generally increases as strict coordination is reduced. Convert targets into concrete counts and time budgets first, then reason about whether incident frequency and recovery time can satisfy them.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-100",
      "type": "ordering",
      "question": "Order mitigation choices from fastest tactical to slowest structural.",
      "items": [
        "Route critical reads to leader temporarily",
        "Enable version-token checks for sessions",
        "Introduce endpoint-specific tunable consistency policy",
        "Re-architect data ownership boundaries"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Immediate routing fixes are fastest; architecture shifts take longest.",
      "detailedExplanation": "Immediate routing fixes are fastest; architecture shifts take longest. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    }
  ]
}
