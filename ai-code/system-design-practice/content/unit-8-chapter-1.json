{
  "unit": 8,
  "unitTitle": "Consistency & Coordination",
  "chapter": 1,
  "chapterTitle": "Consistency Models Fundamentals",
  "chapterDescription": "Core consistency guarantees and trade-offs for read/write behavior, user-visible anomalies, and invariant-critical paths in distributed systems.",
  "problems": [
    {
      "id": "cc-cm-001",
      "type": "multiple-choice",
      "question": "A global profile service is facing read-your-writes expectations. Which consistency-model decision is strongest? Recent user reports mention stale profile values after edits.",
      "options": [
        "Require linearizable reads on critical write-followed-by-read paths and scope them narrowly.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics."
      ],
      "correct": 0,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Treat this as a constraint-filtering problem: find the bottleneck first, then narrow the choices. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-002",
      "type": "multiple-choice",
      "question": "A payment authorization API is facing strict no-stale-read checkout rule. Which consistency-model decision is strongest? This regression appears most during regional failover windows.",
      "options": [
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Use read-your-writes/session consistency for user-facing state while keeping less critical paths eventually consistent."
      ],
      "correct": 3,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Lead with the key assumption, then remove options that break units, scale, or architecture constraints. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-003",
      "type": "multiple-choice",
      "question": "A social feed timeline API is facing cross-device session updates. Which consistency-model decision is strongest? The team must preserve low latency on non-critical reads.",
      "options": [
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Prefer causal consistency where related updates must preserve happens-before relationships.",
        "Standardize all reads as eventually consistent with no exception handling."
      ],
      "correct": 2,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Start by identifying the limiting factor, then rule out options that violate scale or semantics. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-004",
      "type": "multiple-choice",
      "question": "A inventory reservation service is facing multi-region replica lag. Which consistency-model decision is strongest? Critical checkout invariants are now under stricter scrutiny.",
      "options": [
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Pin critical reads to leader/quorum paths when stale data is unacceptable.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency."
      ],
      "correct": 1,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Solve this by pinning the governing ratio first and using it to discard impossible answers. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-005",
      "type": "multiple-choice",
      "question": "A messaging inbox API is facing partition tolerance during failover. Which consistency-model decision is strongest? Multi-device sessions amplify inconsistency visibility.",
      "options": [
        "Adopt tunable consistency with stronger writes for invariant-critical entities.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics."
      ],
      "correct": 0,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Frame the problem around the main tradeoff first, then test each option for consistency. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ]
    },
    {
      "id": "cc-cm-006",
      "type": "multiple-choice",
      "question": "A feature-flag delivery API is facing high write burst with follower reads. Which consistency-model decision is strongest? Replica lag spikes during write bursts expose weak guarantees.",
      "options": [
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Separate strict correctness endpoints from low-latency eventually consistent read endpoints."
      ],
      "correct": 3,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "The fastest path is to anchor on the core constraint and eliminate implausible options early. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-007",
      "type": "multiple-choice",
      "question": "A ride dispatch state service is facing causal update chains between services. Which consistency-model decision is strongest? Support tickets describe data “time travel” behavior.",
      "options": [
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Use monotonic-read guarantees to prevent time-travel user experiences across devices.",
        "Standardize all reads as eventually consistent with no exception handling."
      ],
      "correct": 2,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "A reliable method is to name the primary boundary condition, then evaluate options against it. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-008",
      "type": "multiple-choice",
      "question": "A support ticket backend is facing client retry/reorder behavior. Which consistency-model decision is strongest? Incident review requires explicit endpoint-level contracts.",
      "options": [
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Apply bounded-staleness policy with explicit freshness budgets and fallback behavior.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency."
      ],
      "correct": 1,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "A practical approach here is to lock down the dominant constraint before comparing answer choices. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        }
      ]
    },
    {
      "id": "cc-cm-009",
      "type": "multiple-choice",
      "question": "A ad campaign manager is facing low-latency read requirement. Which consistency-model decision is strongest? The fix should avoid over-strengthening every endpoint.",
      "options": [
        "Use session stickiness plus tokenized version checks to enforce user-visible consistency guarantees.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics."
      ],
      "correct": 0,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Treat this as a constraint-filtering problem: find the bottleneck first, then narrow the choices. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-010",
      "type": "multiple-choice",
      "question": "A analytics query endpoint is facing audit correctness requirement. Which consistency-model decision is strongest? Audit stakeholders require deterministic critical-path behavior.",
      "options": [
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Design explicit degradation mode that trades freshness for availability on non-critical reads."
      ],
      "correct": 3,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "A reliable method is to name the primary boundary condition, then evaluate options against it. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-011",
      "type": "multiple-choice",
      "question": "A document collaboration API is facing read-your-writes expectations. Which consistency-model decision is strongest? Recent traffic growth increased follower-read usage.",
      "options": [
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Require linearizable reads on critical write-followed-by-read paths and scope them narrowly.",
        "Standardize all reads as eventually consistent with no exception handling."
      ],
      "correct": 2,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "The fastest path is to anchor on the core constraint and eliminate implausible options early. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-012",
      "type": "multiple-choice",
      "question": "A bank transfer ledger API is facing strict no-stale-read checkout rule. Which consistency-model decision is strongest? The service mixes critical and non-critical entities.",
      "options": [
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Use read-your-writes/session consistency for user-facing state while keeping less critical paths eventually consistent.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency."
      ],
      "correct": 1,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Frame the problem around the main tradeoff first, then test each option for consistency. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-013",
      "type": "multiple-choice",
      "question": "A shopping cart service is facing cross-device session updates. Which consistency-model decision is strongest? Client retries increase reordering risk across regions.",
      "options": [
        "Prefer causal consistency where related updates must preserve happens-before relationships.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics."
      ],
      "correct": 0,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Solve this by pinning the governing ratio first and using it to discard impossible answers. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-014",
      "type": "multiple-choice",
      "question": "A notification preference API is facing multi-region replica lag. Which consistency-model decision is strongest? On-call reports stale reads concentrated in one path.",
      "options": [
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Pin critical reads to leader/quorum paths when stale data is unacceptable."
      ],
      "correct": 3,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Start by identifying the limiting factor, then rule out options that violate scale or semantics. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-015",
      "type": "multiple-choice",
      "question": "A fraud decision API is facing partition tolerance during failover. Which consistency-model decision is strongest? A quick mitigation is needed before full architecture changes.",
      "options": [
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Adopt tunable consistency with stronger writes for invariant-critical entities.",
        "Standardize all reads as eventually consistent with no exception handling."
      ],
      "correct": 2,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Lead with the key assumption, then remove options that break units, scale, or architecture constraints. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ]
    },
    {
      "id": "cc-cm-016",
      "type": "multiple-choice",
      "question": "A game session coordinator is facing high write burst with follower reads. Which consistency-model decision is strongest? The current API docs do not define freshness semantics clearly.",
      "options": [
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Separate strict correctness endpoints from low-latency eventually consistent read endpoints.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency."
      ],
      "correct": 1,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Treat this as a constraint-filtering problem: find the bottleneck first, then narrow the choices. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-017",
      "type": "multiple-choice",
      "question": "A identity profile API is facing causal update chains between services. Which consistency-model decision is strongest? Cost constraints rule out global strictness everywhere.",
      "options": [
        "Use monotonic-read guarantees to prevent time-travel user experiences across devices.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics."
      ],
      "correct": 0,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "A practical approach here is to lock down the dominant constraint before comparing answer choices. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-018",
      "type": "multiple-choice",
      "question": "A catalog availability API is facing client retry/reorder behavior. Which consistency-model decision is strongest? The UI requires clear behavior when freshness is uncertain.",
      "options": [
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Apply bounded-staleness policy with explicit freshness budgets and fallback behavior."
      ],
      "correct": 3,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "A reliable method is to name the primary boundary condition, then evaluate options against it. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        }
      ]
    },
    {
      "id": "cc-cm-019",
      "type": "multiple-choice",
      "question": "A order tracking service is facing low-latency read requirement. Which consistency-model decision is strongest? SLOs now track monotonic-read violations explicitly.",
      "options": [
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Use session stickiness plus tokenized version checks to enforce user-visible consistency guarantees.",
        "Standardize all reads as eventually consistent with no exception handling."
      ],
      "correct": 2,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "The fastest path is to anchor on the core constraint and eliminate implausible options early. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-020",
      "type": "multiple-choice",
      "question": "A customer settings API is facing audit correctness requirement. Which consistency-model decision is strongest? Teams disagree on whether session guarantees are required.",
      "options": [
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Design explicit degradation mode that trades freshness for availability on non-critical reads.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency."
      ],
      "correct": 1,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "The fastest path is to anchor on the core constraint and eliminate implausible options early. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-021",
      "type": "multiple-choice",
      "question": "A global profile service is facing read-your-writes expectations. Which consistency-model decision is strongest? Cross-service update chains are creating causal confusion.",
      "options": [
        "Require linearizable reads on critical write-followed-by-read paths and scope them narrowly.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics."
      ],
      "correct": 0,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "A reliable method is to name the primary boundary condition, then evaluate options against it. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-022",
      "type": "multiple-choice",
      "question": "A payment authorization API is facing strict no-stale-read checkout rule. Which consistency-model decision is strongest? The platform can enforce version-token routing decisions.",
      "options": [
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Use read-your-writes/session consistency for user-facing state while keeping less critical paths eventually consistent."
      ],
      "correct": 3,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Solve this by pinning the governing ratio first and using it to discard impossible answers. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-023",
      "type": "multiple-choice",
      "question": "A social feed timeline API is facing cross-device session updates. Which consistency-model decision is strongest? Business impact is tied to incorrect post-write reads.",
      "options": [
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Prefer causal consistency where related updates must preserve happens-before relationships.",
        "Standardize all reads as eventually consistent with no exception handling."
      ],
      "correct": 2,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Frame the problem around the main tradeoff first, then test each option for consistency. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-024",
      "type": "multiple-choice",
      "question": "A inventory reservation service is facing multi-region replica lag. Which consistency-model decision is strongest? Some endpoints can tolerate bounded staleness if explicit.",
      "options": [
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Pin critical reads to leader/quorum paths when stale data is unacceptable.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency."
      ],
      "correct": 1,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Lead with the key assumption, then remove options that break units, scale, or architecture constraints. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-025",
      "type": "multiple-choice",
      "question": "A messaging inbox API is facing partition tolerance during failover. Which consistency-model decision is strongest? The incident occurs mainly on follower-heavy traffic.",
      "options": [
        "Adopt tunable consistency with stronger writes for invariant-critical entities.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics."
      ],
      "correct": 0,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Start by identifying the limiting factor, then rule out options that violate scale or semantics. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        }
      ]
    },
    {
      "id": "cc-cm-026",
      "type": "multiple-choice",
      "question": "A feature-flag delivery API is facing high write burst with follower reads. Which consistency-model decision is strongest? Failback events temporarily widen staleness windows.",
      "options": [
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Separate strict correctness endpoints from low-latency eventually consistent read endpoints."
      ],
      "correct": 3,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "A practical approach here is to lock down the dominant constraint before comparing answer choices. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-027",
      "type": "multiple-choice",
      "question": "A ride dispatch state service is facing causal update chains between services. Which consistency-model decision is strongest? Critical endpoints are a minority of total traffic.",
      "options": [
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Use monotonic-read guarantees to prevent time-travel user experiences across devices.",
        "Standardize all reads as eventually consistent with no exception handling."
      ],
      "correct": 2,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Treat this as a constraint-filtering problem: find the bottleneck first, then narrow the choices. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-028",
      "type": "multiple-choice",
      "question": "A support ticket backend is facing client retry/reorder behavior. Which consistency-model decision is strongest? Engineering leadership requested measurable consistency SLOs.",
      "options": [
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Apply bounded-staleness policy with explicit freshness budgets and fallback behavior.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency."
      ],
      "correct": 1,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "The fastest path is to anchor on the core constraint and eliminate implausible options early. Message design should specify delivery guarantees, ordering scope, and backpressure behavior under failure, not just happy-path throughput.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Retry pattern",
          "url": "https://learn.microsoft.com/en-us/azure/architecture/patterns/retry"
        }
      ]
    },
    {
      "id": "cc-cm-029",
      "type": "multiple-choice",
      "question": "A ad campaign manager is facing low-latency read requirement. Which consistency-model decision is strongest? The solution must preserve availability under partial failure.",
      "options": [
        "Use session stickiness plus tokenized version checks to enforce user-visible consistency guarantees.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics."
      ],
      "correct": 0,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "A reliable method is to name the primary boundary condition, then evaluate options against it. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-030",
      "type": "multiple-choice",
      "question": "A analytics query endpoint is facing audit correctness requirement. Which consistency-model decision is strongest? Convergence eventually happens but user trust is degraded.",
      "options": [
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Design explicit degradation mode that trades freshness for availability on non-critical reads."
      ],
      "correct": 3,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Frame the problem around the main tradeoff first, then test each option for consistency. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-031",
      "type": "multiple-choice",
      "question": "A document collaboration API is facing read-your-writes expectations. Which consistency-model decision is strongest? Current behavior differs by region for the same user action.",
      "options": [
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Require linearizable reads on critical write-followed-by-read paths and scope them narrowly.",
        "Standardize all reads as eventually consistent with no exception handling."
      ],
      "correct": 2,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Solve this by pinning the governing ratio first and using it to discard impossible answers. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-032",
      "type": "multiple-choice",
      "question": "A bank transfer ledger API is facing strict no-stale-read checkout rule. Which consistency-model decision is strongest? Mitigation should be canary-safe and reversible.",
      "options": [
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Use read-your-writes/session consistency for user-facing state while keeping less critical paths eventually consistent.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency."
      ],
      "correct": 1,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "A reliable method is to name the primary boundary condition, then evaluate options against it. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-033",
      "type": "multiple-choice",
      "question": "A shopping cart service is facing cross-device session updates. Which consistency-model decision is strongest? Error semantics for stale vs unavailable need to be explicit.",
      "options": [
        "Prefer causal consistency where related updates must preserve happens-before relationships.",
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics."
      ],
      "correct": 0,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "The fastest path is to anchor on the core constraint and eliminate implausible options early. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-034",
      "type": "multiple-choice",
      "question": "A notification preference API is facing multi-region replica lag. Which consistency-model decision is strongest? The team wants a principled consistency rubric, not ad hoc fixes.",
      "options": [
        "Standardize all reads as eventually consistent with no exception handling.",
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Pin critical reads to leader/quorum paths when stale data is unacceptable."
      ],
      "correct": 3,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "Treat this as a constraint-filtering problem: find the bottleneck first, then narrow the choices. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-035",
      "type": "multiple-choice",
      "question": "A fraud decision API is facing partition tolerance during failover. Which consistency-model decision is strongest? Post-incident prevention is required in the first rollout.",
      "options": [
        "Always force globally synchronous writes for every endpoint regardless latency.",
        "Ignore client-visible anomalies and rely only on average latency metrics.",
        "Adopt tunable consistency with stronger writes for invariant-critical entities.",
        "Standardize all reads as eventually consistent with no exception handling."
      ],
      "correct": 2,
      "explanation": "Consistency choice should match invariant criticality and user-visible semantics, not apply one guarantee everywhere.",
      "detailedExplanation": "A practical approach here is to lock down the dominant constraint before comparing answer choices. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        }
      ]
    },
    {
      "id": "cc-cm-036",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: inventory reservation service is seeing issues around partition tolerance during failover. What is the most likely diagnosis?",
          "options": [
            "The current model for inventory reservation service does not match partition tolerance during failover, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees."
          ],
          "correct": 0,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "Carry the prior stage assumptions forward and revalidate units before making the next decision. Message design should specify delivery guarantees, ordering scope, and backpressure behavior under failure, not just happy-path throughput."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest while keeping p99 under target?",
          "options": [
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Prefer causal consistency where related updates must preserve happens-before relationships."
          ],
          "correct": 3,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Translate the prior stage outcome into an operational check before selecting the next move. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them."
        }
      ],
      "detailedExplanation": "Follow the canonical calculation path and check both units and magnitude before finalizing. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-037",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: messaging inbox API is seeing issues around high write burst with follower reads. What is the most likely diagnosis?",
          "options": [
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for messaging inbox API does not match high write burst with follower reads, causing user-visible anomalies."
          ],
          "correct": 3,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "This stage is best solved by propagating the earlier result and validating edge conditions. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest without violating checkout correctness?",
          "options": [
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Pin critical reads to leader/quorum paths when stale data is unacceptable.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI."
          ],
          "correct": 2,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Keep the previous conclusion fixed, then test this stage for consistency and scale. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Anchor on the base formula, preserve unit integrity, and then run a reasonableness check. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-038",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: feature-flag delivery API is seeing issues around causal update chains between services. What is the most likely diagnosis?",
          "options": [
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for feature-flag delivery API does not match causal update chains between services, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good."
          ],
          "correct": 2,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "Use the earlier stage as the boundary condition and solve this step under that constraint. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest under replica lag spikes?",
          "options": [
            "Do nothing and rely on passive replica convergence only.",
            "Adopt tunable consistency with stronger writes for invariant-critical entities.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement."
          ],
          "correct": 1,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Use the result from the previous step as a hard constraint, then evaluate this stage against it. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Compute from the primary formula first, then sanity-check the scale of the result. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-039",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: ride dispatch state service is seeing issues around client retry/reorder behavior. What is the most likely diagnosis?",
          "options": [
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for ride dispatch state service does not match client retry/reorder behavior, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches."
          ],
          "correct": 1,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "Use the result from the previous step as a hard constraint, then evaluate this stage against it. Message design should specify delivery guarantees, ordering scope, and backpressure behavior under failure, not just happy-path throughput."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest during regional failover?",
          "options": [
            "Separate strict correctness endpoints from low-latency eventually consistent read endpoints.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only."
          ],
          "correct": 0,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Use the earlier stage as the boundary condition and solve this step under that constraint. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Use a formula-first approach with explicit units to avoid hidden conversion mistakes. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-040",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: support ticket backend is seeing issues around low-latency read requirement. What is the most likely diagnosis?",
          "options": [
            "The current model for support ticket backend does not match low-latency read requirement, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees."
          ],
          "correct": 0,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "Use the result from the previous step as a hard constraint, then evaluate this stage against it. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest with mobile multi-device clients?",
          "options": [
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Use monotonic-read guarantees to prevent time-travel user experiences across devices."
          ],
          "correct": 3,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Use the earlier stage as the boundary condition and solve this step under that constraint. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Use a formula-first approach with explicit units to avoid hidden conversion mistakes. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-041",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: ad campaign manager is seeing issues around audit correctness requirement. What is the most likely diagnosis?",
          "options": [
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for ad campaign manager does not match audit correctness requirement, causing user-visible anomalies."
          ],
          "correct": 3,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "Use the earlier stage as the boundary condition and solve this step under that constraint. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest while limiting quorum read cost?",
          "options": [
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Apply bounded-staleness policy with explicit freshness budgets and fallback behavior.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI."
          ],
          "correct": 2,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Use the result from the previous step as a hard constraint, then evaluate this stage against it. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Compute from the primary formula first, then sanity-check the scale of the result. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-042",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: analytics query endpoint is seeing issues around read-your-writes expectations. What is the most likely diagnosis?",
          "options": [
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for analytics query endpoint does not match read-your-writes expectations, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good."
          ],
          "correct": 2,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "Translate the prior stage outcome into an operational check before selecting the next move. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest under intermittent partitions?",
          "options": [
            "Do nothing and rely on passive replica convergence only.",
            "Use session stickiness plus tokenized version checks to enforce user-visible consistency guarantees.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement."
          ],
          "correct": 1,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Carry the prior stage assumptions forward and revalidate units before making the next decision. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Apply the main relationship stepwise and verify unit consistency at each step. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-043",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: document collaboration API is seeing issues around strict no-stale-read checkout rule. What is the most likely diagnosis?",
          "options": [
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for document collaboration API does not match strict no-stale-read checkout rule, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches."
          ],
          "correct": 1,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "Keep the previous conclusion fixed, then test this stage for consistency and scale. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest without forcing global sync everywhere?",
          "options": [
            "Design explicit degradation mode that trades freshness for availability on non-critical reads.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only."
          ],
          "correct": 0,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "This stage is best solved by propagating the earlier result and validating edge conditions. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Start from the governing formula, keep units visible, and validate the final magnitude. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-044",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: bank transfer ledger API is seeing issues around cross-device session updates. What is the most likely diagnosis?",
          "options": [
            "The current model for bank transfer ledger API does not match cross-device session updates, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees."
          ],
          "correct": 0,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "Advance from the first-stage output, then verify that this decision still respects the same limits. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest during burst traffic windows?",
          "options": [
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Require linearizable reads on critical write-followed-by-read paths and scope them narrowly."
          ],
          "correct": 3,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Treat this as a continuation step: preserve earlier constraints and recheck feasibility. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Use the core equation with explicit unit tracking before committing to an answer. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-045",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: shopping cart service is seeing issues around multi-region replica lag. What is the most likely diagnosis?",
          "options": [
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for shopping cart service does not match multi-region replica lag, causing user-visible anomalies."
          ],
          "correct": 3,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "Treat this as a continuation step: preserve earlier constraints and recheck feasibility. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest with strict audit surfaces?",
          "options": [
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Use read-your-writes/session consistency for user-facing state while keeping less critical paths eventually consistent.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI."
          ],
          "correct": 2,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Advance from the first-stage output, then verify that this decision still respects the same limits. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Work through the core math with unit labels attached, then verify scale plausibility. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-046",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: notification preference API is seeing issues around partition tolerance during failover. What is the most likely diagnosis?",
          "options": [
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for notification preference API does not match partition tolerance during failover, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good."
          ],
          "correct": 2,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "This stage is best solved by propagating the earlier result and validating edge conditions. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest while preserving availability goals?",
          "options": [
            "Do nothing and rely on passive replica convergence only.",
            "Prefer causal consistency where related updates must preserve happens-before relationships.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement."
          ],
          "correct": 1,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Keep the previous conclusion fixed, then test this stage for consistency and scale. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them."
        }
      ],
      "detailedExplanation": "Anchor on the base formula, preserve unit integrity, and then run a reasonableness check. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-047",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: fraud decision API is seeing issues around high write burst with follower reads. What is the most likely diagnosis?",
          "options": [
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for fraud decision API does not match high write burst with follower reads, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches."
          ],
          "correct": 1,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "Carry the prior stage assumptions forward and revalidate units before making the next decision. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest under edge-cache refresh delays?",
          "options": [
            "Pin critical reads to leader/quorum paths when stale data is unacceptable.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only."
          ],
          "correct": 0,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Translate the prior stage outcome into an operational check before selecting the next move. Caching answers should define invalidation behavior and staleness boundaries; hit rate alone is not a correctness guarantee."
        }
      ],
      "detailedExplanation": "Follow the canonical calculation path and check both units and magnitude before finalizing. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-048",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: game session coordinator is seeing issues around causal update chains between services. What is the most likely diagnosis?",
          "options": [
            "The current model for game session coordinator does not match causal update chains between services, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees."
          ],
          "correct": 0,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "Use the result from the previous step as a hard constraint, then evaluate this stage against it. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest with mixed critical/non-critical entities?",
          "options": [
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Adopt tunable consistency with stronger writes for invariant-critical entities."
          ],
          "correct": 3,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Use the earlier stage as the boundary condition and solve this step under that constraint. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Use a formula-first approach with explicit units to avoid hidden conversion mistakes. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-049",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: identity profile API is seeing issues around client retry/reorder behavior. What is the most likely diagnosis?",
          "options": [
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for identity profile API does not match client retry/reorder behavior, causing user-visible anomalies."
          ],
          "correct": 3,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "Use the earlier stage as the boundary condition and solve this step under that constraint. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest without causing user time-travel reads?",
          "options": [
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Separate strict correctness endpoints from low-latency eventually consistent read endpoints.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI."
          ],
          "correct": 2,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Use the result from the previous step as a hard constraint, then evaluate this stage against it. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Compute from the primary formula first, then sanity-check the scale of the result. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-050",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: catalog availability API is seeing issues around low-latency read requirement. What is the most likely diagnosis?",
          "options": [
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for catalog availability API does not match low-latency read requirement, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good."
          ],
          "correct": 2,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "Carry the prior stage assumptions forward and revalidate units before making the next decision. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest under retry reordering behavior?",
          "options": [
            "Do nothing and rely on passive replica convergence only.",
            "Use monotonic-read guarantees to prevent time-travel user experiences across devices.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement."
          ],
          "correct": 1,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Translate the prior stage outcome into an operational check before selecting the next move. Message design should specify delivery guarantees, ordering scope, and backpressure behavior under failure, not just happy-path throughput."
        }
      ],
      "detailedExplanation": "Follow the canonical calculation path and check both units and magnitude before finalizing. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-051",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: order tracking service is seeing issues around audit correctness requirement. What is the most likely diagnosis?",
          "options": [
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for order tracking service does not match audit correctness requirement, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches."
          ],
          "correct": 1,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "This stage is best solved by propagating the earlier result and validating edge conditions. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest with constrained backend capacity?",
          "options": [
            "Apply bounded-staleness policy with explicit freshness budgets and fallback behavior.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only."
          ],
          "correct": 0,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Keep the previous conclusion fixed, then test this stage for consistency and scale. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Anchor on the base formula, preserve unit integrity, and then run a reasonableness check. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-052",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: customer settings API is seeing issues around read-your-writes expectations. What is the most likely diagnosis?",
          "options": [
            "The current model for customer settings API does not match read-your-writes expectations, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees."
          ],
          "correct": 0,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "Treat this as a continuation step: preserve earlier constraints and recheck feasibility. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest while controlling stale-read risk?",
          "options": [
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Use session stickiness plus tokenized version checks to enforce user-visible consistency guarantees."
          ],
          "correct": 3,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Advance from the first-stage output, then verify that this decision still respects the same limits. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Work through the core math with unit labels attached, then verify scale plausibility. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-053",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: global profile service is seeing issues around strict no-stale-read checkout rule. What is the most likely diagnosis?",
          "options": [
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for global profile service does not match strict no-stale-read checkout rule, causing user-visible anomalies."
          ],
          "correct": 3,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "Advance from the first-stage output, then verify that this decision still respects the same limits. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest during dependency brownouts?",
          "options": [
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Design explicit degradation mode that trades freshness for availability on non-critical reads.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI."
          ],
          "correct": 2,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Treat this as a continuation step: preserve earlier constraints and recheck feasibility. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Use the core equation with explicit unit tracking before committing to an answer. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-054",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: payment authorization API is seeing issues around cross-device session updates. What is the most likely diagnosis?",
          "options": [
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for payment authorization API does not match cross-device session updates, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good."
          ],
          "correct": 2,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "Keep the previous conclusion fixed, then test this stage for consistency and scale. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest with tenant-isolation constraints?",
          "options": [
            "Do nothing and rely on passive replica convergence only.",
            "Require linearizable reads on critical write-followed-by-read paths and scope them narrowly.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement."
          ],
          "correct": 1,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "This stage is best solved by propagating the earlier result and validating edge conditions. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Start from the governing formula, keep units visible, and validate the final magnitude. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-055",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: social feed timeline API is seeing issues around multi-region replica lag. What is the most likely diagnosis?",
          "options": [
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for social feed timeline API does not match multi-region replica lag, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches."
          ],
          "correct": 1,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "Translate the prior stage outcome into an operational check before selecting the next move. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest before wider rollout?",
          "options": [
            "Use read-your-writes/session consistency for user-facing state while keeping less critical paths eventually consistent.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only."
          ],
          "correct": 0,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Carry the prior stage assumptions forward and revalidate units before making the next decision. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Apply the main relationship stepwise and verify unit consistency at each step. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-056",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: inventory reservation service is seeing issues around partition tolerance during failover. What is the most likely diagnosis?",
          "options": [
            "The current model for inventory reservation service does not match partition tolerance during failover, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees."
          ],
          "correct": 0,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "Use the earlier stage as the boundary condition and solve this step under that constraint. Message design should specify delivery guarantees, ordering scope, and backpressure behavior under failure, not just happy-path throughput."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest with clear error semantics?",
          "options": [
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Prefer causal consistency where related updates must preserve happens-before relationships."
          ],
          "correct": 3,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Use the result from the previous step as a hard constraint, then evaluate this stage against it. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Compute from the primary formula first, then sanity-check the scale of the result. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-057",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: messaging inbox API is seeing issues around high write burst with follower reads. What is the most likely diagnosis?",
          "options": [
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for messaging inbox API does not match high write burst with follower reads, causing user-visible anomalies."
          ],
          "correct": 3,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "Use the result from the previous step as a hard constraint, then evaluate this stage against it. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest under backlog recovery pressure?",
          "options": [
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Pin critical reads to leader/quorum paths when stale data is unacceptable.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI."
          ],
          "correct": 2,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Use the earlier stage as the boundary condition and solve this step under that constraint. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Use a formula-first approach with explicit units to avoid hidden conversion mistakes. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-058",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: feature-flag delivery API is seeing issues around causal update chains between services. What is the most likely diagnosis?",
          "options": [
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for feature-flag delivery API does not match causal update chains between services, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good."
          ],
          "correct": 2,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "Carry the prior stage assumptions forward and revalidate units before making the next decision. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest while preserving write throughput?",
          "options": [
            "Do nothing and rely on passive replica convergence only.",
            "Adopt tunable consistency with stronger writes for invariant-critical entities.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement."
          ],
          "correct": 1,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Translate the prior stage outcome into an operational check before selecting the next move. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Follow the canonical calculation path and check both units and magnitude before finalizing. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-059",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: ride dispatch state service is seeing issues around client retry/reorder behavior. What is the most likely diagnosis?",
          "options": [
            "Session behavior has no relationship to consistency guarantees.",
            "The current model for ride dispatch state service does not match client retry/reorder behavior, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches."
          ],
          "correct": 1,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "This stage is best solved by propagating the earlier result and validating edge conditions. Message design should specify delivery guarantees, ordering scope, and backpressure behavior under failure, not just happy-path throughput."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest during incident containment?",
          "options": [
            "Separate strict correctness endpoints from low-latency eventually consistent read endpoints.",
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only."
          ],
          "correct": 0,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Keep the previous conclusion fixed, then test this stage for consistency and scale. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them."
        }
      ],
      "detailedExplanation": "Anchor on the base formula, preserve unit integrity, and then run a reasonableness check. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-060",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: support ticket backend is seeing issues around low-latency read requirement. What is the most likely diagnosis?",
          "options": [
            "The current model for support ticket backend does not match low-latency read requirement, causing user-visible anomalies.",
            "Consistency anomalies are impossible if average latency looks good.",
            "Only network bandwidth explains read/write mismatches.",
            "Session behavior has no relationship to consistency guarantees."
          ],
          "correct": 0,
          "explanation": "This pattern indicates mismatch between required user/invariant semantics and selected consistency level.",
          "detailedExplanation": "This stage is best solved by propagating the earlier result and validating edge conditions. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them."
        },
        {
          "question": "After confirming diagnosis, which next change is strongest with explicit freshness SLOs?",
          "options": [
            "Switch every endpoint to weakest consistency and hide anomalies in UI.",
            "Mandate strongest global consistency for all entities without measurement.",
            "Do nothing and rely on passive replica convergence only.",
            "Use monotonic-read guarantees to prevent time-travel user experiences across devices."
          ],
          "correct": 3,
          "explanation": "Apply the narrowest stronger guarantee where needed, preserving performance elsewhere.",
          "detailedExplanation": "Keep the previous conclusion fixed, then test this stage for consistency and scale. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Anchor on the base formula, preserve unit integrity, and then run a reasonableness check. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-061",
      "type": "multi-select",
      "question": "Which are common user-facing anomalies under weak consistency? (Select all that apply)",
      "options": [
        "Read-your-write missing immediately after update",
        "Non-monotonic reads across requests",
        "Guaranteed strict serial order for all operations",
        "Conflicting views across devices"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Weak consistency can produce stale, non-monotonic, or divergent views.",
      "detailedExplanation": "Use independent validation per option to prevent partial truths from slipping into the final set. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-062",
      "type": "multi-select",
      "question": "When is linearizability typically justified? (Select all that apply)",
      "options": [
        "Financial invariants and double-spend prevention",
        "Inventory oversell prevention at checkout",
        "All analytics dashboard reads",
        "Critical leader-election state"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Use strongest guarantees where correctness failures are high cost.",
      "detailedExplanation": "Evaluate each option independently against the constraint instead of looking for a pattern across choices. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-063",
      "type": "multi-select",
      "question": "Session guarantees include which? (Select all that apply)",
      "options": [
        "Read-your-writes",
        "Monotonic reads",
        "Global serializability by default",
        "Writes-follow-reads"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Session guarantees are client-scoped and weaker than global serializability.",
      "detailedExplanation": "Check every option on its own merits and reject statements that are only true under hidden assumptions. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-064",
      "type": "multi-select",
      "question": "Which are valid trade-offs of quorum reads/writes? (Select all that apply)",
      "options": [
        "Lower stale-read risk with stronger quorums",
        "Higher latency on critical paths",
        "No impact on availability under failures",
        "Can tune by endpoint criticality"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Quorums trade latency/availability for freshness and correctness.",
      "detailedExplanation": "Treat each candidate as a separate true/false check against the same governing requirement. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-065",
      "type": "multi-select",
      "question": "Causal consistency is most helpful when which conditions apply? (Select all that apply)",
      "options": [
        "Operations have happens-before dependencies",
        "Users expect reply-after-post ordering",
        "Independent analytics counters only",
        "Cross-service workflow order matters"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Causality preserves dependent update order without full linearizability.",
      "detailedExplanation": "Score each option independently and keep only those that remain valid under the stated constraints. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-066",
      "type": "multi-select",
      "question": "Which strategies reduce stale-read impact without global strictness? (Select all that apply)",
      "options": [
        "Bounded staleness + freshness metadata",
        "Leader reads for critical endpoints",
        "Disable replication entirely",
        "Read repair and anti-entropy"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Targeted controls reduce stale anomalies while retaining scale benefits.",
      "detailedExplanation": "Avoid grouped guessing: test every option directly against the system boundary condition. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-067",
      "type": "multi-select",
      "question": "Signs that consistency requirements are underspecified include which? (Select all that apply)",
      "options": [
        "Frequent product bug reports about “data reverted”",
        "No documented endpoint freshness policy",
        "Clear entity-level invariants and SLAs",
        "Conflicting assumptions between teams"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Underspecification leads to inconsistent implementations and user confusion.",
      "detailedExplanation": "Run a one-by-one validity check and discard options that depend on unstated conditions. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-068",
      "type": "multi-select",
      "question": "Which are good practices for mixing consistency models by endpoint? (Select all that apply)",
      "options": [
        "Document guarantees per endpoint",
        "Use stronger guarantees only where invariants demand",
        "Hide all consistency errors from clients",
        "Expose freshness semantics in API contracts"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Explicit contracts and selective strictness keep systems understandable and efficient.",
      "detailedExplanation": "Assess each option separately and keep answers that hold across the full problem context. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-069",
      "type": "multi-select",
      "question": "What can increase non-monotonic read risk? (Select all that apply)",
      "options": [
        "Load balancing reads across lagging replicas",
        "No session stickiness or version tracking",
        "Always reading from leader",
        "Replica lag spikes during failover"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Replica lag and unconstrained replica selection cause time-travel read experiences.",
      "detailedExplanation": "Use independent validation per option to prevent partial truths from slipping into the final set. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-070",
      "type": "multi-select",
      "question": "Which controls help preserve read-your-writes in replicated systems? (Select all that apply)",
      "options": [
        "Session token with last-seen write version",
        "Leader read on immediate follow-up requests",
        "Random follower read with no version check",
        "Sticky session within freshness window"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Version tracking or routing constraints protect immediate post-write reads.",
      "detailedExplanation": "Check every option on its own merits and reject statements that are only true under hidden assumptions. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-071",
      "type": "multi-select",
      "question": "Eventual consistency can still be acceptable when which are true? (Select all that apply)",
      "options": [
        "Data is non-critical or tolerant to delay",
        "UI communicates pending convergence state",
        "Hard invariants require instant global agreement",
        "Compensating logic handles temporary divergence"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Eventual consistency is viable when delays are tolerable and explicitly managed.",
      "detailedExplanation": "Evaluate each option independently against the constraint instead of looking for a pattern across choices. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-072",
      "type": "multi-select",
      "question": "Which are realistic costs of strongest consistency on all paths? (Select all that apply)",
      "options": [
        "Higher latency",
        "Reduced availability during partitions",
        "Guaranteed lower cloud cost",
        "Throughput constraints on write-heavy workloads"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Strong consistency everywhere often overpays in latency and availability.",
      "detailedExplanation": "Use independent validation per option to prevent partial truths from slipping into the final set. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-073",
      "type": "multi-select",
      "question": "Which practices improve consistency incident triage? (Select all that apply)",
      "options": [
        "Tag reads with replica/version metadata",
        "Track stale-read rate and monotonic-read violations",
        "Only monitor CPU utilization",
        "Correlate anomalies with replication lag"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Version and lag telemetry enables concrete consistency diagnosis.",
      "detailedExplanation": "Assess each option separately and keep answers that hold across the full problem context. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        }
      ]
    },
    {
      "id": "cc-cm-074",
      "type": "multi-select",
      "question": "For user profile edits across devices, which patterns help UX consistency? (Select all that apply)",
      "options": [
        "Read-your-writes session guarantee",
        "Monotonic reads across sessions",
        "Blind cache refresh without versioning",
        "Conflict-visible merge semantics when needed"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Session guarantees and explicit merge semantics reduce surprising regressions.",
      "detailedExplanation": "Run a one-by-one validity check and discard options that depend on unstated conditions. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-075",
      "type": "multi-select",
      "question": "Which are valid consistency SLO dimensions? (Select all that apply)",
      "options": [
        "Freshness bound (max staleness)",
        "Monotonic-read violation rate",
        "Color palette consistency score",
        "Read-your-write success rate"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Consistency SLOs should be measurable by freshness and anomaly rates.",
      "detailedExplanation": "Avoid grouped guessing: test every option directly against the system boundary condition. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-076",
      "type": "multi-select",
      "question": "During failover, which choices reduce correctness risk? (Select all that apply)",
      "options": [
        "Temporary stronger read path for critical entities",
        "Explicit degraded mode for non-critical reads",
        "Disable all write validation checks",
        "Clear client semantics for stale/unavailable states"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Failover policies should protect invariants and make degraded semantics explicit.",
      "detailedExplanation": "Score each option independently and keep only those that remain valid under the stated constraints. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-077",
      "type": "multi-select",
      "question": "Which anti-patterns often cause consistency bugs at scale? (Select all that apply)",
      "options": [
        "Assuming replica lag is always negligible",
        "Mixing write/read paths without guarantee mapping",
        "Per-endpoint guarantee documentation",
        "Using one global default without domain review"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Implicit assumptions and undocumented guarantees create latent consistency failures.",
      "detailedExplanation": "Treat each candidate as a separate true/false check against the same governing requirement. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-078",
      "type": "numeric-input",
      "question": "Write rate is 6,000 writes/sec and replica lag is 2.5 seconds. Approximate unreplicated writes in lag window?",
      "answer": 15000,
      "unit": "writes",
      "tolerance": 0.02,
      "explanation": "6,000 * 2.5 = 15,000 writes.",
      "detailedExplanation": "Use base-unit arithmetic plus a magnitude check to keep the estimate robust under time pressure. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-079",
      "type": "numeric-input",
      "question": "An endpoint sees 2,000,000 reads/day. Measured stale-read rate is 0.3%. How many stale reads/day?",
      "answer": 6000,
      "unit": "reads",
      "tolerance": 0.02,
      "explanation": "0.003 * 2,000,000 = 6,000.",
      "detailedExplanation": "Do the conversion step first and maintain unit labels to prevent silent math errors. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-080",
      "type": "numeric-input",
      "question": "Follower lag p99 is 900ms. Freshness SLO is <= 500ms. By what percent is p99 over SLO?",
      "answer": 80,
      "unit": "%",
      "tolerance": 0.5,
      "explanation": "(900-500)/500 = 80% over SLO.",
      "detailedExplanation": "Do the conversion step first and maintain unit labels to prevent silent math errors. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-081",
      "type": "numeric-input",
      "question": "A quorum setup uses 5 replicas. Minimum reads+writes quorum sum needed to avoid stale overlap (strict majority condition)?",
      "answer": 6,
      "unit": "quorum-sum",
      "tolerance": 0,
      "explanation": "Need R + W > N, so greater than 5 means minimum sum 6.",
      "detailedExplanation": "Use base-unit arithmetic plus a magnitude check to keep the estimate robust under time pressure. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-082",
      "type": "numeric-input",
      "question": "A client performs 1,200 write-then-read flows/min. Read-your-write success is 97.5%. Failures per minute?",
      "answer": 30,
      "unit": "flows",
      "tolerance": 0.02,
      "explanation": "2.5% of 1,200 = 30 failures/min.",
      "detailedExplanation": "Anchor the math in base units and check each transformation to avoid compounding conversion errors. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-083",
      "type": "numeric-input",
      "question": "Monotonic-read violation rate is 0.08% across 4,500,000 reads/day. Violations/day?",
      "answer": 3600,
      "unit": "reads",
      "tolerance": 0.03,
      "explanation": "0.0008 * 4,500,000 = 3,600.",
      "detailedExplanation": "Normalize units before calculating, and keep order-of-magnitude checks explicit throughout. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-084",
      "type": "numeric-input",
      "question": "A critical path currently does 300ms reads from follower. Leader reads would be 420ms. Percent latency increase?",
      "answer": 40,
      "unit": "%",
      "tolerance": 0.3,
      "explanation": "(420-300)/300 = 40% increase.",
      "detailedExplanation": "Reduce the problem to base units, compute, and sanity-check the output scale before finalizing. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-085",
      "type": "numeric-input",
      "question": "An app enforces 2-second bounded staleness. Observed lag is 1.6s. Remaining staleness budget?",
      "answer": 0.4,
      "unit": "seconds",
      "tolerance": 0.05,
      "explanation": "2.0 - 1.6 = 0.4 seconds.",
      "detailedExplanation": "Start with unit normalization, then verify that the final magnitude passes a quick sanity check. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-086",
      "type": "numeric-input",
      "question": "A service has 24 replicas across regions; 3 are unhealthy. What percent of replicas remain healthy?",
      "answer": 87.5,
      "unit": "%",
      "tolerance": 0.3,
      "explanation": "21/24 = 87.5%.",
      "detailedExplanation": "Convert to base units first, then track powers of ten so arithmetic mistakes are easier to catch. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-087",
      "type": "numeric-input",
      "question": "A strict-consistency endpoint handles 9,000 requests/min at $0.0004/request. Cost per hour?",
      "answer": 216,
      "unit": "USD",
      "tolerance": 0.02,
      "explanation": "9,000*60 = 540,000 req/hr; *0.0004 = $216/hr.",
      "detailedExplanation": "Make the units explicit at every step, then validate the resulting magnitude against known anchors. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-088",
      "type": "numeric-input",
      "question": "Cross-device profile sync sees 72,000 reads/hour; 1.2% are non-monotonic. Non-monotonic reads/hour?",
      "answer": 864,
      "unit": "reads",
      "tolerance": 0.03,
      "explanation": "0.012 * 72,000 = 864.",
      "detailedExplanation": "Do the conversion step first and maintain unit labels to prevent silent math errors. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-089",
      "type": "numeric-input",
      "question": "A follower catch-up process replays 1,800 ops/sec. Backlog is 540,000 ops. Seconds to catch up (no new writes)?",
      "answer": 300,
      "unit": "seconds",
      "tolerance": 0,
      "explanation": "540,000 / 1,800 = 300 seconds.",
      "detailedExplanation": "Use base-unit arithmetic plus a magnitude check to keep the estimate robust under time pressure. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-090",
      "type": "ordering",
      "question": "Order a consistency-design workflow from first to last.",
      "items": [
        "Define entity invariants and user semantics",
        "Map guarantees per endpoint",
        "Implement routing/quorum/session controls",
        "Measure anomaly rates and refine"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Start with semantics, then enforce and measure.",
      "detailedExplanation": "Build the ordering from major scale differences first, then refine with adjacent comparisons. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-091",
      "type": "ordering",
      "question": "Order by increasing consistency strength (typical).",
      "items": [
        "Eventual consistency",
        "Causal consistency",
        "Sequential consistency",
        "Linearizability"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Guarantee strength generally increases along this path.",
      "detailedExplanation": "Rank by dominant bottleneck or magnitude, then validate adjacent transitions for consistency. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-092",
      "type": "ordering",
      "question": "Order by likely latency cost from lowest to highest.",
      "items": [
        "Local eventual follower read",
        "Bounded-staleness read with checks",
        "Leader/quorum read for critical path",
        "Global synchronous path across regions"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Stronger, broader coordination typically costs more latency.",
      "detailedExplanation": "Compare relative scale first, then confirm neighboring items pairwise to lock in the order. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-093",
      "type": "ordering",
      "question": "Order incident triage for stale-read complaints.",
      "items": [
        "Confirm affected endpoints and semantics",
        "Correlate with lag/route/version telemetry",
        "Apply targeted stronger read policy",
        "Backfill tests/alerts for recurrence"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Scope, diagnose, mitigate, then harden.",
      "detailedExplanation": "Order by relative impact rather than exact values, then verify the sequence one boundary at a time. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-094",
      "type": "ordering",
      "question": "Order by strongest to weakest fit for strict financial invariants.",
      "items": [
        "Linearizable critical writes/reads",
        "Quorum path with strong overlap",
        "Causal-only path",
        "Eventually consistent follower reads"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Invariant-critical flows need stronger guarantees.",
      "detailedExplanation": "Establish the extremes first and fill the middle with pairwise comparisons. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-095",
      "type": "ordering",
      "question": "Order user session guarantees by increasing scope.",
      "items": [
        "Read-your-writes",
        "Monotonic reads",
        "Writes-follow-reads",
        "Global serializable behavior"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Session guarantees are client-scoped; global serial behavior is broader.",
      "detailedExplanation": "Use relative magnitude to draft the order and confirm it with local adjacency checks. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-096",
      "type": "ordering",
      "question": "Order rollout safety for consistency changes.",
      "items": [
        "Canary affected endpoints",
        "Monitor freshness/anomaly SLOs",
        "Expand traffic gradually",
        "Finalize policy docs and guardrails"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Progressive rollout with telemetry limits blast radius.",
      "detailedExplanation": "Start with the clear smallest/largest anchors, then place intermediate items by pairwise checks. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cm-097",
      "type": "ordering",
      "question": "Order by increasing stale-read risk (typical).",
      "items": [
        "Leader read after write",
        "Version-checked follower read",
        "Random follower read with moderate lag",
        "Cross-region follower read with no version check"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Risk rises as routing/version constraints weaken.",
      "detailedExplanation": "Prioritize ratio-based comparisons and validate each neighboring step to avoid inversion mistakes. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-098",
      "type": "ordering",
      "question": "Order consistency-contract maturity.",
      "items": [
        "Implicit assumptions only",
        "Informal endpoint comments",
        "Documented per-endpoint guarantees",
        "Documented guarantees with automated conformance tests"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Maturity increases with explicit, testable contracts.",
      "detailedExplanation": "Build the ordering from major scale differences first, then refine with adjacent comparisons. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-099",
      "type": "ordering",
      "question": "Order by increasing tolerance to partitions (availability-biased view).",
      "items": [
        "Globally synchronous strict path",
        "Quorum-based strict path",
        "Session-level guarantees with fallbacks",
        "Eventually consistent local-availability path"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Availability under partitions generally increases as strict coordination is reduced.",
      "detailedExplanation": "Rank by dominant bottleneck or magnitude, then validate adjacent transitions for consistency. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cm-100",
      "type": "ordering",
      "question": "Order mitigation choices from fastest tactical to slowest structural.",
      "items": [
        "Route critical reads to leader temporarily",
        "Enable version-token checks for sessions",
        "Introduce endpoint-specific tunable consistency policy",
        "Re-architect data ownership boundaries"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Immediate routing fixes are fastest; architecture shifts take longest.",
      "detailedExplanation": "Start with the clear smallest/largest anchors, then place intermediate items by pairwise checks. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    }
  ]
}
