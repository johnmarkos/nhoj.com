{
  "unit": 3,
  "unitTitle": "API Design",
  "chapter": 6,
  "chapterTitle": "Error Handling",
  "chapterDescription": "HTTP error codes, error response formats, validation errors, retry strategies, and observability.",
  "problems": [
    {
      "id": "err-001",
      "type": "multiple-choice",
      "question": "What HTTP status code should an API return when the request is syntactically malformed (e.g., invalid JSON)?",
      "options": [
        "400 Bad Request",
        "422 Unprocessable Entity",
        "500 Internal Server Error",
        "406 Not Acceptable"
      ],
      "correct": 0,
      "explanation": "400 Bad Request indicates the server cannot process the request due to client error like malformed syntax. 422 is for semantically invalid but syntactically correct requests.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Prefer the approach that keeps client behavior explicit while preserving evolvability. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Keep quantities like 400 and 422 in aligned units before deciding on an implementation approach. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-002",
      "type": "multiple-choice",
      "question": "What HTTP status code indicates the request was valid but the server cannot process it due to semantic errors (e.g., invalid field values)?",
      "options": [
        "422 Unprocessable Entity",
        "400 Bad Request",
        "409 Conflict",
        "412 Precondition Failed"
      ],
      "correct": 0,
      "explanation": "422 Unprocessable Entity indicates the request is syntactically correct but semantically invalid. The server understands the content type and syntax but cannot process the instructions.",
      "detailedExplanation": "Generalize from hTTP status code indicates the request was valid but the server cannot process it due to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Keep quantities like 422 in aligned units before deciding on an implementation approach. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-003",
      "type": "multiple-choice",
      "question": "When a user tries to create a resource with a username that already exists, what status code is most appropriate?",
      "options": [
        "409 Conflict",
        "400 Bad Request",
        "422 Unprocessable Entity",
        "403 Forbidden"
      ],
      "correct": 0,
      "explanation": "409 Conflict indicates the request conflicts with the current state of the target resource. A duplicate username is a conflict with existing data.",
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Numbers such as 409 should be normalized first so downstream reasoning stays consistent. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-005",
      "type": "multiple-choice",
      "question": "What's the difference between 404 Not Found and 410 Gone?",
      "options": [
        "410 means the resource existed but was permanently deleted",
        "410 means temporary unavailability",
        "404 is for collections, 410 for items",
        "There is no practical difference"
      ],
      "correct": 0,
      "explanation": "410 Gone indicates the resource existed previously but has been intentionally and permanently removed. 404 means the resource was not found and may never have existed.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Good API choices balance client ergonomics, compatibility, and long-term evolvability. If values like 404 and 410 appear, convert them into one unit basis before comparison. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-006",
      "type": "multiple-choice",
      "question": "What HTTP status code indicates the client must authenticate to access the resource?",
      "options": [
        "401 Unauthorized",
        "403 Forbidden",
        "407 Proxy Authentication Required",
        "511 Network Authentication Required"
      ],
      "correct": 0,
      "explanation": "401 Unauthorized (despite the name) indicates authentication is required. The client should include valid credentials to retry the request.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Reject approaches that sound good in general but do not reduce concrete reliability risk. Tie decisions to concrete operational outcomes, not abstract reliability language. Numbers such as 401 should be normalized first so downstream reasoning stays consistent. Common pitfall: meeting average goals while missing tail-risk.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-007",
      "type": "multiple-choice",
      "question": "What status code should be returned when the user is authenticated but lacks permission for the requested action?",
      "options": [
        "403 Forbidden",
        "401 Unauthorized",
        "405 Method Not Allowed",
        "423 Locked"
      ],
      "correct": 0,
      "explanation": "403 Forbidden indicates the server understood the request but refuses to authorize it. The client's identity is known but they lack necessary permissions.",
      "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Prefer the approach that keeps client behavior explicit while preserving evolvability. Interface decisions should be justified by contract stability and client impact over time. If values like 403 appear, convert them into one unit basis before comparison. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-008",
      "type": "multiple-choice",
      "question": "What status code indicates the HTTP method is not supported for the requested resource?",
      "options": [
        "405 Method Not Allowed",
        "400 Bad Request",
        "501 Not Implemented",
        "415 Unsupported Media Type"
      ],
      "correct": 0,
      "explanation": "405 Method Not Allowed indicates the method (GET, POST, etc.) is not supported for the target resource. The response should include an Allow header listing valid methods.",
      "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Keep quantities like 405 in aligned units before deciding on an implementation approach. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-009",
      "type": "multiple-choice",
      "question": "What status code should be returned when the request content type is not supported by the server?",
      "options": [
        "415 Unsupported Media Type",
        "406 Not Acceptable",
        "400 Bad Request",
        "422 Unprocessable Entity"
      ],
      "correct": 0,
      "explanation": "415 Unsupported Media Type indicates the server refuses the request because the payload format is not supported. For example, sending XML when only JSON is accepted.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Discard options that weaken contract clarity or compatibility over time. Interface decisions should be justified by contract stability and client impact over time. Keep quantities like 415 in aligned units before deciding on an implementation approach. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-010",
      "type": "multiple-choice",
      "question": "What status code indicates the server cannot produce a response matching the Accept headers sent by the client?",
      "options": [
        "406 Not Acceptable",
        "415 Unsupported Media Type",
        "400 Bad Request",
        "501 Not Implemented"
      ],
      "correct": 0,
      "explanation": "406 Not Acceptable indicates the server cannot produce a response matching the acceptable values defined in the request's Accept headers.",
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Discard options that weaken contract clarity or compatibility over time. Good API choices balance client ergonomics, compatibility, and long-term evolvability. If values like 406 appear, convert them into one unit basis before comparison. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-011",
      "type": "multiple-choice",
      "question": "What's the appropriate status code when a client exceeds their rate limit?",
      "options": [
        "429 Too Many Requests",
        "503 Service Unavailable",
        "403 Forbidden",
        "400 Bad Request"
      ],
      "correct": 0,
      "explanation": "429 Too Many Requests indicates the user has sent too many requests in a given time period. It should include Retry-After header indicating when to retry.",
      "detailedExplanation": "Generalize from what's the appropriate status code when a client exceeds their rate limit to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Reject approaches that sound good in general but do not reduce concrete reliability risk. Tie decisions to concrete operational outcomes, not abstract reliability language. Numbers such as 429 should be normalized first so downstream reasoning stays consistent. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-013",
      "type": "multiple-choice",
      "question": "What status code should a gateway return when the upstream server returns an invalid response?",
      "options": [
        "502 Bad Gateway",
        "500 Internal Server Error",
        "503 Service Unavailable",
        "504 Gateway Timeout"
      ],
      "correct": 0,
      "explanation": "502 Bad Gateway indicates the server acting as a gateway received an invalid response from the upstream server it accessed to fulfill the request.",
      "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Good API choices balance client ergonomics, compatibility, and long-term evolvability. If values like 502 appear, convert them into one unit basis before comparison. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-014",
      "type": "multiple-choice",
      "question": "What status code indicates the server is temporarily unable to handle requests due to maintenance or overload?",
      "options": [
        "503 Service Unavailable",
        "500 Internal Server Error",
        "502 Bad Gateway",
        "429 Too Many Requests"
      ],
      "correct": 0,
      "explanation": "503 Service Unavailable indicates the server is temporarily unable to handle the request, often due to maintenance or overload. It should include Retry-After header.",
      "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Prioritize the approach that best protects reliability objectives under stated failure conditions. A strong real-world approach explains how failure mode, mitigation speed, and blast radius interact. If values like 503 appear, convert them into one unit basis before comparison. Common pitfall: meeting average goals while missing tail-risk.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-015",
      "type": "multiple-choice",
      "question": "What status code should be returned when the server didn't receive a timely response from an upstream server?",
      "options": [
        "504 Gateway Timeout",
        "408 Request Timeout",
        "503 Service Unavailable",
        "502 Bad Gateway"
      ],
      "correct": 0,
      "explanation": "504 Gateway Timeout indicates the server acting as a gateway did not receive a timely response from the upstream server.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Reject approaches that sound good in general but do not reduce concrete reliability risk. Map the approach to measurable reliability impact such as error-budget burn and recovery behavior. Keep quantities like 504 in aligned units before deciding on an implementation approach. Common pitfall: meeting average goals while missing tail-risk.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-016",
      "type": "multiple-choice",
      "question": "What status code indicates the client closed the connection before the server could send a response?",
      "options": [
        "408 Request Timeout",
        "504 Gateway Timeout",
        "499 Client Closed Request",
        "444 No Response"
      ],
      "correct": 0,
      "explanation": "408 Request Timeout indicates the server would like to shut down this unused connection. Note: 499 is nginx-specific and non-standard.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Reject approaches that sound good in general but do not reduce concrete reliability risk. A strong real-world approach explains how failure mode, mitigation speed, and blast radius interact. Keep quantities like 408 and 499 in aligned units before deciding on an implementation approach. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-017",
      "type": "multiple-choice",
      "question": "What HTTP header should accompany a 429 or 503 response to indicate when the client should retry?",
      "options": [
        "Retry-After",
        "X-RateLimit-Reset",
        "Cache-Control",
        "Expires"
      ],
      "correct": 0,
      "explanation": "Retry-After is the standard header indicating how long to wait before retrying. It can contain a date or number of seconds.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Prefer approaches that directly address failure mode, recovery path, and blast radius. Tie decisions to concrete operational outcomes, not abstract reliability language. Numbers such as 429 and 503 should be normalized first so downstream reasoning stays consistent. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-018",
      "type": "multiple-choice",
      "question": "According to RFC 7807 (Problem Details), what Content-Type should error responses use?",
      "options": [
        "application/problem+json",
        "application/json",
        "application/error+json",
        "text/json"
      ],
      "correct": 0,
      "explanation": "RFC 7807 defines application/problem+json as the media type for Problem Details for HTTP APIs, providing a standard format for error responses.",
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Keep quantities like 7807 in aligned units before deciding on an implementation approach. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-019",
      "type": "multiple-choice",
      "question": "In RFC 7807 Problem Details format, what field contains a URI identifying the problem type?",
      "options": ["type", "instance", "detail", "title"],
      "correct": 0,
      "explanation": "The 'type' field is a URI reference that identifies the problem type. When dereferenced, it should provide human-readable documentation.",
      "detailedExplanation": "Generalize from in RFC 7807 Problem Details format, what field contains a URI identifying the problem to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Discard options that weaken contract clarity or compatibility over time. Interface decisions should be justified by contract stability and client impact over time. If values like 7807 appear, convert them into one unit basis before comparison. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-020",
      "type": "multiple-choice",
      "question": "In RFC 7807 Problem Details, what is the 'instance' field used for?",
      "options": [
        "A URI identifying this specific occurrence of the problem",
        "The class name of the exception",
        "The server instance that generated the error",
        "A unique error ID"
      ],
      "correct": 0,
      "explanation": "The 'instance' field is a URI reference that identifies the specific occurrence of the problem. It may or may not yield further information when dereferenced.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Prefer the approach that keeps client behavior explicit while preserving evolvability. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Numbers such as 7807 should be normalized first so downstream reasoning stays consistent. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-021",
      "type": "multi-select",
      "question": "Which fields are REQUIRED in RFC 7807 Problem Details format?",
      "options": ["type", "title", "status", "detail", "instance"],
      "correctIndices": [0, 1],
      "explanation": "Only 'type' and 'title' are required. 'status', 'detail', and 'instance' are optional but recommended for providing complete error information.",
      "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Validate each proposed control independently and avoid partially true claims that fail under realistic load. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Numbers such as 7807 should be normalized first so downstream reasoning stays consistent. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-022",
      "type": "multi-select",
      "question": "Which of these are benefits of using RFC 7807 Problem Details for error responses?",
      "options": [
        "Standardized format across APIs",
        "Machine-readable error types",
        "Extensibility for custom fields",
        "Automatic error recovery"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "RFC 7807 provides standardization, machine-readable types via URIs, and allows extension fields. It doesn't enable automatic recoveryâ€”that requires client logic.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Evaluate each candidate approach independently under the same constraints. Map the approach to measurable reliability impact such as error-budget burn and recovery behavior. If values like 7807 appear, convert them into one unit basis before comparison. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-023",
      "type": "multiple-choice",
      "question": "What's the recommended approach for reporting multiple validation errors in a single response?",
      "options": [
        "Return all errors in an array within the response body",
        "Return only the first error encountered",
        "Return a 207 Multi-Status response",
        "Send multiple responses"
      ],
      "correct": 0,
      "explanation": "Returning all validation errors at once helps clients fix all issues in one attempt rather than discovering errors one at a time through multiple requests.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Discard options that weaken contract clarity or compatibility over time. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-024",
      "type": "multiple-choice",
      "question": "When reporting field-level validation errors, what information should be included?",
      "options": [
        "Field name/path, error code, and human-readable message",
        "Only the HTTP status code",
        "Stack trace and line number",
        "Just the field name"
      ],
      "correct": 0,
      "explanation": "Field-level errors should identify which field failed, provide a machine-readable error code, and include a human-readable message explaining the issue.",
      "detailedExplanation": "Generalize from reporting field-level validation errors, what information should be included to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Prefer the approach that keeps client behavior explicit while preserving evolvability. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-025",
      "type": "two-stage",
      "question": "A validation endpoint receives this request. What's wrong?",
      "context": "POST /users\n{\n  \"email\": \"not-an-email\",\n  \"age\": -5,\n  \"username\": \"ab\"\n}",
      "stages": [
        {
          "question": "How many validation errors should be reported?",
          "options": ["3 errors", "1 error", "2 errors", "4 errors"],
          "correct": 0,
          "explanation": "All three fields have issues: invalid email format, negative age, username too short.",
          "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Do not reset assumptions between stages; carry forward prior constraints directly. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: interface design coupled too tightly to internal implementation."
        },
        {
          "question": "What's the best way to structure these errors in the response?",
          "options": [
            "Array of error objects with field paths",
            "Single concatenated error message",
            "Nested object matching request structure",
            "Separate HTTP responses for each"
          ],
          "correct": 0,
          "explanation": "An array of error objects lets clients programmatically identify and display each error.",
          "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: ambiguous contracts that hide behavior changes."
        }
      ],
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-026",
      "type": "multiple-choice",
      "question": "How should an API indicate which field caused a validation error when dealing with nested objects?",
      "options": [
        "Use JSON Pointer or dot notation (e.g., 'address.zipCode')",
        "Return the entire object path as a string",
        "Only reference top-level field names",
        "Include the full object in the error"
      ],
      "correct": 0,
      "explanation": "JSON Pointer (RFC 6901) or dot notation provides a standard way to reference nested fields precisely, making it easy for clients to highlight specific form fields.",
      "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Interface decisions should be justified by contract stability and client impact over time. Numbers such as 6901 should be normalized first so downstream reasoning stays consistent. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-027",
      "type": "multiple-choice",
      "question": "What's the purpose of including error codes in addition to human-readable messages?",
      "options": [
        "Enable programmatic error handling and localization",
        "Reduce response payload size",
        "Comply with HTTP specifications",
        "Make debugging easier"
      ],
      "correct": 0,
      "explanation": "Error codes allow clients to handle specific errors programmatically and look up localized messages for different languages, independent of the server's message text.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Discard options that weaken contract clarity or compatibility over time. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-028",
      "type": "multi-select",
      "question": "Which information should typically be EXCLUDED from error responses sent to clients?",
      "options": [
        "Stack traces",
        "Internal server paths",
        "Database query details",
        "Field validation messages"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "Stack traces, server paths, and database details are security risks that could help attackers. Field validation messages are appropriate for clients to display.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Anchor decisions in explicit constraints, invariants, and observable failure signals rather than intuition. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-029",
      "type": "multiple-choice",
      "question": "Why might you return different error details in production vs development environments?",
      "options": [
        "Production should hide sensitive details while development shows more for debugging",
        "Production errors are simpler",
        "Development doesn't need error handling",
        "There should be no difference"
      ],
      "correct": 0,
      "explanation": "Production should hide implementation details for security, while development environments can show stack traces and verbose details to aid debugging.",
      "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Prefer the approach that keeps client behavior explicit while preserving evolvability. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-030",
      "type": "multiple-choice",
      "question": "What's the recommended practice for error message language/localization?",
      "options": [
        "Use Accept-Language header to determine response language",
        "Always return English messages",
        "Include messages in all supported languages",
        "Let the client translate error codes"
      ],
      "correct": 0,
      "explanation": "The Accept-Language header indicates the client's language preference. The server should return localized messages when possible, with fallback to a default language.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Prefer the approach that keeps client behavior explicit while preserving evolvability. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-031",
      "type": "ordering",
      "question": "Order these steps for implementing comprehensive API error handling:",
      "items": [
        "Define error code taxonomy",
        "Create error response schema",
        "Implement error middleware/handler",
        "Add logging and monitoring",
        "Document error responses"
      ],
      "correctOrder": [0, 1, 2, 3, 4],
      "explanation": "Start by defining error categories/codes, then create a consistent response format, implement central handling, add observability, and document for API consumers.",
      "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Build the rank from biggest differences first, then refine with adjacent checks. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-032",
      "type": "multiple-choice",
      "question": "What retry strategy should clients use when receiving a 503 Service Unavailable?",
      "options": [
        "Exponential backoff with jitter",
        "Immediate retry",
        "Fixed interval retry",
        "No retry, fail immediately"
      ],
      "correct": 0,
      "explanation": "Exponential backoff with jitter prevents thundering herd problems when many clients retry simultaneously. The jitter adds randomness to spread out retry attempts.",
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Prefer approaches that directly address failure mode, recovery path, and blast radius. A strong real-world approach explains how failure mode, mitigation speed, and blast radius interact. Keep quantities like 503 in aligned units before deciding on an implementation approach. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Retry pattern",
          "url": "https://learn.microsoft.com/en-us/azure/architecture/patterns/retry"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-033",
      "type": "multiple-choice",
      "question": "What is 'jitter' in the context of retry strategies?",
      "options": [
        "Random variation added to retry delays",
        "Rapid successive retries",
        "Priority-based retry ordering",
        "Synchronous retry across clients"
      ],
      "correct": 0,
      "explanation": "Jitter adds randomness to retry timing to prevent synchronized retries from many clients hitting the server at the same time (thundering herd).",
      "detailedExplanation": "Generalize from 'jitter' in the context of retry strategies to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Prefer approaches that directly address failure mode, recovery path, and blast radius. Tie decisions to concrete operational outcomes, not abstract reliability language. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Retry pattern",
          "url": "https://learn.microsoft.com/en-us/azure/architecture/patterns/retry"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-034",
      "type": "two-stage",
      "question": "A client receives a 429 response with 'Retry-After: 60'.",
      "stages": [
        {
          "question": "What does the Retry-After value indicate?",
          "options": [
            "Wait 60 seconds before retrying",
            "60 requests remaining in quota",
            "Rate limit resets at minute 60",
            "60% of rate limit consumed"
          ],
          "correct": 0,
          "explanation": "Retry-After: 60 means wait at least 60 seconds before retrying.",
          "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Solve this as chained reasoning where stage two must respect stage one assumptions. A strong real-world approach explains how failure mode, mitigation speed, and blast radius interact. Numbers such as 60 and 60 seconds should be normalized first so downstream reasoning stays consistent. Common pitfall: retry storms during partial failure."
        },
        {
          "question": "What should a well-behaved client do?",
          "options": [
            "Wait at least 60 seconds, then retry once",
            "Retry immediately with exponential backoff",
            "Cancel the request permanently",
            "Switch to a different endpoint"
          ],
          "correct": 0,
          "explanation": "Clients should respect the Retry-After header and not retry before the specified time.",
          "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Solve this as chained reasoning where stage two must respect stage one assumptions. Tie decisions to concrete operational outcomes, not abstract reliability language. Common pitfall: meeting average goals while missing tail-risk."
        }
      ],
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Do not reset assumptions between stages; carry forward prior constraints directly. Map the approach to measurable reliability impact such as error-budget burn and recovery behavior. Keep quantities like 429 and 60 in aligned units before deciding on an implementation approach. Common pitfall: meeting average goals while missing tail-risk.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Retry pattern",
          "url": "https://learn.microsoft.com/en-us/azure/architecture/patterns/retry"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-035",
      "type": "multiple-choice",
      "question": "Which HTTP status codes generally indicate the request is safe to retry?",
      "options": [
        "408, 429, 503, 504",
        "400, 401, 403, 404",
        "500, 501, 502, 505",
        "All 4xx and 5xx codes"
      ],
      "correct": 0,
      "explanation": "408 (timeout), 429 (rate limit), 503 (unavailable), and 504 (gateway timeout) are typically transient and safe to retry. 4xx client errors usually require request changes.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Prioritize the approach that best protects reliability objectives under stated failure conditions. Tie decisions to concrete operational outcomes, not abstract reliability language. Numbers such as 408 and 429 should be normalized first so downstream reasoning stays consistent. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-036",
      "type": "multi-select",
      "question": "Which HTTP 4xx errors might be worth retrying?",
      "options": [
        "408 Request Timeout",
        "409 Conflict (with optimistic locking)",
        "401 after token refresh",
        "400 Bad Request"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "408 is transient, 409 can resolve if you refetch and retry with new version, 401 can work after refreshing tokens. 400 indicates a fundamental request problem.",
      "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Validate each proposed control independently and avoid partially true claims that fail under realistic load. Tie decisions to concrete operational outcomes, not abstract reliability language. If values like 408 and 409 appear, convert them into one unit basis before comparison. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-037",
      "type": "multiple-choice",
      "question": "What is an idempotency key used for in API error recovery?",
      "options": [
        "Safely retry requests without causing duplicate operations",
        "Track which errors have occurred",
        "Identify unique error types",
        "Rate limit specific operations"
      ],
      "correct": 0,
      "explanation": "Idempotency keys allow clients to safely retry requests. The server uses the key to recognize retries and return the same result without re-executing the operation.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Prioritize the approach that best protects reliability objectives under stated failure conditions. Tie decisions to concrete operational outcomes, not abstract reliability language. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-038",
      "type": "two-stage",
      "question": "A payment API request times out. The client doesn't know if the payment succeeded.",
      "stages": [
        {
          "question": "What problem does this illustrate?",
          "options": [
            "Uncertainty about request completion",
            "Invalid payment credentials",
            "Rate limiting",
            "Authentication failure"
          ],
          "correct": 0,
          "explanation": "Timeouts create uncertainty about operation completion.",
          "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Do not reset assumptions between stages; carry forward prior constraints directly. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: ambiguous contracts that hide behavior changes."
        },
        {
          "question": "How should the API design address this?",
          "options": [
            "Require idempotency keys for payment requests",
            "Make all payments non-retryable",
            "Return immediate responses only",
            "Ignore timeout scenarios"
          ],
          "correct": 0,
          "explanation": "Idempotency keys let clients safely retryâ€”the server recognizes retries and returns the original result.",
          "detailedExplanation": "Generalize from the API design address this to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Do not reset assumptions between stages; carry forward prior constraints directly. A strong real-world approach explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: assuming recovery speed without operational proof."
        }
      ],
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Solve this as chained reasoning where stage two must respect stage one assumptions. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-039",
      "type": "multiple-choice",
      "question": "How should a server respond to a retry with the same idempotency key?",
      "options": [
        "Return the stored response from the original request",
        "Process the request again",
        "Return 409 Conflict",
        "Return 400 Bad Request"
      ],
      "correct": 0,
      "explanation": "When the server recognizes an idempotency key from a completed request, it should return the same response to maintain idempotent behavior.",
      "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Prioritize the approach that best protects reliability objectives under stated failure conditions. Map the approach to measurable reliability impact such as error-budget burn and recovery behavior. Common pitfall: meeting average goals while missing tail-risk.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-040",
      "type": "multiple-choice",
      "question": "What status code should be returned when an idempotency key is reused with different request parameters?",
      "options": [
        "422 Unprocessable Entity",
        "409 Conflict",
        "400 Bad Request",
        "200 OK with original response"
      ],
      "correct": 0,
      "explanation": "Reusing an idempotency key with different parameters is a client errorâ€”the key should uniquely identify a specific intended operation. 422 indicates this semantic error.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Discard options that weaken contract clarity or compatibility over time. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Numbers such as 422 should be normalized first so downstream reasoning stays consistent. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-041",
      "type": "ordering",
      "question": "Order the steps in handling a request with an idempotency key:",
      "items": [
        "Check if key exists in storage",
        "If new, process request and store result with key",
        "If exists, return stored response",
        "Validate idempotency key format"
      ],
      "correctOrder": [3, 0, 2, 1],
      "explanation": "First validate the key format, then check storage. If found, return the cached response. If new, process the request and store both key and response.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Place obvious extremes first, then sort the middle by pairwise comparison. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        },
        {
          "title": "Google Cloud Storage pricing",
          "url": "https://cloud.google.com/storage/pricing"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-042",
      "type": "multiple-choice",
      "question": "What's the circuit breaker pattern used for in API clients?",
      "options": [
        "Prevent repeated calls to a failing service",
        "Encrypt API communications",
        "Load balance across servers",
        "Cache successful responses"
      ],
      "correct": 0,
      "explanation": "Circuit breakers stop calling a failing service after repeated failures, giving it time to recover instead of overwhelming it with requests that will likely fail.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Prioritize the approach that best protects reliability objectives under stated failure conditions. Map the approach to measurable reliability impact such as error-budget burn and recovery behavior. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Circuit Breaker",
          "url": "https://martinfowler.com/bliki/CircuitBreaker.html"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-043",
      "type": "ordering",
      "question": "Order the circuit breaker states from healthy to fully open:",
      "items": [
        "Closed (normal operation)",
        "Half-Open (testing recovery)",
        "Open (failing fast)"
      ],
      "correctOrder": [0, 2, 1],
      "explanation": "Closed is normal. After failures exceed threshold, it opens (blocks calls). After timeout, it goes half-open to test if the service recovered, then returns to closed or open.",
      "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Order by relative scale and bottleneck effect, then validate neighboring items. Tie decisions to concrete operational outcomes, not abstract reliability language. Common pitfall: meeting average goals while missing tail-risk.",
      "references": [
        {
          "title": "Circuit Breaker",
          "url": "https://martinfowler.com/bliki/CircuitBreaker.html"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-044",
      "type": "two-stage",
      "question": "An API client's circuit breaker is in the 'Open' state for a payment service.",
      "stages": [
        {
          "question": "What happens when the client tries to make a payment request?",
          "options": [
            "Request fails immediately without calling the service",
            "Request is queued for later",
            "Request goes through normally",
            "Request is redirected to backup service"
          ],
          "correct": 0,
          "explanation": "Open circuit breakers fail fast without calling the service.",
          "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Do not reset assumptions between stages; carry forward prior constraints directly. A strong real-world approach explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: assuming recovery speed without operational proof."
        },
        {
          "question": "What should the API return to its own clients during this state?",
          "options": [
            "503 Service Unavailable with retry information",
            "200 OK with pending status",
            "500 Internal Server Error",
            "Silently drop the request"
          ],
          "correct": 0,
          "explanation": "The API should communicate unavailability to its clients with appropriate retry guidance.",
          "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Do not reset assumptions between stages; carry forward prior constraints directly. Tie decisions to concrete operational outcomes, not abstract reliability language. Common pitfall: retry storms during partial failure."
        }
      ],
      "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Solve this as chained reasoning where stage two must respect stage one assumptions. Tie decisions to concrete operational outcomes, not abstract reliability language. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Circuit Breaker",
          "url": "https://martinfowler.com/bliki/CircuitBreaker.html"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-045",
      "type": "multiple-choice",
      "question": "What triggers a circuit breaker to transition from Closed to Open?",
      "options": [
        "Failure rate exceeds threshold within time window",
        "A single failed request",
        "Manual intervention only",
        "Scheduled maintenance windows"
      ],
      "correct": 0,
      "explanation": "Circuit breakers typically open when failures exceed a threshold (e.g., 50% failure rate) within a sliding time window, indicating the service is having problems.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Prefer approaches that directly address failure mode, recovery path, and blast radius. Map the approach to measurable reliability impact such as error-budget burn and recovery behavior. Keep quantities like 50 in aligned units before deciding on an implementation approach. Common pitfall: meeting average goals while missing tail-risk.",
      "references": [
        {
          "title": "Circuit Breaker",
          "url": "https://martinfowler.com/bliki/CircuitBreaker.html"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-046",
      "type": "multiple-choice",
      "question": "What is 'graceful degradation' in API error handling?",
      "options": [
        "Providing reduced functionality when some components fail",
        "Gradually shutting down the service",
        "Slowly increasing error rates",
        "Deprecating old API versions"
      ],
      "correct": 0,
      "explanation": "Graceful degradation means the system continues operating with reduced functionality when some components fail, rather than failing completely.",
      "detailedExplanation": "Generalize from 'graceful degradation' in API error handling to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Reject approaches that sound good in general but do not reduce concrete reliability risk. Map the approach to measurable reliability impact such as error-budget burn and recovery behavior. Common pitfall: meeting average goals while missing tail-risk.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-047",
      "type": "two-stage",
      "question": "A product page API depends on: product service, recommendations service, and reviews service. The recommendations service is down.",
      "stages": [
        {
          "question": "What should the API return?",
          "options": [
            "Product data with empty recommendations section",
            "500 Internal Server Error",
            "Cache only - no live data",
            "Redirect to a different endpoint"
          ],
          "correct": 0,
          "explanation": "Return available data with degraded sections empty/missing.",
          "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: interface design coupled too tightly to internal implementation."
        },
        {
          "question": "How should the response indicate the partial failure?",
          "options": [
            "Include a warnings array noting degraded sections",
            "Return 206 Partial Content",
            "Set a custom header",
            "Don't indicate - client shouldn't know"
          ],
          "correct": 0,
          "explanation": "Inform the client about what's unavailable through a warnings field so they can adjust their UI.",
          "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: interface design coupled too tightly to internal implementation."
        }
      ],
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Do not reset assumptions between stages; carry forward prior constraints directly. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-048",
      "type": "multi-select",
      "question": "Which are valid graceful degradation strategies for API dependencies?",
      "options": [
        "Return cached/stale data",
        "Omit non-critical sections",
        "Use default/fallback values",
        "Fail the entire request"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "Cached data, omitting sections, and defaults all provide degraded but functional responses. Failing entirely defeats the purpose of graceful degradation.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Anchor decisions in explicit constraints, invariants, and observable failure signals rather than intuition. A strong real-world approach explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: meeting average goals while missing tail-risk.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-049",
      "type": "multiple-choice",
      "question": "What status code is appropriate for a response that contains some but not all requested data due to partial failure?",
      "options": [
        "200 OK with degradation indicators in body",
        "206 Partial Content",
        "207 Multi-Status",
        "503 Service Unavailable"
      ],
      "correct": 0,
      "explanation": "200 OK is appropriate when the request fundamentally succeeded. Include indicators in the response body (like warnings array) to communicate what's missing.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Prioritize explicit semantics and upgrade safety, not just short-term convenience. If values like 200 appear, convert them into one unit basis before comparison. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-050",
      "type": "multiple-choice",
      "question": "What is 207 Multi-Status primarily used for?",
      "options": [
        "WebDAV operations with multiple resources",
        "Partial API responses",
        "Batch operations with mixed results",
        "Gradual response streaming"
      ],
      "correct": 0,
      "explanation": "207 Multi-Status is a WebDAV status for operations affecting multiple resources. For REST APIs, batch operations typically use 200 with per-item statuses in the body.",
      "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Prefer the approach that keeps client behavior explicit while preserving evolvability. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Numbers such as 207 and 200 should be normalized first so downstream reasoning stays consistent. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-051",
      "type": "two-stage",
      "question": "A batch API receives a request to create 5 users. 3 succeed and 2 fail validation.",
      "stages": [
        {
          "question": "What HTTP status code should be returned?",
          "options": [
            "200 OK (or 207 Multi-Status)",
            "201 Created",
            "400 Bad Request",
            "500 Internal Server Error"
          ],
          "correct": 0,
          "explanation": "Return 200/207 with an array showing each item's outcome.",
          "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Keep quantities like 200 and 207 in aligned units before deciding on an implementation approach. Common pitfall: ambiguous contracts that hide behavior changes."
        },
        {
          "question": "How should the response body be structured?",
          "options": [
            "Array with individual status for each item",
            "Only the successful items",
            "Only the error messages",
            "Single success/failure boolean"
          ],
          "correct": 0,
          "explanation": "This lets clients know which succeeded and handle failures individually.",
          "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Do not reset assumptions between stages; carry forward prior constraints directly. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: interface design coupled too tightly to internal implementation."
        }
      ],
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Do not reset assumptions between stages; carry forward prior constraints directly. Interface decisions should be justified by contract stability and client impact over time. Keep quantities like 5 and 3 in aligned units before deciding on an implementation approach. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-052",
      "type": "multiple-choice",
      "question": "In a batch response with mixed results, what should each item's status object include?",
      "options": [
        "Index/ID, success boolean, and error details if failed",
        "Only success/failure flag",
        "Full request echo",
        "Just the error message"
      ],
      "correct": 0,
      "explanation": "Each item needs identification (index or ID), success/failure indication, and detailed error information for failures to enable client-side handling.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-053",
      "type": "ordering",
      "question": "Order these batch operation strategies from most to least atomic:",
      "items": [
        "All-or-nothing transaction",
        "Continue on error, report all results",
        "Stop at first error",
        "Async processing with eventual results"
      ],
      "correctOrder": [0, 2, 1, 3],
      "explanation": "All-or-nothing is fully atomic. Stop-at-first-error is partially atomic. Continue-on-error processes everything. Async is least atomic with eventual consistency.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Order by relative scale and bottleneck effect, then validate neighboring items. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-054",
      "type": "multiple-choice",
      "question": "What error handling approach is best when batch operations must be all-or-nothing?",
      "options": [
        "Validate all items first, then execute in a transaction",
        "Execute each item and rollback all on any failure",
        "Process items and return partial success",
        "Queue items for async processing"
      ],
      "correct": 0,
      "explanation": "Validating upfront catches errors before any changes are made. Then wrapping execution in a transaction ensures atomicity without partial state.",
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Prefer the approach that keeps client behavior explicit while preserving evolvability. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-055",
      "type": "multiple-choice",
      "question": "What is 'fail-fast' error handling?",
      "options": [
        "Stop processing immediately when an error occurs",
        "Return errors as quickly as possible",
        "Fail before any data is committed",
        "Aggressive timeout settings"
      ],
      "correct": 0,
      "explanation": "Fail-fast means stopping execution immediately when an error is detected rather than continuing and potentially making things worse or wasting resources.",
      "detailedExplanation": "Generalize from 'fail-fast' error handling to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Discard options that weaken contract clarity or compatibility over time. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-056",
      "type": "multi-select",
      "question": "When should an API use fail-fast error handling?",
      "options": [
        "Critical validation failures",
        "Security/authentication errors",
        "Unrecoverable system errors",
        "Minor data quality warnings"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "Fail fast on critical issues that can't be recovered from. Minor warnings might be logged but shouldn't stop processing if the operation can still succeed.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Anchor decisions in explicit constraints, invariants, and observable failure signals rather than intuition. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-057",
      "type": "multiple-choice",
      "question": "What should happen to API errors in terms of logging/observability?",
      "options": [
        "Log with context, assign severity, enable alerting on patterns",
        "Log only 500 errors",
        "Don't log errors, just return them",
        "Log everything at the same level"
      ],
      "correct": 0,
      "explanation": "Errors should be logged with request context, categorized by severity, and monitored for patterns. This enables debugging, alerting, and trend analysis.",
      "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Discard options that weaken contract clarity or compatibility over time. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-058",
      "type": "multi-select",
      "question": "What context should be included when logging API errors?",
      "options": [
        "Request ID/correlation ID",
        "Timestamp and endpoint",
        "Sanitized request parameters",
        "User passwords and tokens"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "Include IDs for tracing, timing info, and sanitized parameters. Never log sensitive data like passwords, tokens, or PII in plain text.",
      "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Anchor decisions in explicit constraints, invariants, and observable failure signals rather than intuition. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-059",
      "type": "multiple-choice",
      "question": "What is a correlation ID used for in API error handling?",
      "options": [
        "Tracing a request across multiple services",
        "Correlating errors with users",
        "Matching request/response pairs",
        "Identifying duplicate requests"
      ],
      "correct": 0,
      "explanation": "Correlation IDs (or trace IDs) are passed through service calls, allowing engineers to trace a request's path and find related logs across distributed systems.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-060",
      "type": "two-stage",
      "question": "A user reports an error they saw in your app. They provide the error message but no other details.",
      "stages": [
        {
          "question": "What would make this easier to debug?",
          "options": [
            "A unique error ID shown to users and logged server-side",
            "More detailed error messages to users",
            "Real-time log streaming to users",
            "User screenshots of the error"
          ],
          "correct": 0,
          "explanation": "Displaying a unique error ID lets users report it, and engineers can find the corresponding logs.",
          "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: interface design coupled too tightly to internal implementation."
        },
        {
          "question": "How should this error ID be generated?",
          "options": [
            "UUID or request correlation ID",
            "Sequential integer",
            "Error type code",
            "Timestamp only"
          ],
          "correct": 0,
          "explanation": "UUIDs ensure uniqueness across distributed systems.",
          "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Do not reset assumptions between stages; carry forward prior constraints directly. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: breaking clients during version evolution."
        }
      ],
      "detailedExplanation": "Generalize from user reports an error they saw in your app to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-062",
      "type": "multiple-choice",
      "question": "At what level should a handled validation error (400 response) typically be logged?",
      "options": ["Info or Warning", "Error", "Critical", "Debug only"],
      "correct": 0,
      "explanation": "Validation errors are expected client mistakes, not system problems. Info/Warning level is appropriate. Reserve Error/Critical for unexpected system failures.",
      "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Prefer the approach that keeps client behavior explicit while preserving evolvability. Interface decisions should be justified by contract stability and client impact over time. If values like 400 appear, convert them into one unit basis before comparison. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-063",
      "type": "multiple-choice",
      "question": "What's the difference between logging a 400 error vs a 500 error?",
      "options": [
        "400s are client errors (lower severity), 500s are server errors (higher severity)",
        "No difference in logging",
        "400s shouldn't be logged at all",
        "500s don't need context"
      ],
      "correct": 0,
      "explanation": "400 errors indicate client mistakes and are expected. 500 errors indicate server problems requiring investigation. They warrant different severity levels and alerting.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Discard options that weaken contract clarity or compatibility over time. Interface decisions should be justified by contract stability and client impact over time. If values like 400 and 500 appear, convert them into one unit basis before comparison. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-064",
      "type": "multi-select",
      "question": "Which metrics should be tracked for API error monitoring?",
      "options": [
        "Error rate by endpoint",
        "Error rate by status code",
        "p99 response time for errors",
        "Total request volume"
      ],
      "correctIndices": [0, 1, 2, 3],
      "explanation": "All these metrics are valuable: endpoint-specific rates find problematic endpoints, status code distribution shows error types, latency matters even for errors, and volume provides context.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Evaluate each candidate approach independently under the same constraints. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-065",
      "type": "multiple-choice",
      "question": "What error rate threshold might trigger an alert for a production API?",
      "options": [
        "When 5xx rate exceeds 1% for 5+ minutes",
        "Any single 500 error",
        "When error count exceeds 1000/day",
        "Only during business hours"
      ],
      "correct": 0,
      "explanation": "Percentage-based thresholds over time windows catch significant issues while avoiding alert fatigue from isolated errors. Specific thresholds vary by service criticality.",
      "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-066",
      "type": "two-stage",
      "question": "Your API monitoring shows a spike in 500 errors starting 10 minutes ago.",
      "stages": [
        {
          "question": "What's the first thing to check?",
          "options": [
            "Recent deployments or configuration changes",
            "User complaints",
            "Full error logs for all time",
            "Database storage capacity"
          ],
          "correct": 0,
          "explanation": "Correlating errors with recent changes often identifies the cause.",
          "detailedExplanation": "Generalize from what's the first thing to check to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Solve this as chained reasoning where stage two must respect stage one assumptions. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: breaking clients during version evolution."
        },
        {
          "question": "What error information helps identify the root cause?",
          "options": [
            "Correlation IDs, stack traces, and affected endpoints",
            "Total error count only",
            "User session information",
            "API version numbers"
          ],
          "correct": 0,
          "explanation": "Detailed logs with request context and stack traces help pinpoint the specific failure.",
          "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Do not reset assumptions between stages; carry forward prior constraints directly. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: interface design coupled too tightly to internal implementation."
        }
      ],
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Prioritize explicit semantics and upgrade safety, not just short-term convenience. If values like 500 and 10 minutes appear, convert them into one unit basis before comparison. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-067",
      "type": "multiple-choice",
      "question": "What is the 'dead letter queue' pattern for handling errors?",
      "options": [
        "Storing failed messages/requests for later analysis or retry",
        "A queue that deletes all messages",
        "The final fallback service",
        "A queue for deprecated endpoints"
      ],
      "correct": 0,
      "explanation": "Dead letter queues capture messages that couldn't be processed successfully, enabling later analysis, manual intervention, or automated retry after fixes.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Prefer approaches that directly address failure mode, recovery path, and blast radius. A strong real-world approach explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Retry pattern",
          "url": "https://learn.microsoft.com/en-us/azure/architecture/patterns/retry"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-068",
      "type": "multiple-choice",
      "question": "When should an API return 501 Not Implemented?",
      "options": [
        "The server doesn't support the functionality required to fulfill the request",
        "The endpoint is planned but not built yet",
        "The method is deprecated",
        "The feature is disabled by configuration"
      ],
      "correct": 0,
      "explanation": "501 indicates the server doesn't recognize the request method or lacks ability to fulfill it. It's not for planned features or disabled functionality.",
      "detailedExplanation": "Generalize from an API return 501 Not Implemented to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Prioritize explicit semantics and upgrade safety, not just short-term convenience. If values like 501 appear, convert them into one unit basis before comparison. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-069",
      "type": "multiple-choice",
      "question": "What's the difference between 501 Not Implemented and 405 Method Not Allowed?",
      "options": [
        "501 means the server doesn't support the method at all; 405 means the method isn't allowed for this specific resource",
        "They are equivalent",
        "501 is for POST only",
        "405 is for legacy systems"
      ],
      "correct": 0,
      "explanation": "405 means the method exists but isn't allowed for this resource (e.g., DELETE on a read-only resource). 501 means the method itself isn't supported by the server.",
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Prefer the approach that keeps client behavior explicit while preserving evolvability. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Keep quantities like 501 and 405 in aligned units before deciding on an implementation approach. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-070",
      "type": "multiple-choice",
      "question": "What status code should be returned if a required request header is missing?",
      "options": [
        "400 Bad Request",
        "422 Unprocessable Entity",
        "412 Precondition Failed",
        "428 Precondition Required"
      ],
      "correct": 0,
      "explanation": "Missing required headers make the request malformed, warranting 400 Bad Request. 412 is for conditional request preconditions (If-Match, etc.) that failed.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Prefer the approach that keeps client behavior explicit while preserving evolvability. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Keep quantities like 400 and 412 in aligned units before deciding on an implementation approach. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-071",
      "type": "multiple-choice",
      "question": "What is 428 Precondition Required used for?",
      "options": [
        "Indicating the request must include conditional headers (like If-Match)",
        "A required field is missing",
        "The precondition check failed",
        "Server requires authentication"
      ],
      "correct": 0,
      "explanation": "428 tells clients they must include conditional headers (If-Match, If-Unmodified-Since) to prevent lost updates from concurrent modifications.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Numbers such as 428 should be normalized first so downstream reasoning stays consistent. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-072",
      "type": "two-stage",
      "question": "Two users simultaneously edit the same document. User A saves first, then User B tries to save.",
      "stages": [
        {
          "question": "What status code should User B receive?",
          "options": [
            "409 Conflict or 412 Precondition Failed",
            "200 OK (last write wins)",
            "423 Locked",
            "400 Bad Request"
          ],
          "correct": 0,
          "explanation": "409/412 indicates the conflict.",
          "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Do not reset assumptions between stages; carry forward prior constraints directly. Interface decisions should be justified by contract stability and client impact over time. Keep quantities like 409 and 412 in aligned units before deciding on an implementation approach. Common pitfall: ambiguous contracts that hide behavior changes."
        },
        {
          "question": "What information should the error response include?",
          "options": [
            "Current version/ETag and suggestion to refetch",
            "Just an error message",
            "The other user's identity",
            "Full edit history"
          ],
          "correct": 0,
          "explanation": "Providing the current version lets User B fetch the latest, merge changes if possible, and retry with the correct precondition.",
          "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Do not reset assumptions between stages; carry forward prior constraints directly. Map the approach to measurable reliability impact such as error-budget burn and recovery behavior. Common pitfall: retry storms during partial failure."
        }
      ],
      "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Solve this as chained reasoning where stage two must respect stage one assumptions. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-073",
      "type": "multiple-choice",
      "question": "What HTTP header pair is used for optimistic concurrency control?",
      "options": [
        "ETag and If-Match",
        "Last-Modified and If-Unmodified-Since",
        "Version and If-Version",
        "Lock-Token and If-Locked"
      ],
      "correct": 0,
      "explanation": "ETag provides a resource version identifier. If-Match in requests ensures the update only proceeds if the resource hasn't changed since it was fetched.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Prefer the approach that keeps client behavior explicit while preserving evolvability. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-074",
      "type": "ordering",
      "question": "Order the steps for implementing optimistic concurrency control:",
      "items": [
        "Client fetches resource with ETag",
        "Client sends update with If-Match header",
        "Server compares ETag to current version",
        "Server returns 412 if mismatch, updates if match"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Client gets resource and ETag, includes ETag in If-Match when updating, server validates the version matches before applying the update.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Build the rank from biggest differences first, then refine with adjacent checks. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-075",
      "type": "multiple-choice",
      "question": "What status code indicates a resource is locked and cannot be modified?",
      "options": [
        "423 Locked",
        "409 Conflict",
        "403 Forbidden",
        "405 Method Not Allowed"
      ],
      "correct": 0,
      "explanation": "423 Locked (from WebDAV) indicates the resource is currently locked. This is used when explicit locking mechanisms prevent modification.",
      "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Discard options that weaken contract clarity or compatibility over time. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Keep quantities like 423 in aligned units before deciding on an implementation approach. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-076",
      "type": "multiple-choice",
      "question": "What's the purpose of the 'Allow' header in a 405 response?",
      "options": [
        "List the HTTP methods supported for this resource",
        "Indicate allowed IP addresses",
        "Specify allowed content types",
        "List authorized users"
      ],
      "correct": 0,
      "explanation": "When returning 405, the Allow header must list valid methods for the resource (e.g., 'Allow: GET, HEAD, POST'), helping clients understand what's permitted.",
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Discard options that weaken contract clarity or compatibility over time. Interface decisions should be justified by contract stability and client impact over time. Keep quantities like 405 in aligned units before deciding on an implementation approach. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-077",
      "type": "multi-select",
      "question": "Which headers should accompany a 401 Unauthorized response?",
      "options": [
        "WWW-Authenticate",
        "Optionally Retry-After",
        "Content-Type (for error body)",
        "Location"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "WWW-Authenticate indicates the authentication scheme required. Error body with Content-Type explains the issue. Retry-After is useful if authentication is temporarily unavailable.",
      "detailedExplanation": "Generalize from headers should accompany a 401 Unauthorized response to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Anchor decisions in explicit constraints, invariants, and observable failure signals rather than intuition. A strong real-world approach explains how failure mode, mitigation speed, and blast radius interact. Numbers such as 401 should be normalized first so downstream reasoning stays consistent. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Retry pattern",
          "url": "https://learn.microsoft.com/en-us/azure/architecture/patterns/retry"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-078",
      "type": "two-stage",
      "question": "An API client receives a 401 response. The WWW-Authenticate header says 'Bearer realm=\"api\"'.",
      "stages": [
        {
          "question": "What does this indicate?",
          "options": [
            "Bearer token authentication is required",
            "Basic auth is required",
            "API key in query string is required",
            "OAuth authorization code flow needed"
          ],
          "correct": 0,
          "explanation": "WWW-Authenticate: Bearer indicates bearer token authentication.",
          "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Do not reset assumptions between stages; carry forward prior constraints directly. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: interface design coupled too tightly to internal implementation."
        },
        {
          "question": "How should the client retry the request?",
          "options": [
            "Include 'Authorization: Bearer <token>' header",
            "Include 'Authorization: Basic <credentials>'",
            "Add api_key query parameter",
            "Use a cookie"
          ],
          "correct": 0,
          "explanation": "The client should obtain a valid token and include it in the Authorization header.",
          "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Solve this as chained reasoning where stage two must respect stage one assumptions. Tie decisions to concrete operational outcomes, not abstract reliability language. Common pitfall: retry storms during partial failure."
        }
      ],
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Solve this as chained reasoning where stage two must respect stage one assumptions. Interface decisions should be justified by contract stability and client impact over time. If values like 401 appear, convert them into one unit basis before comparison. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-079",
      "type": "multiple-choice",
      "question": "Should APIs reveal whether a username exists in a 401 response?",
      "options": [
        "No, use generic messages to prevent user enumeration",
        "Yes, it helps users correct their input",
        "Only in development environments",
        "Only for admin users"
      ],
      "correct": 0,
      "explanation": "Revealing whether a username exists enables attackers to enumerate valid accounts. Use generic messages like 'Invalid credentials' for both wrong username and wrong password.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Discard options that weaken contract clarity or compatibility over time. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Keep quantities like 401 in aligned units before deciding on an implementation approach. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-080",
      "type": "multiple-choice",
      "question": "What's the security concern with detailed error messages?",
      "options": [
        "They may reveal system internals useful to attackers",
        "They increase response size",
        "They're harder to translate",
        "They're more expensive to generate"
      ],
      "correct": 0,
      "explanation": "Detailed errors (stack traces, database errors, file paths) can reveal vulnerabilities, technology stack, and internal structure that attackers can exploit.",
      "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Discard options that weaken contract clarity or compatibility over time. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-081",
      "type": "multi-select",
      "question": "Which error details are safe to include in production API responses?",
      "options": [
        "Error code/type identifier",
        "User-friendly message",
        "Field-level validation details",
        "SQL query that failed"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "Error codes, friendly messages, and validation feedback are safe and helpful. SQL queries expose database schema and could reveal SQL injection opportunities.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Validate each proposed control independently and avoid partially true claims that fail under realistic load. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-082",
      "type": "ordering",
      "question": "Order these error handling tasks by when they should occur in request processing:",
      "items": [
        "Input validation",
        "Authentication check",
        "Authorization check",
        "Business logic execution",
        "Error response formatting"
      ],
      "correctOrder": [0, 1, 2, 3, 4],
      "explanation": "Validate input first (reject malformed requests early), then authenticate, authorize, execute business logic, and format any errors for the response.",
      "detailedExplanation": "Generalize from order these error handling tasks by when they should occur in request processing: to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Build the rank from biggest differences first, then refine with adjacent checks. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-083",
      "type": "multiple-choice",
      "question": "Why should input validation happen before authentication?",
      "options": [
        "To reject obviously invalid requests without wasting auth resources",
        "Validation is less secure",
        "Auth errors should come first",
        "It's required by HTTP spec"
      ],
      "correct": 0,
      "explanation": "Basic input validation (malformed JSON, required fields) should fail fast. However, sensitive validation that reveals business logic should wait until after auth.",
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Prefer the approach that keeps client behavior explicit while preserving evolvability. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-084",
      "type": "two-stage",
      "question": "A request has an invalid auth token AND invalid JSON body.",
      "stages": [
        {
          "question": "Which error should be returned?",
          "options": [
            "400 Bad Request (invalid JSON)",
            "401 Unauthorized",
            "422 Unprocessable Entity",
            "Both errors combined"
          ],
          "correct": 0,
          "explanation": "Malformed requests should fail immediately.",
          "detailedExplanation": "Generalize from error should be returned to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Do not reset assumptions between stages; carry forward prior constraints directly. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: interface design coupled too tightly to internal implementation."
        },
        {
          "question": "Why is this ordering preferred?",
          "options": [
            "Fail fast on obviously bad requests; don't waste cycles on auth",
            "Auth errors are more important",
            "400 errors are more informative",
            "HTTP spec requires this order"
          ],
          "correct": 0,
          "explanation": "There's no point authenticating a request that can't be processed anyway. Save auth processing for valid requests.",
          "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Do not reset assumptions between stages; carry forward prior constraints directly. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: interface design coupled too tightly to internal implementation."
        }
      ],
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 7519: JSON Web Token (JWT)",
          "url": "https://www.rfc-editor.org/rfc/rfc7519"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-085",
      "type": "multiple-choice",
      "question": "What's the purpose of centralizing error handling in API frameworks?",
      "options": [
        "Consistent error format and behavior across all endpoints",
        "Reduce code in controllers",
        "Improve performance",
        "Enable error recovery"
      ],
      "correct": 0,
      "explanation": "Centralized error handlers (middleware/exception handlers) ensure all endpoints return consistently formatted errors, simplifying client implementation.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Discard options that weaken contract clarity or compatibility over time. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-086",
      "type": "multi-select",
      "question": "What should a centralized error handler do?",
      "options": [
        "Map exceptions to appropriate HTTP status codes",
        "Format error responses consistently",
        "Log errors with context",
        "Retry failed operations"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "Central handlers map errors to statuses, format responses, and log. Retries are typically handled at different layers (client-side or specific middleware).",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Evaluate each candidate approach independently under the same constraints. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-087",
      "type": "ordering",
      "question": "Order these error handling components from closest to business logic to closest to client:",
      "items": [
        "Business logic exceptions",
        "Service layer error handling",
        "Controller/handler error mapping",
        "Error response middleware",
        "HTTP response"
      ],
      "correctOrder": [0, 1, 2, 3, 4],
      "explanation": "Errors bubble up from business logic through service layer, controller mapping, error middleware, and finally become HTTP responses sent to clients.",
      "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Order by relative scale and bottleneck effect, then validate neighboring items. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-088",
      "type": "multiple-choice",
      "question": "What status code should be used for a downstream service timeout?",
      "options": [
        "504 Gateway Timeout",
        "500 Internal Server Error",
        "503 Service Unavailable",
        "408 Request Timeout"
      ],
      "correct": 0,
      "explanation": "504 Gateway Timeout indicates the server acting as a gateway didn't receive a timely response from upstream. This clearly communicates the timeout was downstream.",
      "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Prioritize the approach that best protects reliability objectives under stated failure conditions. Tie decisions to concrete operational outcomes, not abstract reliability language. Keep quantities like 504 in aligned units before deciding on an implementation approach. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-089",
      "type": "multiple-choice",
      "question": "Should clients see different errors for 'service down' vs 'service slow'?",
      "options": [
        "Yes, it helps clients choose appropriate retry strategies",
        "No, all failures should look the same",
        "Only in debug mode",
        "Only for internal clients"
      ],
      "correct": 0,
      "explanation": "Distinguishing timeout (slow) from connection refused (down) helps clients. Timeouts might warrant longer retry delays; down services might need circuit breaking.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Prefer approaches that directly address failure mode, recovery path, and blast radius. Map the approach to measurable reliability impact such as error-budget burn and recovery behavior. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Retry pattern",
          "url": "https://learn.microsoft.com/en-us/azure/architecture/patterns/retry"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-090",
      "type": "two-stage",
      "question": "Your API calls three microservices. Service A returns quickly, Service B times out, Service C returns an error.",
      "stages": [
        {
          "question": "If all three are required, what should the response be?",
          "options": [
            "500-level error indicating which services failed",
            "Partial data from Service A only",
            "200 with warnings",
            "504 Gateway Timeout"
          ],
          "correct": 0,
          "explanation": "When required dependencies fail, indicate the failure clearly.",
          "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Solve this as chained reasoning where stage two must respect stage one assumptions. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: ambiguous contracts that hide behavior changes."
        },
        {
          "question": "What information helps the client understand the failure?",
          "options": [
            "Which operation failed and whether retry might help",
            "Full details of all service calls",
            "Just a generic error message",
            "The other services' successful data"
          ],
          "correct": 0,
          "explanation": "Tell clients which part failed and whether it's transient (retry-worthy) or permanent.",
          "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Do not reset assumptions between stages; carry forward prior constraints directly. Tie decisions to concrete operational outcomes, not abstract reliability language. Common pitfall: retry storms during partial failure."
        }
      ],
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-091",
      "type": "multiple-choice",
      "question": "What is 'error translation' in microservices?",
      "options": [
        "Converting internal errors to appropriate external error responses",
        "Localizing error messages",
        "Converting between error formats",
        "Logging errors in multiple systems"
      ],
      "correct": 0,
      "explanation": "Error translation converts internal error details (database errors, service failures) into appropriate API error responses without exposing internal implementation.",
      "detailedExplanation": "Generalize from 'error translation' in microservices to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-092",
      "type": "multi-select",
      "question": "Which internal errors should be translated to generic external errors?",
      "options": [
        "Database constraint violations",
        "File system errors",
        "Third-party API failures",
        "User input validation errors"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "Database, filesystem, and third-party errors should be translated to hide implementation details. User validation errors should be specific to help users fix issues.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Anchor decisions in explicit constraints, invariants, and observable failure signals rather than intuition. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-093",
      "type": "multiple-choice",
      "question": "What's the danger of exposing database errors directly to API clients?",
      "options": [
        "Reveals schema details and potential SQL injection vectors",
        "Database errors are too technical",
        "It violates database licensing",
        "Clients can't understand them"
      ],
      "correct": 0,
      "explanation": "Database errors may reveal table names, column names, constraints, and query structureâ€”information attackers can use to craft more effective attacks.",
      "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Prefer the approach that keeps client behavior explicit while preserving evolvability. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-094",
      "type": "two-stage",
      "question": "A database unique constraint violation occurs when creating a user.",
      "stages": [
        {
          "question": "What external error should the API return?",
          "options": [
            "409 Conflict with message about duplicate value",
            "400 Bad Request with constraint name",
            "500 Internal Server Error",
            "422 with database error details"
          ],
          "correct": 0,
          "explanation": "Return a user-friendly conflict error externally.",
          "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: ambiguous contracts that hide behavior changes."
        },
        {
          "question": "What should be logged internally?",
          "options": [
            "Full constraint name and query for debugging",
            "Only the HTTP status code",
            "Nothing - it's a client error",
            "The user's password for context"
          ],
          "correct": 0,
          "explanation": "Log full details internally for debugging, but never log sensitive data like passwords.",
          "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: breaking clients during version evolution."
        }
      ],
      "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-095",
      "type": "ordering",
      "question": "Order these steps for proper error response when a database connection fails:",
      "items": [
        "Catch database connection exception",
        "Log error with full details internally",
        "Translate to generic server error",
        "Return 503 with retry guidance"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Catch the specific error, log everything for ops/debugging, translate to an appropriate generic error, and return with guidance for clients.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Build the rank from biggest differences first, then refine with adjacent checks. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-096",
      "type": "multiple-choice",
      "question": "What should an API do when it catches an unexpected exception type?",
      "options": [
        "Return 500 Internal Server Error with generic message",
        "Return the exception message to the client",
        "Ignore it and return 200",
        "Crash the application"
      ],
      "correct": 0,
      "explanation": "Unexpected exceptions should return a generic 500 error. Never expose exception details to clients. Log the full exception for investigation.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Discard options that weaken contract clarity or compatibility over time. Interface decisions should be justified by contract stability and client impact over time. Keep quantities like 500 in aligned units before deciding on an implementation approach. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-097",
      "type": "multi-select",
      "question": "Which are good practices for error message content?",
      "options": [
        "Be specific enough to be actionable",
        "Avoid technical jargon for end-user messages",
        "Include next steps when possible",
        "Always include stack traces"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "Messages should help users understand and fix issues, avoid jargon, and guide next steps. Stack traces are internalâ€”never expose them to external clients.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Anchor decisions in explicit constraints, invariants, and observable failure signals rather than intuition. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-098",
      "type": "two-stage",
      "question": "A user submits a form and receives: 'Error: NullPointerException at UserService.java:42'",
      "stages": [
        {
          "question": "What's wrong with this error message?",
          "options": [
            "Exposes internal implementation and isn't actionable",
            "It's too short",
            "It should include the full stack trace",
            "NullPointerException is the wrong type"
          ],
          "correct": 0,
          "explanation": "Good error messages don't expose internals.",
          "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Solve this as chained reasoning where stage two must respect stage one assumptions. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: ambiguous contracts that hide behavior changes."
        },
        {
          "question": "What would be a better error message?",
          "options": [
            "'Unable to process your request. Please try again or contact support.'",
            "'NullPointerException: UserService'",
            "'Error 42: User Service'",
            "'Check your input and try again'"
          ],
          "correct": 0,
          "explanation": "Good error messages are user-friendly, don't expose internals, and provide actionable guidance. Include an error ID for support reference if possible.",
          "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Solve this as chained reasoning where stage two must respect stage one assumptions. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: breaking clients during version evolution."
        }
      ],
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Do not reset assumptions between stages; carry forward prior constraints directly. Interface decisions should be justified by contract stability and client impact over time. If values like 42 appear, convert them into one unit basis before comparison. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-099",
      "type": "ordering",
      "question": "Order these components of a well-designed error response:",
      "items": [
        "HTTP status code",
        "Error type/code identifier",
        "Human-readable message",
        "Request/correlation ID",
        "Detailed field errors (if validation)"
      ],
      "correctOrder": [0, 1, 2, 3, 4],
      "explanation": "Start with HTTP status, include machine-readable code, human message, tracking ID for support, and specific field errors when applicable.",
      "detailedExplanation": "Generalize from order these components of a well-designed error response: to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Build the rank from biggest differences first, then refine with adjacent checks. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    },
    {
      "id": "err-100",
      "type": "two-stage",
      "question": "You're designing an error response format for a new API.",
      "stages": [
        {
          "question": "Which standard should you consider following?",
          "options": [
            "RFC 7807 (Problem Details for HTTP APIs)",
            "Custom JSON format",
            "Plain text messages",
            "XML error responses"
          ],
          "correct": 0,
          "explanation": "RFC 7807 provides a standard format for error responses.",
          "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Numbers such as 7807 should be normalized first so downstream reasoning stays consistent. Common pitfall: breaking clients during version evolution."
        },
        {
          "question": "What's a key benefit of using this standard?",
          "options": [
            "Client libraries may already support it, reducing integration effort",
            "It's required by HTTP specification",
            "It's more compact than alternatives",
            "It supports all programming languages"
          ],
          "correct": 0,
          "explanation": "RFC 7807 provides a standard format that many libraries support. Using standards reduces client integration effort and ensures consistent error handling.",
          "detailedExplanation": "Generalize from what's a key benefit of using this standard to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Do not reset assumptions between stages; carry forward prior constraints directly. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Keep quantities like 7807 in aligned units before deciding on an implementation approach. Common pitfall: ambiguous contracts that hide behavior changes."
        }
      ],
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["api-design", "error-handling"],
      "difficulty": "senior"
    }
  ]
}
