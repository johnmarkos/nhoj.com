{
  "unit": 8,
  "unitTitle": "Consistency & Coordination",
  "chapter": 6,
  "chapterTitle": "Consensus & Membership",
  "chapterDescription": "Applying consensus and safe membership changes to preserve correctness under failures, partitions, and reconfiguration events.",
  "problems": [
    {
      "id": "cc-cs-001",
      "type": "multiple-choice",
      "question": "A metadata cluster control plane is facing quorum loss during node failures. Which consensus/membership decision is strongest? Recent failover tests exposed unsafe assumptions.",
      "options": [
        "Use quorum intersection-safe reconfiguration (joint consensus style) for membership changes.",
        "Assume any reachable node may accept writes during partitions.",
        "Apply membership changes in large batches for speed.",
        "Treat heartbeat misses as immediate permanent failure proof."
      ],
      "correct": 0,
      "explanation": "Consensus safety depends on quorum/term discipline, controlled membership changes, and stale-leader write rejection.",
      "detailedExplanation": "The decision turns on \"metadata cluster control plane is facing quorum loss during node failures\". Prioritize the option that best protects the reliability objective under the stated failure conditions. Tie the decision to concrete operational outcomes, not abstract reliability language. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-002",
      "type": "multiple-choice",
      "question": "A service discovery registry is facing split-brain after partition heal. Which consensus/membership decision is strongest? Write correctness must survive leader churn.",
      "options": [
        "Assume any reachable node may accept writes during partitions.",
        "Apply membership changes in large batches for speed.",
        "Treat heartbeat misses as immediate permanent failure proof.",
        "Enforce leader-epoch checks on all write paths and reject stale-term writes."
      ],
      "correct": 3,
      "explanation": "Consensus safety depends on quorum/term discipline, controlled membership changes, and stale-leader write rejection.",
      "detailedExplanation": "Start from \"service discovery registry is facing split-brain after partition heal\", then pressure-test the result against the options. Prefer the choice that balances hit rate with clear staleness and invalidation behavior. A strong caching answer names staleness limits, invalidation behavior, and keying strategy. Common pitfall: hot-key skew causing uneven load.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cs-003",
      "type": "multiple-choice",
      "question": "A distributed scheduler coordinator is facing slow leader election under packet loss. Which consensus/membership decision is strongest? Ops team needs deterministic reconfiguration runbooks.",
      "options": [
        "Apply membership changes in large batches for speed.",
        "Treat heartbeat misses as immediate permanent failure proof.",
        "Tune election timeout jitter and heartbeat settings to reduce unnecessary elections.",
        "Assume any reachable node may accept writes during partitions."
      ],
      "correct": 2,
      "explanation": "Consensus safety depends on quorum/term discipline, controlled membership changes, and stale-leader write rejection.",
      "detailedExplanation": "The key clue in this question is \"distributed scheduler coordinator is facing slow leader election under packet loss\". Reject options that improve speed but weaken freshness or invalidation correctness. Cache design quality is mostly about correctness boundaries, not only hit rate. Common pitfall: stale data despite high hit rates.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-004",
      "type": "multiple-choice",
      "question": "A multi-region config store is facing unsafe membership reconfiguration. Which consensus/membership decision is strongest? Cluster experiences intermittent packet loss.",
      "options": [
        "Treat heartbeat misses as immediate permanent failure proof.",
        "Separate liveness detection from safety checks; never treat suspicion as proof of failure.",
        "Assume any reachable node may accept writes during partitions.",
        "Apply membership changes in large batches for speed."
      ],
      "correct": 1,
      "explanation": "Consensus safety depends on quorum/term discipline, controlled membership changes, and stale-leader write rejection.",
      "detailedExplanation": "The core signal here is \"multi-region config store is facing unsafe membership reconfiguration\". Discard cache tactics that hide consistency bugs under high load. Cache design quality is mostly about correctness boundaries, not only hit rate. Common pitfall: hot-key skew causing uneven load.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-005",
      "type": "multiple-choice",
      "question": "A consensus-backed lock service is facing log divergence after failover. Which consensus/membership decision is strongest? Scaling events previously increased instability.",
      "options": [
        "Use commit index/majority acknowledgement before externally visible state changes.",
        "Assume any reachable node may accept writes during partitions.",
        "Apply membership changes in large batches for speed.",
        "Treat heartbeat misses as immediate permanent failure proof."
      ],
      "correct": 0,
      "explanation": "Consensus safety depends on quorum/term discipline, controlled membership changes, and stale-leader write rejection.",
      "detailedExplanation": "If you keep \"consensus-backed lock service is facing log divergence after failover\" in view, the correct answer separates faster. Reject choices that sound good generally but do not reduce the concrete reliability risk in this scenario. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-006",
      "type": "multiple-choice",
      "question": "A stream partition leadership service is facing stale leader serving writes. Which consensus/membership decision is strongest? Control-plane changes must be low blast radius.",
      "options": [
        "Assume any reachable node may accept writes during partitions.",
        "Apply membership changes in large batches for speed.",
        "Treat heartbeat misses as immediate permanent failure proof.",
        "Stage membership changes one step at a time with rollback checkpoints."
      ],
      "correct": 3,
      "explanation": "Consensus safety depends on quorum/term discipline, controlled membership changes, and stale-leader write rejection.",
      "detailedExplanation": "This prompt is really about \"stream partition leadership service is facing stale leader serving writes\". Discard cache tactics that hide consistency bugs under high load. Cache design quality is mostly about correctness boundaries, not only hit rate. Common pitfall: invalidation races under concurrent writes.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cs-007",
      "type": "multiple-choice",
      "question": "A state machine replication cluster is facing vote storms from unstable nodes. Which consensus/membership decision is strongest? Client retries amplified stale-leader pressure.",
      "options": [
        "Apply membership changes in large batches for speed.",
        "Treat heartbeat misses as immediate permanent failure proof.",
        "Isolate unstable nodes from voting until health stabilizes to prevent election churn.",
        "Assume any reachable node may accept writes during partitions."
      ],
      "correct": 2,
      "explanation": "Consensus safety depends on quorum/term discipline, controlled membership changes, and stale-leader write rejection.",
      "detailedExplanation": "Use \"state machine replication cluster is facing vote storms from unstable nodes\" as your starting point, then verify tradeoffs carefully. Discard cache tactics that hide consistency bugs under high load. Cache design quality is mostly about correctness boundaries, not only hit rate. Common pitfall: stale data despite high hit rates.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-008",
      "type": "multiple-choice",
      "question": "A orchestration control plane is facing joint-consensus misuse during scaling. Which consensus/membership decision is strongest? SLOs now include election-rate thresholds.",
      "options": [
        "Treat heartbeat misses as immediate permanent failure proof.",
        "Instrument term changes, election rates, and commit-lag SLOs for early instability detection.",
        "Assume any reachable node may accept writes during partitions.",
        "Apply membership changes in large batches for speed."
      ],
      "correct": 1,
      "explanation": "Consensus safety depends on quorum/term discipline, controlled membership changes, and stale-leader write rejection.",
      "detailedExplanation": "Read this as a scenario about \"orchestration control plane is facing joint-consensus misuse during scaling\". Prefer the choice that balances hit rate with clear staleness and invalidation behavior. Cache design quality is mostly about correctness boundaries, not only hit rate. Common pitfall: stale data despite high hit rates.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-009",
      "type": "multiple-choice",
      "question": "A raft-backed KV store is facing follower lag causing commit stalls. Which consensus/membership decision is strongest? Membership updates happen during business hours.",
      "options": [
        "Prefer read-index/lease-read safety checks before serving leader-only consistency paths.",
        "Assume any reachable node may accept writes during partitions.",
        "Apply membership changes in large batches for speed.",
        "Treat heartbeat misses as immediate permanent failure proof."
      ],
      "correct": 0,
      "explanation": "Consensus safety depends on quorum/term discipline, controlled membership changes, and stale-leader write rejection.",
      "detailedExplanation": "The decision turns on \"raft-backed KV store is facing follower lag causing commit stalls\". Discard cache tactics that hide consistency bugs under high load. A strong caching answer names staleness limits, invalidation behavior, and keying strategy. Common pitfall: invalidation races under concurrent writes.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-010",
      "type": "multiple-choice",
      "question": "A membership heartbeat service is facing failure detector false positives. Which consensus/membership decision is strongest? A previous outage involved term confusion.",
      "options": [
        "Assume any reachable node may accept writes during partitions.",
        "Apply membership changes in large batches for speed.",
        "Treat heartbeat misses as immediate permanent failure proof.",
        "Document quorum math and failure-mode behavior for operators before scaling events."
      ],
      "correct": 3,
      "explanation": "Consensus safety depends on quorum/term discipline, controlled membership changes, and stale-leader write rejection.",
      "detailedExplanation": "Use \"membership heartbeat service is facing failure detector false positives\" as your starting point, then verify tradeoffs carefully. Prefer the choice that balances hit rate with clear staleness and invalidation behavior. A strong caching answer names staleness limits, invalidation behavior, and keying strategy. Common pitfall: invalidation races under concurrent writes.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "RFC 6455: The WebSocket Protocol",
          "url": "https://www.rfc-editor.org/rfc/rfc6455"
        }
      ]
    },
    {
      "id": "cc-cs-011",
      "type": "multiple-choice",
      "question": "A clustered feature flag control is facing quorum loss during node failures. Which consensus/membership decision is strongest? Some nodes are noisy and occasionally flapping.",
      "options": [
        "Apply membership changes in large batches for speed.",
        "Treat heartbeat misses as immediate permanent failure proof.",
        "Use quorum intersection-safe reconfiguration (joint consensus style) for membership changes.",
        "Assume any reachable node may accept writes during partitions."
      ],
      "correct": 2,
      "explanation": "Consensus safety depends on quorum/term discipline, controlled membership changes, and stale-leader write rejection.",
      "detailedExplanation": "This prompt is really about \"clustered feature flag control is facing quorum loss during node failures\". Prefer the choice that balances hit rate with clear staleness and invalidation behavior. A strong caching answer names staleness limits, invalidation behavior, and keying strategy. Common pitfall: hot-key skew causing uneven load.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-012",
      "type": "multiple-choice",
      "question": "A routing table authority service is facing split-brain after partition heal. Which consensus/membership decision is strongest? Read paths currently trust cached leadership state.",
      "options": [
        "Treat heartbeat misses as immediate permanent failure proof.",
        "Enforce leader-epoch checks on all write paths and reject stale-term writes.",
        "Assume any reachable node may accept writes during partitions.",
        "Apply membership changes in large batches for speed."
      ],
      "correct": 1,
      "explanation": "Consensus safety depends on quorum/term discipline, controlled membership changes, and stale-leader write rejection.",
      "detailedExplanation": "If you keep \"routing table authority service is facing split-brain after partition heal\" in view, the correct answer separates faster. Reject options that improve speed but weaken freshness or invalidation correctness. Cache design quality is mostly about correctness boundaries, not only hit rate. Common pitfall: hot-key skew causing uneven load.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cs-013",
      "type": "multiple-choice",
      "question": "A tenant quota control cluster is facing slow leader election under packet loss. Which consensus/membership decision is strongest? The team is adding nodes for capacity this quarter.",
      "options": [
        "Tune election timeout jitter and heartbeat settings to reduce unnecessary elections.",
        "Assume any reachable node may accept writes during partitions.",
        "Apply membership changes in large batches for speed.",
        "Treat heartbeat misses as immediate permanent failure proof."
      ],
      "correct": 0,
      "explanation": "Consensus safety depends on quorum/term discipline, controlled membership changes, and stale-leader write rejection.",
      "detailedExplanation": "The core signal here is \"tenant quota control cluster is facing slow leader election under packet loss\". Eliminate designs that create ambiguous API semantics or brittle versioning paths. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ]
    },
    {
      "id": "cc-cs-014",
      "type": "multiple-choice",
      "question": "A job queue assignment coordinator is facing unsafe membership reconfiguration. Which consensus/membership decision is strongest? Recovery behavior needs explicit rollback points.",
      "options": [
        "Assume any reachable node may accept writes during partitions.",
        "Apply membership changes in large batches for speed.",
        "Treat heartbeat misses as immediate permanent failure proof.",
        "Separate liveness detection from safety checks; never treat suspicion as proof of failure."
      ],
      "correct": 3,
      "explanation": "Consensus safety depends on quorum/term discipline, controlled membership changes, and stale-leader write rejection.",
      "detailedExplanation": "The key clue in this question is \"job queue assignment coordinator is facing unsafe membership reconfiguration\". Eliminate answers that do not directly address the failure mode, recovery path, or blast radius. The strongest answer explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cs-015",
      "type": "multiple-choice",
      "question": "A global policy distribution plane is facing log divergence after failover. Which consensus/membership decision is strongest? Cluster size increases quorum arithmetic complexity.",
      "options": [
        "Apply membership changes in large batches for speed.",
        "Treat heartbeat misses as immediate permanent failure proof.",
        "Use commit index/majority acknowledgement before externally visible state changes.",
        "Assume any reachable node may accept writes during partitions."
      ],
      "correct": 2,
      "explanation": "Consensus safety depends on quorum/term discipline, controlled membership changes, and stale-leader write rejection.",
      "detailedExplanation": "Start from \"global policy distribution plane is facing log divergence after failover\", then pressure-test the result against the options. Prioritize the option that best protects the reliability objective under the stated failure conditions. The strongest answer explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: meeting average goals while missing tail-risk.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-016",
      "type": "multiple-choice",
      "question": "A shard map authority store is facing stale leader serving writes. Which consensus/membership decision is strongest? Failure detector sensitivity is under review.",
      "options": [
        "Treat heartbeat misses as immediate permanent failure proof.",
        "Stage membership changes one step at a time with rollback checkpoints.",
        "Assume any reachable node may accept writes during partitions.",
        "Apply membership changes in large batches for speed."
      ],
      "correct": 1,
      "explanation": "Consensus safety depends on quorum/term discipline, controlled membership changes, and stale-leader write rejection.",
      "detailedExplanation": "The decision turns on \"shard map authority store is facing stale leader serving writes\". Discard cache tactics that hide consistency bugs under high load. Treat freshness policy and invalidation paths as first-class constraints. Common pitfall: stale data despite high hit rates.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-017",
      "type": "multiple-choice",
      "question": "A certificate state coordinator is facing vote storms from unstable nodes. Which consensus/membership decision is strongest? Leadership handoff must avoid double-writer windows.",
      "options": [
        "Isolate unstable nodes from voting until health stabilizes to prevent election churn.",
        "Assume any reachable node may accept writes during partitions.",
        "Apply membership changes in large batches for speed.",
        "Treat heartbeat misses as immediate permanent failure proof."
      ],
      "correct": 0,
      "explanation": "Consensus safety depends on quorum/term discipline, controlled membership changes, and stale-leader write rejection.",
      "detailedExplanation": "Read this as a scenario about \"certificate state coordinator is facing vote storms from unstable nodes\". Discard cache tactics that hide consistency bugs under high load. Cache design quality is mostly about correctness boundaries, not only hit rate. Common pitfall: hot-key skew causing uneven load.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-018",
      "type": "multiple-choice",
      "question": "A deployment controller quorum is facing joint-consensus misuse during scaling. Which consensus/membership decision is strongest? Lagging followers are common during spikes.",
      "options": [
        "Assume any reachable node may accept writes during partitions.",
        "Apply membership changes in large batches for speed.",
        "Treat heartbeat misses as immediate permanent failure proof.",
        "Instrument term changes, election rates, and commit-lag SLOs for early instability detection."
      ],
      "correct": 3,
      "explanation": "Consensus safety depends on quorum/term discipline, controlled membership changes, and stale-leader write rejection.",
      "detailedExplanation": "Use \"deployment controller quorum is facing joint-consensus misuse during scaling\" as your starting point, then verify tradeoffs carefully. Prefer the choice that balances hit rate with clear staleness and invalidation behavior. Treat freshness policy and invalidation paths as first-class constraints. Common pitfall: invalidation races under concurrent writes.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-019",
      "type": "multiple-choice",
      "question": "A workflow coordinator cluster is facing follower lag causing commit stalls. Which consensus/membership decision is strongest? Operator tooling currently hides quorum health details.",
      "options": [
        "Apply membership changes in large batches for speed.",
        "Treat heartbeat misses as immediate permanent failure proof.",
        "Prefer read-index/lease-read safety checks before serving leader-only consistency paths.",
        "Assume any reachable node may accept writes during partitions."
      ],
      "correct": 2,
      "explanation": "Consensus safety depends on quorum/term discipline, controlled membership changes, and stale-leader write rejection.",
      "detailedExplanation": "This prompt is really about \"workflow coordinator cluster is facing follower lag causing commit stalls\". Reject options that improve speed but weaken freshness or invalidation correctness. Treat freshness policy and invalidation paths as first-class constraints. Common pitfall: invalidation races under concurrent writes.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-020",
      "type": "multiple-choice",
      "question": "A audit log authority node set is facing failure detector false positives. Which consensus/membership decision is strongest? This is a high-impact shared control service.",
      "options": [
        "Treat heartbeat misses as immediate permanent failure proof.",
        "Document quorum math and failure-mode behavior for operators before scaling events.",
        "Assume any reachable node may accept writes during partitions.",
        "Apply membership changes in large batches for speed."
      ],
      "correct": 1,
      "explanation": "Consensus safety depends on quorum/term discipline, controlled membership changes, and stale-leader write rejection.",
      "detailedExplanation": "Start from \"audit log authority node set is facing failure detector false positives\", then pressure-test the result against the options. Discard cache tactics that hide consistency bugs under high load. Treat freshness policy and invalidation paths as first-class constraints. Common pitfall: hot-key skew causing uneven load.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-021",
      "type": "multiple-choice",
      "question": "A metadata cluster control plane is facing quorum loss during node failures. Which consensus/membership decision is strongest? Consensus incidents now trigger executive review.",
      "options": [
        "Use quorum intersection-safe reconfiguration (joint consensus style) for membership changes.",
        "Assume any reachable node may accept writes during partitions.",
        "Apply membership changes in large batches for speed.",
        "Treat heartbeat misses as immediate permanent failure proof."
      ],
      "correct": 0,
      "explanation": "Consensus safety depends on quorum/term discipline, controlled membership changes, and stale-leader write rejection.",
      "detailedExplanation": "The key clue in this question is \"metadata cluster control plane is facing quorum loss during node failures\". Reject options that improve speed but weaken freshness or invalidation correctness. Cache design quality is mostly about correctness boundaries, not only hit rate. Common pitfall: hot-key skew causing uneven load.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-022",
      "type": "multiple-choice",
      "question": "A service discovery registry is facing split-brain after partition heal. Which consensus/membership decision is strongest? Service availability goals remain strict under faults.",
      "options": [
        "Assume any reachable node may accept writes during partitions.",
        "Apply membership changes in large batches for speed.",
        "Treat heartbeat misses as immediate permanent failure proof.",
        "Enforce leader-epoch checks on all write paths and reject stale-term writes."
      ],
      "correct": 3,
      "explanation": "Consensus safety depends on quorum/term discipline, controlled membership changes, and stale-leader write rejection.",
      "detailedExplanation": "Read this as a scenario about \"service discovery registry is facing split-brain after partition heal\". Prioritize the option that best protects the reliability objective under the stated failure conditions. The strongest answer explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ]
    },
    {
      "id": "cc-cs-023",
      "type": "multiple-choice",
      "question": "A distributed scheduler coordinator is facing slow leader election under packet loss. Which consensus/membership decision is strongest? Deployment cadence must not compromise safety.",
      "options": [
        "Apply membership changes in large batches for speed.",
        "Treat heartbeat misses as immediate permanent failure proof.",
        "Tune election timeout jitter and heartbeat settings to reduce unnecessary elections.",
        "Assume any reachable node may accept writes during partitions."
      ],
      "correct": 2,
      "explanation": "Consensus safety depends on quorum/term discipline, controlled membership changes, and stale-leader write rejection.",
      "detailedExplanation": "The decision turns on \"distributed scheduler coordinator is facing slow leader election under packet loss\". Reject options that improve speed but weaken freshness or invalidation correctness. A strong caching answer names staleness limits, invalidation behavior, and keying strategy. Common pitfall: invalidation races under concurrent writes.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-024",
      "type": "multiple-choice",
      "question": "A multi-region config store is facing unsafe membership reconfiguration. Which consensus/membership decision is strongest? Historical incidents showed unsafe manual interventions.",
      "options": [
        "Treat heartbeat misses as immediate permanent failure proof.",
        "Separate liveness detection from safety checks; never treat suspicion as proof of failure.",
        "Assume any reachable node may accept writes during partitions.",
        "Apply membership changes in large batches for speed."
      ],
      "correct": 1,
      "explanation": "Consensus safety depends on quorum/term discipline, controlled membership changes, and stale-leader write rejection.",
      "detailedExplanation": "This prompt is really about \"multi-region config store is facing unsafe membership reconfiguration\". Reject options that improve speed but weaken freshness or invalidation correctness. Cache design quality is mostly about correctness boundaries, not only hit rate. Common pitfall: stale data despite high hit rates.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-025",
      "type": "multiple-choice",
      "question": "A consensus-backed lock service is facing log divergence after failover. Which consensus/membership decision is strongest? Telemetry for commit lag is now available.",
      "options": [
        "Use commit index/majority acknowledgement before externally visible state changes.",
        "Assume any reachable node may accept writes during partitions.",
        "Apply membership changes in large batches for speed.",
        "Treat heartbeat misses as immediate permanent failure proof."
      ],
      "correct": 0,
      "explanation": "Consensus safety depends on quorum/term discipline, controlled membership changes, and stale-leader write rejection.",
      "detailedExplanation": "Use \"consensus-backed lock service is facing log divergence after failover\" as your starting point, then verify tradeoffs carefully. Reject choices that sound good generally but do not reduce the concrete reliability risk in this scenario. Tie the decision to concrete operational outcomes, not abstract reliability language. Common pitfall: meeting average goals while missing tail-risk.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-026",
      "type": "multiple-choice",
      "question": "A stream partition leadership service is facing stale leader serving writes. Which consensus/membership decision is strongest? New regions add higher RTT variance.",
      "options": [
        "Assume any reachable node may accept writes during partitions.",
        "Apply membership changes in large batches for speed.",
        "Treat heartbeat misses as immediate permanent failure proof.",
        "Stage membership changes one step at a time with rollback checkpoints."
      ],
      "correct": 3,
      "explanation": "Consensus safety depends on quorum/term discipline, controlled membership changes, and stale-leader write rejection.",
      "detailedExplanation": "The core signal here is \"stream partition leadership service is facing stale leader serving writes\". Prefer the choice that balances hit rate with clear staleness and invalidation behavior. Cache design quality is mostly about correctness boundaries, not only hit rate. Common pitfall: stale data despite high hit rates.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cs-027",
      "type": "multiple-choice",
      "question": "A state machine replication cluster is facing vote storms from unstable nodes. Which consensus/membership decision is strongest? Client-facing consistency depends on commit visibility.",
      "options": [
        "Apply membership changes in large batches for speed.",
        "Treat heartbeat misses as immediate permanent failure proof.",
        "Isolate unstable nodes from voting until health stabilizes to prevent election churn.",
        "Assume any reachable node may accept writes during partitions."
      ],
      "correct": 2,
      "explanation": "Consensus safety depends on quorum/term discipline, controlled membership changes, and stale-leader write rejection.",
      "detailedExplanation": "If you keep \"state machine replication cluster is facing vote storms from unstable nodes\" in view, the correct answer separates faster. Discard cache tactics that hide consistency bugs under high load. Cache design quality is mostly about correctness boundaries, not only hit rate. Common pitfall: hot-key skew causing uneven load.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-028",
      "type": "multiple-choice",
      "question": "A orchestration control plane is facing joint-consensus misuse during scaling. Which consensus/membership decision is strongest? Partition events are rare but high consequence.",
      "options": [
        "Treat heartbeat misses as immediate permanent failure proof.",
        "Instrument term changes, election rates, and commit-lag SLOs for early instability detection.",
        "Assume any reachable node may accept writes during partitions.",
        "Apply membership changes in large batches for speed."
      ],
      "correct": 1,
      "explanation": "Consensus safety depends on quorum/term discipline, controlled membership changes, and stale-leader write rejection.",
      "detailedExplanation": "Start from \"orchestration control plane is facing joint-consensus misuse during scaling\", then pressure-test the result against the options. Discard cache tactics that hide consistency bugs under high load. A strong caching answer names staleness limits, invalidation behavior, and keying strategy. Common pitfall: stale data despite high hit rates.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cs-029",
      "type": "multiple-choice",
      "question": "A raft-backed KV store is facing follower lag causing commit stalls. Which consensus/membership decision is strongest? Maintenance windows require predictable node draining.",
      "options": [
        "Prefer read-index/lease-read safety checks before serving leader-only consistency paths.",
        "Assume any reachable node may accept writes during partitions.",
        "Apply membership changes in large batches for speed.",
        "Treat heartbeat misses as immediate permanent failure proof."
      ],
      "correct": 0,
      "explanation": "Consensus safety depends on quorum/term discipline, controlled membership changes, and stale-leader write rejection.",
      "detailedExplanation": "The key clue in this question is \"raft-backed KV store is facing follower lag causing commit stalls\". Prefer the choice that balances hit rate with clear staleness and invalidation behavior. Cache design quality is mostly about correctness boundaries, not only hit rate. Common pitfall: hot-key skew causing uneven load.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-030",
      "type": "multiple-choice",
      "question": "A membership heartbeat service is facing failure detector false positives. Which consensus/membership decision is strongest? Membership churn increased after autoscaling changes.",
      "options": [
        "Assume any reachable node may accept writes during partitions.",
        "Apply membership changes in large batches for speed.",
        "Treat heartbeat misses as immediate permanent failure proof.",
        "Document quorum math and failure-mode behavior for operators before scaling events."
      ],
      "correct": 3,
      "explanation": "Consensus safety depends on quorum/term discipline, controlled membership changes, and stale-leader write rejection.",
      "detailedExplanation": "The decision turns on \"membership heartbeat service is facing failure detector false positives\". Discard cache tactics that hide consistency bugs under high load. A strong caching answer names staleness limits, invalidation behavior, and keying strategy. Common pitfall: invalidation races under concurrent writes.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "RFC 6455: The WebSocket Protocol",
          "url": "https://www.rfc-editor.org/rfc/rfc6455"
        }
      ]
    },
    {
      "id": "cc-cs-031",
      "type": "multiple-choice",
      "question": "A clustered feature flag control is facing quorum loss during node failures. Which consensus/membership decision is strongest? Data correctness is more important than rapid promotion.",
      "options": [
        "Apply membership changes in large batches for speed.",
        "Treat heartbeat misses as immediate permanent failure proof.",
        "Use quorum intersection-safe reconfiguration (joint consensus style) for membership changes.",
        "Assume any reachable node may accept writes during partitions."
      ],
      "correct": 2,
      "explanation": "Consensus safety depends on quorum/term discipline, controlled membership changes, and stale-leader write rejection.",
      "detailedExplanation": "Read this as a scenario about \"clustered feature flag control is facing quorum loss during node failures\". Discard cache tactics that hide consistency bugs under high load. A strong caching answer names staleness limits, invalidation behavior, and keying strategy. Common pitfall: hot-key skew causing uneven load.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-032",
      "type": "multiple-choice",
      "question": "A routing table authority service is facing split-brain after partition heal. Which consensus/membership decision is strongest? The team needs safer defaults for emergency actions.",
      "options": [
        "Treat heartbeat misses as immediate permanent failure proof.",
        "Enforce leader-epoch checks on all write paths and reject stale-term writes.",
        "Assume any reachable node may accept writes during partitions.",
        "Apply membership changes in large batches for speed."
      ],
      "correct": 1,
      "explanation": "Consensus safety depends on quorum/term discipline, controlled membership changes, and stale-leader write rejection.",
      "detailedExplanation": "The key clue in this question is \"routing table authority service is facing split-brain after partition heal\". Reject options that improve speed but weaken freshness or invalidation correctness. A strong caching answer names staleness limits, invalidation behavior, and keying strategy. Common pitfall: hot-key skew causing uneven load.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cs-033",
      "type": "multiple-choice",
      "question": "A tenant quota control cluster is facing slow leader election under packet loss. Which consensus/membership decision is strongest? Election storms caused cascading control failures.",
      "options": [
        "Tune election timeout jitter and heartbeat settings to reduce unnecessary elections.",
        "Assume any reachable node may accept writes during partitions.",
        "Apply membership changes in large batches for speed.",
        "Treat heartbeat misses as immediate permanent failure proof."
      ],
      "correct": 0,
      "explanation": "Consensus safety depends on quorum/term discipline, controlled membership changes, and stale-leader write rejection.",
      "detailedExplanation": "Start from \"tenant quota control cluster is facing slow leader election under packet loss\", then pressure-test the result against the options. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-034",
      "type": "multiple-choice",
      "question": "A job queue assignment coordinator is facing unsafe membership reconfiguration. Which consensus/membership decision is strongest? Operator confidence depends on transparent quorum state.",
      "options": [
        "Assume any reachable node may accept writes during partitions.",
        "Apply membership changes in large batches for speed.",
        "Treat heartbeat misses as immediate permanent failure proof.",
        "Separate liveness detection from safety checks; never treat suspicion as proof of failure."
      ],
      "correct": 3,
      "explanation": "Consensus safety depends on quorum/term discipline, controlled membership changes, and stale-leader write rejection.",
      "detailedExplanation": "If you keep \"job queue assignment coordinator is facing unsafe membership reconfiguration\" in view, the correct answer separates faster. Discard cache tactics that hide consistency bugs under high load. Treat freshness policy and invalidation paths as first-class constraints. Common pitfall: hot-key skew causing uneven load.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cs-035",
      "type": "multiple-choice",
      "question": "A global policy distribution plane is facing log divergence after failover. Which consensus/membership decision is strongest? Post-incident hardening is part of this milestone.",
      "options": [
        "Apply membership changes in large batches for speed.",
        "Treat heartbeat misses as immediate permanent failure proof.",
        "Use commit index/majority acknowledgement before externally visible state changes.",
        "Assume any reachable node may accept writes during partitions."
      ],
      "correct": 2,
      "explanation": "Consensus safety depends on quorum/term discipline, controlled membership changes, and stale-leader write rejection.",
      "detailedExplanation": "The core signal here is \"global policy distribution plane is facing log divergence after failover\". Reject choices that sound good generally but do not reduce the concrete reliability risk in this scenario. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: meeting average goals while missing tail-risk.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "cc-cs-036",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: distributed scheduler coordinator reports log divergence after failover. What is the primary diagnosis?",
          "options": [
            "The current consensus behavior in distributed scheduler coordinator mismatches log divergence after failover, creating safety/liveness risk.",
            "Any elected leader can safely commit without majority acknowledgement.",
            "Membership updates are independent of quorum safety constraints.",
            "Old leaders may continue writes if clients still route to them."
          ],
          "correct": 0,
          "explanation": "The failure mode indicates weakened quorum/term or membership discipline.",
          "detailedExplanation": "The decision turns on \"scenario: distributed scheduler coordinator reports log divergence after failover\". Solve this as chained reasoning where stage two must respect stage one assumptions. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: retry storms during partial failure."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while preserving quorum safety?",
          "options": [
            "Force fixed election timeout with zero jitter across all nodes.",
            "Disable quorum checks to improve failover speed.",
            "Allow manual term overrides in production emergencies by default.",
            "Separate liveness detection from safety checks; never treat suspicion as proof of failure."
          ],
          "correct": 3,
          "explanation": "Apply safety-preserving coordination changes first, then optimize liveness/performance.",
          "detailedExplanation": "Start from \"after confirming diagnosis, what is the strongest next change while preserving quorum\", then pressure-test the result against the options. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "Use \"consensus & Membership\" as your starting point, then verify tradeoffs carefully. Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-037",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: multi-region config store reports stale leader serving writes. What is the primary diagnosis?",
          "options": [
            "Any elected leader can safely commit without majority acknowledgement.",
            "Membership updates are independent of quorum safety constraints.",
            "Old leaders may continue writes if clients still route to them.",
            "The current consensus behavior in multi-region config store mismatches stale leader serving writes, creating safety/liveness risk."
          ],
          "correct": 3,
          "explanation": "The failure mode indicates weakened quorum/term or membership discipline.",
          "detailedExplanation": "Start from \"scenario: multi-region config store reports stale leader serving writes\", then pressure-test the result against the options. Do not reset assumptions between stages; carry forward prior constraints directly. Cache design quality is mostly about correctness boundaries, not only hit rate. Common pitfall: invalidation races under concurrent writes."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change during partition recovery?",
          "options": [
            "Disable quorum checks to improve failover speed.",
            "Allow manual term overrides in production emergencies by default.",
            "Use commit index/majority acknowledgement before externally visible state changes.",
            "Force fixed election timeout with zero jitter across all nodes."
          ],
          "correct": 2,
          "explanation": "Apply safety-preserving coordination changes first, then optimize liveness/performance.",
          "detailedExplanation": "The decision turns on \"after confirming diagnosis, what is the strongest next change during partition recovery\". Do not reset assumptions between stages; carry forward prior constraints directly. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: meeting average goals while missing tail-risk."
        }
      ],
      "detailedExplanation": "This prompt is really about \"consensus & Membership\". Solve this as chained reasoning where stage two must respect stage one assumptions. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-038",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: consensus-backed lock service reports vote storms from unstable nodes. What is the primary diagnosis?",
          "options": [
            "Membership updates are independent of quorum safety constraints.",
            "Old leaders may continue writes if clients still route to them.",
            "The current consensus behavior in consensus-backed lock service mismatches vote storms from unstable nodes, creating safety/liveness risk.",
            "Any elected leader can safely commit without majority acknowledgement."
          ],
          "correct": 2,
          "explanation": "The failure mode indicates weakened quorum/term or membership discipline.",
          "detailedExplanation": "Use \"scenario: consensus-backed lock service reports vote storms from unstable nodes\" as your starting point, then verify tradeoffs carefully. Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under high RTT variance?",
          "options": [
            "Allow manual term overrides in production emergencies by default.",
            "Stage membership changes one step at a time with rollback checkpoints.",
            "Force fixed election timeout with zero jitter across all nodes.",
            "Disable quorum checks to improve failover speed."
          ],
          "correct": 1,
          "explanation": "Apply safety-preserving coordination changes first, then optimize liveness/performance.",
          "detailedExplanation": "The core signal here is \"after confirming diagnosis, what is the strongest next change under high RTT variance\". Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "The decision turns on \"consensus & Membership\". Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-039",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: stream partition leadership service reports joint-consensus misuse during scaling. What is the primary diagnosis?",
          "options": [
            "Old leaders may continue writes if clients still route to them.",
            "The current consensus behavior in stream partition leadership service mismatches joint-consensus misuse during scaling, creating safety/liveness risk.",
            "Any elected leader can safely commit without majority acknowledgement.",
            "Membership updates are independent of quorum safety constraints."
          ],
          "correct": 1,
          "explanation": "The failure mode indicates weakened quorum/term or membership discipline.",
          "detailedExplanation": "Read this as a scenario about \"scenario: stream partition leadership service reports joint-consensus misuse during\". Solve this as chained reasoning where stage two must respect stage one assumptions. Throughput is only one part; replay behavior and consumer lag handling matter equally. Common pitfall: ordering loss during partition or replay changes."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with minimal election churn?",
          "options": [
            "Isolate unstable nodes from voting until health stabilizes to prevent election churn.",
            "Force fixed election timeout with zero jitter across all nodes.",
            "Disable quorum checks to improve failover speed.",
            "Allow manual term overrides in production emergencies by default."
          ],
          "correct": 0,
          "explanation": "Apply safety-preserving coordination changes first, then optimize liveness/performance.",
          "detailedExplanation": "The key clue in this question is \"after confirming diagnosis, what is the strongest next change with minimal election\". Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "Read this as a scenario about \"consensus & Membership\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-040",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: state machine replication cluster reports follower lag causing commit stalls. What is the primary diagnosis?",
          "options": [
            "The current consensus behavior in state machine replication cluster mismatches follower lag causing commit stalls, creating safety/liveness risk.",
            "Any elected leader can safely commit without majority acknowledgement.",
            "Membership updates are independent of quorum safety constraints.",
            "Old leaders may continue writes if clients still route to them."
          ],
          "correct": 0,
          "explanation": "The failure mode indicates weakened quorum/term or membership discipline.",
          "detailedExplanation": "The core signal here is \"scenario: state machine replication cluster reports follower lag causing commit stalls\". Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while preventing stale-leader writes?",
          "options": [
            "Force fixed election timeout with zero jitter across all nodes.",
            "Disable quorum checks to improve failover speed.",
            "Allow manual term overrides in production emergencies by default.",
            "Instrument term changes, election rates, and commit-lag SLOs for early instability detection."
          ],
          "correct": 3,
          "explanation": "Apply safety-preserving coordination changes first, then optimize liveness/performance.",
          "detailedExplanation": "Use \"after confirming diagnosis, what is the strongest next change while preventing\" as your starting point, then verify tradeoffs carefully. Do not reset assumptions between stages; carry forward prior constraints directly. A strong caching answer names staleness limits, invalidation behavior, and keying strategy. Common pitfall: invalidation races under concurrent writes."
        }
      ],
      "detailedExplanation": "The core signal here is \"consensus & Membership\". Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-041",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: orchestration control plane reports failure detector false positives. What is the primary diagnosis?",
          "options": [
            "Any elected leader can safely commit without majority acknowledgement.",
            "Membership updates are independent of quorum safety constraints.",
            "Old leaders may continue writes if clients still route to them.",
            "The current consensus behavior in orchestration control plane mismatches failure detector false positives, creating safety/liveness risk."
          ],
          "correct": 3,
          "explanation": "The failure mode indicates weakened quorum/term or membership discipline.",
          "detailedExplanation": "The key clue in this question is \"scenario: orchestration control plane reports failure detector false positives\". Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change during rolling node replacement?",
          "options": [
            "Disable quorum checks to improve failover speed.",
            "Allow manual term overrides in production emergencies by default.",
            "Prefer read-index/lease-read safety checks before serving leader-only consistency paths.",
            "Force fixed election timeout with zero jitter across all nodes."
          ],
          "correct": 2,
          "explanation": "Apply safety-preserving coordination changes first, then optimize liveness/performance.",
          "detailedExplanation": "Read this as a scenario about \"after confirming diagnosis, what is the strongest next change during rolling node\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "If you keep \"consensus & Membership\" in view, the correct answer separates faster. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-042",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: raft-backed KV store reports quorum loss during node failures. What is the primary diagnosis?",
          "options": [
            "Membership updates are independent of quorum safety constraints.",
            "Old leaders may continue writes if clients still route to them.",
            "The current consensus behavior in raft-backed KV store mismatches quorum loss during node failures, creating safety/liveness risk.",
            "Any elected leader can safely commit without majority acknowledgement."
          ],
          "correct": 2,
          "explanation": "The failure mode indicates weakened quorum/term or membership discipline.",
          "detailedExplanation": "Start from \"scenario: raft-backed KV store reports quorum loss during node failures\", then pressure-test the result against the options. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under follower lag pressure?",
          "options": [
            "Allow manual term overrides in production emergencies by default.",
            "Document quorum math and failure-mode behavior for operators before scaling events.",
            "Force fixed election timeout with zero jitter across all nodes.",
            "Disable quorum checks to improve failover speed."
          ],
          "correct": 1,
          "explanation": "Apply safety-preserving coordination changes first, then optimize liveness/performance.",
          "detailedExplanation": "The decision turns on \"after confirming diagnosis, what is the strongest next change under follower lag\". Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "This prompt is really about \"consensus & Membership\". Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-043",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: membership heartbeat service reports split-brain after partition heal. What is the primary diagnosis?",
          "options": [
            "Old leaders may continue writes if clients still route to them.",
            "The current consensus behavior in membership heartbeat service mismatches split-brain after partition heal, creating safety/liveness risk.",
            "Any elected leader can safely commit without majority acknowledgement.",
            "Membership updates are independent of quorum safety constraints."
          ],
          "correct": 1,
          "explanation": "The failure mode indicates weakened quorum/term or membership discipline.",
          "detailedExplanation": "The decision turns on \"scenario: membership heartbeat service reports split-brain after partition heal\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. A good message-system answer defines guarantees clearly for both producer and consumer paths. Common pitfall: assuming exactly-once without idempotency."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change before scale-out events?",
          "options": [
            "Use quorum intersection-safe reconfiguration (joint consensus style) for membership changes.",
            "Force fixed election timeout with zero jitter across all nodes.",
            "Disable quorum checks to improve failover speed.",
            "Allow manual term overrides in production emergencies by default."
          ],
          "correct": 0,
          "explanation": "Apply safety-preserving coordination changes first, then optimize liveness/performance.",
          "detailedExplanation": "Start from \"after confirming diagnosis, what is the strongest next change before scale-out events\", then pressure-test the result against the options. Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "Use \"consensus & Membership\" as your starting point, then verify tradeoffs carefully. Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-044",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: clustered feature flag control reports slow leader election under packet loss. What is the primary diagnosis?",
          "options": [
            "The current consensus behavior in clustered feature flag control mismatches slow leader election under packet loss, creating safety/liveness risk.",
            "Any elected leader can safely commit without majority acknowledgement.",
            "Membership updates are independent of quorum safety constraints.",
            "Old leaders may continue writes if clients still route to them."
          ],
          "correct": 0,
          "explanation": "The failure mode indicates weakened quorum/term or membership discipline.",
          "detailedExplanation": "Read this as a scenario about \"scenario: clustered feature flag control reports slow leader election under packet loss\". Solve this as chained reasoning where stage two must respect stage one assumptions. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with strict correctness guarantees?",
          "options": [
            "Force fixed election timeout with zero jitter across all nodes.",
            "Disable quorum checks to improve failover speed.",
            "Allow manual term overrides in production emergencies by default.",
            "Enforce leader-epoch checks on all write paths and reject stale-term writes."
          ],
          "correct": 3,
          "explanation": "Apply safety-preserving coordination changes first, then optimize liveness/performance.",
          "detailedExplanation": "The key clue in this question is \"after confirming diagnosis, what is the strongest next change with strict correctness\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "Read this as a scenario about \"consensus & Membership\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-045",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: routing table authority service reports unsafe membership reconfiguration. What is the primary diagnosis?",
          "options": [
            "Any elected leader can safely commit without majority acknowledgement.",
            "Membership updates are independent of quorum safety constraints.",
            "Old leaders may continue writes if clients still route to them.",
            "The current consensus behavior in routing table authority service mismatches unsafe membership reconfiguration, creating safety/liveness risk."
          ],
          "correct": 3,
          "explanation": "The failure mode indicates weakened quorum/term or membership discipline.",
          "detailedExplanation": "Use \"scenario: routing table authority service reports unsafe membership reconfiguration\" as your starting point, then verify tradeoffs carefully. Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change during incident containment?",
          "options": [
            "Disable quorum checks to improve failover speed.",
            "Allow manual term overrides in production emergencies by default.",
            "Tune election timeout jitter and heartbeat settings to reduce unnecessary elections.",
            "Force fixed election timeout with zero jitter across all nodes."
          ],
          "correct": 2,
          "explanation": "Apply safety-preserving coordination changes first, then optimize liveness/performance.",
          "detailedExplanation": "The core signal here is \"after confirming diagnosis, what is the strongest next change during incident\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Tie the decision to concrete operational outcomes, not abstract reliability language. Common pitfall: retry storms during partial failure."
        }
      ],
      "detailedExplanation": "The decision turns on \"consensus & Membership\". Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-046",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: tenant quota control cluster reports log divergence after failover. What is the primary diagnosis?",
          "options": [
            "Membership updates are independent of quorum safety constraints.",
            "Old leaders may continue writes if clients still route to them.",
            "The current consensus behavior in tenant quota control cluster mismatches log divergence after failover, creating safety/liveness risk.",
            "Any elected leader can safely commit without majority acknowledgement."
          ],
          "correct": 2,
          "explanation": "The failure mode indicates weakened quorum/term or membership discipline.",
          "detailedExplanation": "This prompt is really about \"scenario: tenant quota control cluster reports log divergence after failover\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: retry storms during partial failure."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with limited operator bandwidth?",
          "options": [
            "Allow manual term overrides in production emergencies by default.",
            "Separate liveness detection from safety checks; never treat suspicion as proof of failure.",
            "Force fixed election timeout with zero jitter across all nodes.",
            "Disable quorum checks to improve failover speed."
          ],
          "correct": 1,
          "explanation": "Apply safety-preserving coordination changes first, then optimize liveness/performance.",
          "detailedExplanation": "If you keep \"after confirming diagnosis, what is the strongest next change with limited operator\" in view, the correct answer separates faster. Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "Start from \"consensus & Membership\", then pressure-test the result against the options. Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-047",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: job queue assignment coordinator reports stale leader serving writes. What is the primary diagnosis?",
          "options": [
            "Old leaders may continue writes if clients still route to them.",
            "The current consensus behavior in job queue assignment coordinator mismatches stale leader serving writes, creating safety/liveness risk.",
            "Any elected leader can safely commit without majority acknowledgement.",
            "Membership updates are independent of quorum safety constraints."
          ],
          "correct": 1,
          "explanation": "The failure mode indicates weakened quorum/term or membership discipline.",
          "detailedExplanation": "If you keep \"scenario: job queue assignment coordinator reports stale leader serving writes\" in view, the correct answer separates faster. Do not reset assumptions between stages; carry forward prior constraints directly. Treat freshness policy and invalidation paths as first-class constraints. Common pitfall: stale data despite high hit rates."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under maintenance windows?",
          "options": [
            "Use commit index/majority acknowledgement before externally visible state changes.",
            "Force fixed election timeout with zero jitter across all nodes.",
            "Disable quorum checks to improve failover speed.",
            "Allow manual term overrides in production emergencies by default."
          ],
          "correct": 0,
          "explanation": "Apply safety-preserving coordination changes first, then optimize liveness/performance.",
          "detailedExplanation": "This prompt is really about \"after confirming diagnosis, what is the strongest next change under maintenance windows\". Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "The key clue in this question is \"consensus & Membership\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-048",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: global policy distribution plane reports vote storms from unstable nodes. What is the primary diagnosis?",
          "options": [
            "The current consensus behavior in global policy distribution plane mismatches vote storms from unstable nodes, creating safety/liveness risk.",
            "Any elected leader can safely commit without majority acknowledgement.",
            "Membership updates are independent of quorum safety constraints.",
            "Old leaders may continue writes if clients still route to them."
          ],
          "correct": 0,
          "explanation": "The failure mode indicates weakened quorum/term or membership discipline.",
          "detailedExplanation": "The core signal here is \"scenario: global policy distribution plane reports vote storms from unstable nodes\". Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while preserving commit throughput?",
          "options": [
            "Force fixed election timeout with zero jitter across all nodes.",
            "Disable quorum checks to improve failover speed.",
            "Allow manual term overrides in production emergencies by default.",
            "Stage membership changes one step at a time with rollback checkpoints."
          ],
          "correct": 3,
          "explanation": "Apply safety-preserving coordination changes first, then optimize liveness/performance.",
          "detailedExplanation": "Use \"after confirming diagnosis, what is the strongest next change while preserving commit\" as your starting point, then verify tradeoffs carefully. Solve this as chained reasoning where stage two must respect stage one assumptions. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "The core signal here is \"consensus & Membership\". Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-049",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: shard map authority store reports joint-consensus misuse during scaling. What is the primary diagnosis?",
          "options": [
            "Any elected leader can safely commit without majority acknowledgement.",
            "Membership updates are independent of quorum safety constraints.",
            "Old leaders may continue writes if clients still route to them.",
            "The current consensus behavior in shard map authority store mismatches joint-consensus misuse during scaling, creating safety/liveness risk."
          ],
          "correct": 3,
          "explanation": "The failure mode indicates weakened quorum/term or membership discipline.",
          "detailedExplanation": "The key clue in this question is \"scenario: shard map authority store reports joint-consensus misuse during scaling\". Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with explicit rollback criteria?",
          "options": [
            "Disable quorum checks to improve failover speed.",
            "Allow manual term overrides in production emergencies by default.",
            "Isolate unstable nodes from voting until health stabilizes to prevent election churn.",
            "Force fixed election timeout with zero jitter across all nodes."
          ],
          "correct": 2,
          "explanation": "Apply safety-preserving coordination changes first, then optimize liveness/performance.",
          "detailedExplanation": "Read this as a scenario about \"after confirming diagnosis, what is the strongest next change with explicit rollback\". Solve this as chained reasoning where stage two must respect stage one assumptions. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "If you keep \"consensus & Membership\" in view, the correct answer separates faster. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-050",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: certificate state coordinator reports follower lag causing commit stalls. What is the primary diagnosis?",
          "options": [
            "Membership updates are independent of quorum safety constraints.",
            "Old leaders may continue writes if clients still route to them.",
            "The current consensus behavior in certificate state coordinator mismatches follower lag causing commit stalls, creating safety/liveness risk.",
            "Any elected leader can safely commit without majority acknowledgement."
          ],
          "correct": 2,
          "explanation": "The failure mode indicates weakened quorum/term or membership discipline.",
          "detailedExplanation": "If you keep \"scenario: certificate state coordinator reports follower lag causing commit stalls\" in view, the correct answer separates faster. Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change during control-plane upgrades?",
          "options": [
            "Allow manual term overrides in production emergencies by default.",
            "Instrument term changes, election rates, and commit-lag SLOs for early instability detection.",
            "Force fixed election timeout with zero jitter across all nodes.",
            "Disable quorum checks to improve failover speed."
          ],
          "correct": 1,
          "explanation": "Apply safety-preserving coordination changes first, then optimize liveness/performance.",
          "detailedExplanation": "This prompt is really about \"after confirming diagnosis, what is the strongest next change during control-plane\". Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "The key clue in this question is \"consensus & Membership\". Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-051",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: deployment controller quorum reports failure detector false positives. What is the primary diagnosis?",
          "options": [
            "Old leaders may continue writes if clients still route to them.",
            "The current consensus behavior in deployment controller quorum mismatches failure detector false positives, creating safety/liveness risk.",
            "Any elected leader can safely commit without majority acknowledgement.",
            "Membership updates are independent of quorum safety constraints."
          ],
          "correct": 1,
          "explanation": "The failure mode indicates weakened quorum/term or membership discipline.",
          "detailedExplanation": "This prompt is really about \"scenario: deployment controller quorum reports failure detector false positives\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under degraded heartbeat reliability?",
          "options": [
            "Prefer read-index/lease-read safety checks before serving leader-only consistency paths.",
            "Force fixed election timeout with zero jitter across all nodes.",
            "Disable quorum checks to improve failover speed.",
            "Allow manual term overrides in production emergencies by default."
          ],
          "correct": 0,
          "explanation": "Apply safety-preserving coordination changes first, then optimize liveness/performance.",
          "detailedExplanation": "If you keep \"after confirming diagnosis, what is the strongest next change under degraded heartbeat\" in view, the correct answer separates faster. Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "Start from \"consensus & Membership\", then pressure-test the result against the options. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-052",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: workflow coordinator cluster reports quorum loss during node failures. What is the primary diagnosis?",
          "options": [
            "The current consensus behavior in workflow coordinator cluster mismatches quorum loss during node failures, creating safety/liveness risk.",
            "Any elected leader can safely commit without majority acknowledgement.",
            "Membership updates are independent of quorum safety constraints.",
            "Old leaders may continue writes if clients still route to them."
          ],
          "correct": 0,
          "explanation": "The failure mode indicates weakened quorum/term or membership discipline.",
          "detailedExplanation": "Use \"scenario: workflow coordinator cluster reports quorum loss during node failures\" as your starting point, then verify tradeoffs carefully. Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while keeping read safety?",
          "options": [
            "Force fixed election timeout with zero jitter across all nodes.",
            "Disable quorum checks to improve failover speed.",
            "Allow manual term overrides in production emergencies by default.",
            "Document quorum math and failure-mode behavior for operators before scaling events."
          ],
          "correct": 3,
          "explanation": "Apply safety-preserving coordination changes first, then optimize liveness/performance.",
          "detailedExplanation": "The core signal here is \"after confirming diagnosis, what is the strongest next change while keeping read safety\". Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "The decision turns on \"consensus & Membership\". Solve this as chained reasoning where stage two must respect stage one assumptions. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-053",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: audit log authority node set reports split-brain after partition heal. What is the primary diagnosis?",
          "options": [
            "Any elected leader can safely commit without majority acknowledgement.",
            "Membership updates are independent of quorum safety constraints.",
            "Old leaders may continue writes if clients still route to them.",
            "The current consensus behavior in audit log authority node set mismatches split-brain after partition heal, creating safety/liveness risk."
          ],
          "correct": 3,
          "explanation": "The failure mode indicates weakened quorum/term or membership discipline.",
          "detailedExplanation": "Read this as a scenario about \"scenario: audit log authority node set reports split-brain after partition heal\". Solve this as chained reasoning where stage two must respect stage one assumptions. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. Common pitfall: consumer lag growth under burst traffic."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change before broader multi-region rollout?",
          "options": [
            "Disable quorum checks to improve failover speed.",
            "Allow manual term overrides in production emergencies by default.",
            "Use quorum intersection-safe reconfiguration (joint consensus style) for membership changes.",
            "Force fixed election timeout with zero jitter across all nodes."
          ],
          "correct": 2,
          "explanation": "Apply safety-preserving coordination changes first, then optimize liveness/performance.",
          "detailedExplanation": "The key clue in this question is \"after confirming diagnosis, what is the strongest next change before broader\". Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "Read this as a scenario about \"consensus & Membership\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-054",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: metadata cluster control plane reports slow leader election under packet loss. What is the primary diagnosis?",
          "options": [
            "Membership updates are independent of quorum safety constraints.",
            "Old leaders may continue writes if clients still route to them.",
            "The current consensus behavior in metadata cluster control plane mismatches slow leader election under packet loss, creating safety/liveness risk.",
            "Any elected leader can safely commit without majority acknowledgement."
          ],
          "correct": 2,
          "explanation": "The failure mode indicates weakened quorum/term or membership discipline.",
          "detailedExplanation": "The decision turns on \"scenario: metadata cluster control plane reports slow leader election under packet loss\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under frequent client retries?",
          "options": [
            "Allow manual term overrides in production emergencies by default.",
            "Enforce leader-epoch checks on all write paths and reject stale-term writes.",
            "Force fixed election timeout with zero jitter across all nodes.",
            "Disable quorum checks to improve failover speed."
          ],
          "correct": 1,
          "explanation": "Apply safety-preserving coordination changes first, then optimize liveness/performance.",
          "detailedExplanation": "Start from \"after confirming diagnosis, what is the strongest next change under frequent client\", then pressure-test the result against the options. Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "Use \"consensus & Membership\" as your starting point, then verify tradeoffs carefully. Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-055",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: service discovery registry reports unsafe membership reconfiguration. What is the primary diagnosis?",
          "options": [
            "Old leaders may continue writes if clients still route to them.",
            "The current consensus behavior in service discovery registry mismatches unsafe membership reconfiguration, creating safety/liveness risk.",
            "Any elected leader can safely commit without majority acknowledgement.",
            "Membership updates are independent of quorum safety constraints."
          ],
          "correct": 1,
          "explanation": "The failure mode indicates weakened quorum/term or membership discipline.",
          "detailedExplanation": "Start from \"scenario: service discovery registry reports unsafe membership reconfiguration\", then pressure-test the result against the options. Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with transparent operator observability?",
          "options": [
            "Tune election timeout jitter and heartbeat settings to reduce unnecessary elections.",
            "Force fixed election timeout with zero jitter across all nodes.",
            "Disable quorum checks to improve failover speed.",
            "Allow manual term overrides in production emergencies by default."
          ],
          "correct": 0,
          "explanation": "Apply safety-preserving coordination changes first, then optimize liveness/performance.",
          "detailedExplanation": "The decision turns on \"after confirming diagnosis, what is the strongest next change with transparent operator\". Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "This prompt is really about \"consensus & Membership\". Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-056",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: distributed scheduler coordinator reports log divergence after failover. What is the primary diagnosis?",
          "options": [
            "The current consensus behavior in distributed scheduler coordinator mismatches log divergence after failover, creating safety/liveness risk.",
            "Any elected leader can safely commit without majority acknowledgement.",
            "Membership updates are independent of quorum safety constraints.",
            "Old leaders may continue writes if clients still route to them."
          ],
          "correct": 0,
          "explanation": "The failure mode indicates weakened quorum/term or membership discipline.",
          "detailedExplanation": "The key clue in this question is \"scenario: distributed scheduler coordinator reports log divergence after failover\". Solve this as chained reasoning where stage two must respect stage one assumptions. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: meeting average goals while missing tail-risk."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change during membership churn?",
          "options": [
            "Force fixed election timeout with zero jitter across all nodes.",
            "Disable quorum checks to improve failover speed.",
            "Allow manual term overrides in production emergencies by default.",
            "Separate liveness detection from safety checks; never treat suspicion as proof of failure."
          ],
          "correct": 3,
          "explanation": "Apply safety-preserving coordination changes first, then optimize liveness/performance.",
          "detailedExplanation": "Read this as a scenario about \"after confirming diagnosis, what is the strongest next change during membership churn\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "If you keep \"consensus & Membership\" in view, the correct answer separates faster. Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-057",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: multi-region config store reports stale leader serving writes. What is the primary diagnosis?",
          "options": [
            "Any elected leader can safely commit without majority acknowledgement.",
            "Membership updates are independent of quorum safety constraints.",
            "Old leaders may continue writes if clients still route to them.",
            "The current consensus behavior in multi-region config store mismatches stale leader serving writes, creating safety/liveness risk."
          ],
          "correct": 3,
          "explanation": "The failure mode indicates weakened quorum/term or membership discipline.",
          "detailedExplanation": "The core signal here is \"scenario: multi-region config store reports stale leader serving writes\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. A strong caching answer names staleness limits, invalidation behavior, and keying strategy. Common pitfall: hot-key skew causing uneven load."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while minimizing split-brain risk?",
          "options": [
            "Disable quorum checks to improve failover speed.",
            "Allow manual term overrides in production emergencies by default.",
            "Use commit index/majority acknowledgement before externally visible state changes.",
            "Force fixed election timeout with zero jitter across all nodes."
          ],
          "correct": 2,
          "explanation": "Apply safety-preserving coordination changes first, then optimize liveness/performance.",
          "detailedExplanation": "Use \"after confirming diagnosis, what is the strongest next change while minimizing\" as your starting point, then verify tradeoffs carefully. Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "The core signal here is \"consensus & Membership\". Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-058",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: consensus-backed lock service reports vote storms from unstable nodes. What is the primary diagnosis?",
          "options": [
            "Membership updates are independent of quorum safety constraints.",
            "Old leaders may continue writes if clients still route to them.",
            "The current consensus behavior in consensus-backed lock service mismatches vote storms from unstable nodes, creating safety/liveness risk.",
            "Any elected leader can safely commit without majority acknowledgement."
          ],
          "correct": 2,
          "explanation": "The failure mode indicates weakened quorum/term or membership discipline.",
          "detailedExplanation": "If you keep \"scenario: consensus-backed lock service reports vote storms from unstable nodes\" in view, the correct answer separates faster. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under mixed node health conditions?",
          "options": [
            "Allow manual term overrides in production emergencies by default.",
            "Stage membership changes one step at a time with rollback checkpoints.",
            "Force fixed election timeout with zero jitter across all nodes.",
            "Disable quorum checks to improve failover speed."
          ],
          "correct": 1,
          "explanation": "Apply safety-preserving coordination changes first, then optimize liveness/performance.",
          "detailedExplanation": "This prompt is really about \"after confirming diagnosis, what is the strongest next change under mixed node health\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "The key clue in this question is \"consensus & Membership\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-059",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: stream partition leadership service reports joint-consensus misuse during scaling. What is the primary diagnosis?",
          "options": [
            "Old leaders may continue writes if clients still route to them.",
            "The current consensus behavior in stream partition leadership service mismatches joint-consensus misuse during scaling, creating safety/liveness risk.",
            "Any elected leader can safely commit without majority acknowledgement.",
            "Membership updates are independent of quorum safety constraints."
          ],
          "correct": 1,
          "explanation": "The failure mode indicates weakened quorum/term or membership discipline.",
          "detailedExplanation": "This prompt is really about \"scenario: stream partition leadership service reports joint-consensus misuse during\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Throughput is only one part; replay behavior and consumer lag handling matter equally. Common pitfall: assuming exactly-once without idempotency."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with deterministic failover behavior?",
          "options": [
            "Isolate unstable nodes from voting until health stabilizes to prevent election churn.",
            "Force fixed election timeout with zero jitter across all nodes.",
            "Disable quorum checks to improve failover speed.",
            "Allow manual term overrides in production emergencies by default."
          ],
          "correct": 0,
          "explanation": "Apply safety-preserving coordination changes first, then optimize liveness/performance.",
          "detailedExplanation": "If you keep \"after confirming diagnosis, what is the strongest next change with deterministic\" in view, the correct answer separates faster. Solve this as chained reasoning where stage two must respect stage one assumptions. The strongest answer explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: assuming recovery speed without operational proof."
        }
      ],
      "detailedExplanation": "Start from \"consensus & Membership\", then pressure-test the result against the options. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-060",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: state machine replication cluster reports follower lag causing commit stalls. What is the primary diagnosis?",
          "options": [
            "The current consensus behavior in state machine replication cluster mismatches follower lag causing commit stalls, creating safety/liveness risk.",
            "Any elected leader can safely commit without majority acknowledgement.",
            "Membership updates are independent of quorum safety constraints.",
            "Old leaders may continue writes if clients still route to them."
          ],
          "correct": 0,
          "explanation": "The failure mode indicates weakened quorum/term or membership discipline.",
          "detailedExplanation": "Start from \"scenario: state machine replication cluster reports follower lag causing commit stalls\", then pressure-test the result against the options. Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while protecting commit integrity?",
          "options": [
            "Force fixed election timeout with zero jitter across all nodes.",
            "Disable quorum checks to improve failover speed.",
            "Allow manual term overrides in production emergencies by default.",
            "Instrument term changes, election rates, and commit-lag SLOs for early instability detection."
          ],
          "correct": 3,
          "explanation": "Apply safety-preserving coordination changes first, then optimize liveness/performance.",
          "detailedExplanation": "The decision turns on \"after confirming diagnosis, what is the strongest next change while protecting commit\". Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "This prompt is really about \"consensus & Membership\". Solve this as chained reasoning where stage two must respect stage one assumptions. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-061",
      "type": "multi-select",
      "question": "Consensus safety relies on which principles? (Select all that apply)",
      "options": [
        "Quorum intersection",
        "Term/epoch monotonicity",
        "Arbitrary stale leader writes",
        "Majority-based commit visibility"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Safety requires intersecting quorums and monotonic leadership terms.",
      "detailedExplanation": "Use \"consensus safety relies on which principles? (Select all that apply)\" as your starting point, then verify tradeoffs carefully. Treat every option as a separate true/false test under the same constraints. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-062",
      "type": "multi-select",
      "question": "When changing membership, safe practices include which? (Select all that apply)",
      "options": [
        "Joint-consensus style transitions",
        "One-step giant reconfiguration",
        "Rollback checkpoints",
        "Health-gated node promotion"
      ],
      "correctIndices": [0, 2, 3],
      "explanation": "Membership changes should preserve quorum intersection and reversibility.",
      "detailedExplanation": "The core signal here is \"changing membership, safe practices include which? (Select all that apply)\". Validate each option independently; do not select statements that are only partially true. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-063",
      "type": "multi-select",
      "question": "Election-storm mitigation includes which? (Select all that apply)",
      "options": [
        "Timeout jitter",
        "Stabilize flapping voters",
        "Identical fixed timeout everywhere",
        "Backpressure unstable nodes from candidacy"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Diverse timing and unstable-node handling reduce synchronized election churn.",
      "detailedExplanation": "If you keep \"election-storm mitigation includes which? (Select all that apply)\" in view, the correct answer separates faster. Treat every option as a separate true/false test under the same constraints. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-064",
      "type": "multi-select",
      "question": "Stale-leader write defense should include which? (Select all that apply)",
      "options": [
        "Leader term validation at write path",
        "Fencing/epoch checks at resource boundary",
        "Trust cached leader identity indefinitely",
        "Reject writes with old term"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Write sinks should enforce current leadership/term validity.",
      "detailedExplanation": "Start from \"stale-leader write defense should include which? (Select all that apply)\", then pressure-test the result against the options. Validate each option independently; do not select statements that are only partially true. Cache design quality is mostly about correctness boundaries, not only hit rate. Common pitfall: invalidation races under concurrent writes.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-065",
      "type": "multi-select",
      "question": "Failure detector caveats include which? (Select all that apply)",
      "options": [
        "Suspicion can be false under network jitter",
        "Detector output must not bypass safety checks",
        "Detector certainty is always perfect",
        "Tune detector thresholds to environment"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Failure detection is probabilistic and must remain separated from safety decisions.",
      "detailedExplanation": "The key clue in this question is \"failure detector caveats include which? (Select all that apply)\". Validate each option independently; do not select statements that are only partially true. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-066",
      "type": "multi-select",
      "question": "Commit index semantics imply which? (Select all that apply)",
      "options": [
        "Only committed entries should be externally visible",
        "Follower-applied but uncommitted entries are risky",
        "Commit can skip majority ack safely",
        "Client-visible state should track committed log"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "External visibility should follow majority-committed state.",
      "detailedExplanation": "Read this as a scenario about \"commit index semantics imply which? (Select all that apply)\". Validate each option independently; do not select statements that are only partially true. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "cc-cs-067",
      "type": "multi-select",
      "question": "Useful consensus observability includes which? (Select all that apply)",
      "options": [
        "Leader changes per hour",
        "Election duration distribution",
        "Only node CPU averages",
        "Commit lag and uncommitted backlog"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Consensus health needs election and commit-path telemetry.",
      "detailedExplanation": "The decision turns on \"useful consensus observability includes which? (Select all that apply)\". Validate each option independently; do not select statements that are only partially true. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-068",
      "type": "multi-select",
      "question": "Read safety in leader-based systems may require which? (Select all that apply)",
      "options": [
        "Read-index/lease-read checks",
        "Term validation before serving linearizable reads",
        "Follower stale cache trust only",
        "Fallback when leadership uncertainty exists"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Read paths need leadership confidence checks for strong semantics.",
      "detailedExplanation": "This prompt is really about \"read safety in leader-based systems may require which? (Select all that apply)\". Avoid pattern guessing and evaluate each candidate directly against the scenario. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-069",
      "type": "multi-select",
      "question": "Split-brain risk is reduced by which? (Select all that apply)",
      "options": [
        "Quorum-based leadership",
        "Stale-term write rejection",
        "Dual independent leaders with write access",
        "Membership discipline during partitions"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Quorum leadership + stale-writer rejection prevent dual-writer corruption.",
      "detailedExplanation": "Use \"split-brain risk is reduced by which? (Select all that apply)\" as your starting point, then verify tradeoffs carefully. Validate each option independently; do not select statements that are only partially true. Cache design quality is mostly about correctness boundaries, not only hit rate. Common pitfall: stale data despite high hit rates.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-070",
      "type": "multi-select",
      "question": "Liveness optimizations should avoid which trade-offs? (Select all that apply)",
      "options": [
        "Bypassing majority commit checks",
        "Unsafe manual term overrides",
        "Timeout tuning with safety intact",
        "Skipping membership validation"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Liveness tuning must not violate safety invariants.",
      "detailedExplanation": "If you keep \"liveness optimizations should avoid which trade-offs? (Select all that apply)\" in view, the correct answer separates faster. Validate each option independently; do not select statements that are only partially true. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-071",
      "type": "multi-select",
      "question": "During node replacement, safe actions include which? (Select all that apply)",
      "options": [
        "Drain voting role before removal",
        "Verify quorum after each step",
        "Replace many voters at once blindly",
        "Revalidate leader stability"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Stepwise replacement and quorum checks reduce outage risk.",
      "detailedExplanation": "The core signal here is \"during node replacement, safe actions include which? (Select all that apply)\". Avoid pattern guessing and evaluate each candidate directly against the scenario. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-072",
      "type": "multi-select",
      "question": "Consensus anti-patterns include which? (Select all that apply)",
      "options": [
        "Assuming old leader can finish writes harmlessly",
        "Undocumented quorum math for operators",
        "Canarying membership changes",
        "Treating commit lag as irrelevant"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Unsafe assumptions and weak operator guidance cause incidents.",
      "detailedExplanation": "Use \"consensus anti-patterns include which? (Select all that apply)\" as your starting point, then verify tradeoffs carefully. Treat every option as a separate true/false test under the same constraints. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-073",
      "type": "multi-select",
      "question": "Multi-region consensus concerns include which? (Select all that apply)",
      "options": [
        "Higher election and commit latency",
        "Asymmetric partition behavior",
        "No change to quorum dynamics",
        "Placement strategy affects availability"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Geography changes timing and failure characteristics of quorum systems.",
      "detailedExplanation": "This prompt is really about \"multi-region consensus concerns include which? (Select all that apply)\". Validate each option independently; do not select statements that are only partially true. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-074",
      "type": "multi-select",
      "question": "Operator runbooks for consensus should include which? (Select all that apply)",
      "options": [
        "Term/quorum inspection steps",
        "Safe emergency demotion process",
        "Unbounded manual write bypass instructions",
        "Reconfiguration rollback criteria"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Runbooks should preserve safety even under pressure.",
      "detailedExplanation": "The decision turns on \"operator runbooks for consensus should include which? (Select all that apply)\". Treat every option as a separate true/false test under the same constraints. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-075",
      "type": "multi-select",
      "question": "When follower lag rises, valid responses include which? (Select all that apply)",
      "options": [
        "Investigate replication bottlenecks",
        "Adjust write/read pressure safely",
        "Ignore lag for committed-read guarantees",
        "Pause risky membership operations"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Lag affects commit/read safety and should inform operational actions.",
      "detailedExplanation": "Read this as a scenario about \"follower lag rises, valid responses include which? (Select all that apply)\". Validate each option independently; do not select statements that are only partially true. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-076",
      "type": "multi-select",
      "question": "Consensus membership safety checks include which? (Select all that apply)",
      "options": [
        "Quorum count after each change",
        "Voter/non-voter role clarity",
        "Assume even node count always safe",
        "Term continuity validation"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Membership safety needs explicit arithmetic and role/term validation.",
      "detailedExplanation": "The key clue in this question is \"consensus membership safety checks include which? (Select all that apply)\". Validate each option independently; do not select statements that are only partially true. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-077",
      "type": "multi-select",
      "question": "High-quality failover drills should test which? (Select all that apply)",
      "options": [
        "Stale-leader rejection",
        "Election convergence time",
        "Only happy-path commit flow",
        "Client-visible consistency after failover"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Drills should validate correctness and user-visible behavior under failure.",
      "detailedExplanation": "Start from \"high-quality failover drills should test which? (Select all that apply)\", then pressure-test the result against the options. Treat every option as a separate true/false test under the same constraints. The strongest answer explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-078",
      "type": "numeric-input",
      "question": "Cluster has 7 voters; minimum votes needed for majority?",
      "answer": 4,
      "unit": "votes",
      "tolerance": 0,
      "explanation": "Majority of 7 is 4.",
      "detailedExplanation": "If you keep \"cluster has 7 voters\" in view, the correct answer separates faster. Normalize units before computing so conversion mistakes do not propagate. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. If values like 7 and 4 appear, convert them into one unit basis before comparison. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-079",
      "type": "numeric-input",
      "question": "Election timeout base is 900ms with jitter up to 300ms. Maximum timeout?",
      "answer": 1200,
      "unit": "ms",
      "tolerance": 0,
      "explanation": "900+300=1200ms.",
      "detailedExplanation": "The core signal here is \"election timeout base is 900ms with jitter up to 300ms\". Normalize units before computing so conversion mistakes do not propagate. The strongest answer explains how failure mode, mitigation speed, and blast radius interact. If values like 900ms and 300ms appear, convert them into one unit basis before comparison. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-080",
      "type": "numeric-input",
      "question": "Leader changes 84 times/day with average election duration 2.5s. Total election time/day (minutes)?",
      "answer": 3.5,
      "unit": "minutes",
      "tolerance": 0.05,
      "explanation": "84*2.5=210s=3.5min.",
      "detailedExplanation": "Read this as a scenario about \"leader changes 84 times/day with average election duration 2\". Write the unit conversion path explicitly, then calculate, then sanity-check magnitude. Consistency decisions should be explicit about which conflicts are acceptable and why. Numbers such as 84 and 2.5s should be normalized first so downstream reasoning stays consistent. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-081",
      "type": "numeric-input",
      "question": "Commit lag incidents are 0.45% over 2,800,000 ops/day. Lag incidents/day?",
      "answer": 12600,
      "unit": "operations",
      "tolerance": 0.03,
      "explanation": "0.0045*2,800,000=12,600.",
      "detailedExplanation": "The decision turns on \"commit lag incidents are 0\". Normalize units before computing so conversion mistakes do not propagate. Strong answers connect quorum/coordination settings to concrete correctness goals. If values like 0.45 and 2,800 appear, convert them into one unit basis before comparison. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-082",
      "type": "numeric-input",
      "question": "Node replacement plan removes 1 voter every 15 min from a 9-voter cluster, replacing 3 voters total. Total planned window?",
      "answer": 45,
      "unit": "minutes",
      "tolerance": 0,
      "explanation": "3*15=45 minutes.",
      "detailedExplanation": "Start from \"node replacement plan removes 1 voter every 15 min from a 9-voter cluster, replacing 3\", then pressure-test the result against the options. Write the unit conversion path explicitly, then calculate, then sanity-check magnitude. Consistency decisions should be explicit about which conflicts are acceptable and why. Numbers such as 1 and 15 min should be normalized first so downstream reasoning stays consistent. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-083",
      "type": "numeric-input",
      "question": "Follower lag backlog is 1,440,000 log entries; catch-up rate 12,000 entries/sec. Seconds to catch up?",
      "answer": 120,
      "unit": "seconds",
      "tolerance": 0,
      "explanation": "1,440,000/12,000=120s.",
      "detailedExplanation": "The key clue in this question is \"follower lag backlog is 1,440,000 log entries\". Write the unit conversion path explicitly, then calculate, then sanity-check magnitude. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Numbers such as 1,440 and 000 should be normalized first so downstream reasoning stays consistent. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-084",
      "type": "numeric-input",
      "question": "Term mismatch rejects 1,080 writes/day out of 3,600,000 writes/day. Reject rate (%)?",
      "answer": 0.03,
      "unit": "%",
      "tolerance": 0.01,
      "explanation": "1080/3,600,000=0.0003=0.03%.",
      "detailedExplanation": "The core signal here is \"term mismatch rejects 1,080 writes/day out of 3,600,000 writes/day\". Normalize units before computing so conversion mistakes do not propagate. Consistency decisions should be explicit about which conflicts are acceptable and why. If values like 1,080 and 3,600 appear, convert them into one unit basis before comparison. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-085",
      "type": "numeric-input",
      "question": "A 5-voter cluster can tolerate how many voter failures while preserving majority?",
      "answer": 2,
      "unit": "failures",
      "tolerance": 0,
      "explanation": "Majority is 3; tolerate 2 failures.",
      "detailedExplanation": "If you keep \"5-voter cluster can tolerate how many voter failures while preserving majority\" in view, the correct answer separates faster. Normalize units before computing so conversion mistakes do not propagate. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. If values like 5 and 3 appear, convert them into one unit basis before comparison. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-086",
      "type": "numeric-input",
      "question": "Commit p99 is 180ms, target is 120ms. Percent over target?",
      "answer": 50,
      "unit": "%",
      "tolerance": 0.3,
      "explanation": "(180-120)/120=50%.",
      "detailedExplanation": "This prompt is really about \"commit p99 is 180ms, target is 120ms\". Keep every transformation in one unit system and check order of magnitude at the end. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Keep quantities like 180ms and 120ms in aligned units before selecting an answer. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "Percentile",
          "url": "https://en.wikipedia.org/wiki/Percentile"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-087",
      "type": "numeric-input",
      "question": "Reconfiguration has 4 staged steps, each with 8-minute validation. Total validation time?",
      "answer": 32,
      "unit": "minutes",
      "tolerance": 0,
      "explanation": "4*8=32 minutes.",
      "detailedExplanation": "Use \"reconfiguration has 4 staged steps, each with 8-minute validation\" as your starting point, then verify tradeoffs carefully. Write the unit conversion path explicitly, then calculate, then sanity-check magnitude. Strong answers connect quorum/coordination settings to concrete correctness goals. Numbers such as 4 and 8 should be normalized first so downstream reasoning stays consistent. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-088",
      "type": "numeric-input",
      "question": "If 22% of 95,000 reads/sec require leader-read safety checks, checked reads/sec?",
      "answer": 20900,
      "unit": "reads/sec",
      "tolerance": 0.02,
      "explanation": "0.22*95,000=20,900.",
      "detailedExplanation": "Read this as a scenario about \"if 22% of 95,000 reads/sec require leader-read safety checks, checked reads/sec\". Keep every transformation in one unit system and check order of magnitude at the end. Strong answers connect quorum/coordination settings to concrete correctness goals. Keep quantities like 22 and 95,000 in aligned units before selecting an answer. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-089",
      "type": "numeric-input",
      "question": "Election storm reduced from 300/day to 45/day. Percent reduction?",
      "answer": 85,
      "unit": "%",
      "tolerance": 0.2,
      "explanation": "(300-45)/300=85%.",
      "detailedExplanation": "The decision turns on \"election storm reduced from 300/day to 45/day\". Keep every transformation in one unit system and check order of magnitude at the end. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Keep quantities like 300 and 45 in aligned units before selecting an answer. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-090",
      "type": "ordering",
      "question": "Order a safe consensus failover sequence.",
      "items": [
        "Detect leader health loss",
        "Run quorum election",
        "Establish new term leader",
        "Resume writes with term validation"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Writes should resume only after new-term leader is established.",
      "detailedExplanation": "Use \"order a safe consensus failover sequence\" as your starting point, then verify tradeoffs carefully. Place obvious extremes first, then sort the middle by pairwise comparison. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: meeting average goals while missing tail-risk.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-091",
      "type": "ordering",
      "question": "Order membership change safety flow.",
      "items": [
        "Assess quorum impact",
        "Apply single safe membership step",
        "Validate stability and commit health",
        "Proceed to next step or rollback"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Stepwise validation preserves safety during reconfiguration.",
      "detailedExplanation": "This prompt is really about \"order membership change safety flow\". Build the rank from biggest differences first, then refine with adjacent checks. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-092",
      "type": "ordering",
      "question": "Order by increasing split-brain risk.",
      "items": [
        "Quorum + term + sink validation",
        "Quorum + term validation only",
        "Leader cache trust without sink checks",
        "Independent local leaders accepting writes"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Risk rises as leadership validation weakens.",
      "detailedExplanation": "If you keep \"order by increasing split-brain risk\" in view, the correct answer separates faster. Order by relative scale and bottleneck effect, then validate neighboring items. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-093",
      "type": "ordering",
      "question": "Order observability maturity for consensus.",
      "items": [
        "Node-up/down count only",
        "Leader-change counters",
        "Leader/election + commit lag telemetry",
        "Telemetry + SLO guardrails + automated alerts"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Maturity grows with richer, action-driving telemetry.",
      "detailedExplanation": "The core signal here is \"order observability maturity for consensus\". Place obvious extremes first, then sort the middle by pairwise comparison. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-094",
      "type": "ordering",
      "question": "Order by increasing coordination complexity.",
      "items": [
        "Static 3-node quorum",
        "Larger single-region quorum",
        "Multi-region quorum",
        "Multi-region quorum with frequent membership churn"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Complexity increases with geography and dynamic membership.",
      "detailedExplanation": "The key clue in this question is \"order by increasing coordination complexity\". Order by relative scale and bottleneck effect, then validate neighboring items. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-095",
      "type": "ordering",
      "question": "Order election-stability controls from basic to advanced.",
      "items": [
        "Fixed timeout",
        "Timeout + jitter",
        "Jitter + unstable-node voting controls",
        "Jitter + voting controls + automated health gating"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Advanced controls reduce synchronized election storms.",
      "detailedExplanation": "Start from \"order election-stability controls from basic to advanced\", then pressure-test the result against the options. Build the rank from biggest differences first, then refine with adjacent checks. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-096",
      "type": "ordering",
      "question": "Order read-safety confidence from weakest to strongest.",
      "items": [
        "Cached leader hint",
        "Leader check without term validation",
        "Read-index/lease check",
        "Read-index/lease + sink term validation"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Strong read safety requires up-to-date leadership validation.",
      "detailedExplanation": "The decision turns on \"order read-safety confidence from weakest to strongest\". Build the rank from biggest differences first, then refine with adjacent checks. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-097",
      "type": "ordering",
      "question": "Order by strongest evidence of reconfiguration success.",
      "items": [
        "No incidents reported yet",
        "Stable leader count",
        "Stable leader + low commit lag",
        "Stable leader + low lag + preserved client consistency SLO"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Best evidence combines internal and user-facing correctness.",
      "detailedExplanation": "Read this as a scenario about \"order by strongest evidence of reconfiguration success\". Order by relative scale and bottleneck effect, then validate neighboring items. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-098",
      "type": "ordering",
      "question": "Order incident response for stale-leader write suspicion.",
      "items": [
        "Confirm term mismatch evidence",
        "Contain writes with strict validation mode",
        "Fix election/membership root cause",
        "Add recurrence tests and runbook updates"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Containment first, then root-cause and hardening.",
      "detailedExplanation": "Use \"order incident response for stale-leader write suspicion\" as your starting point, then verify tradeoffs carefully. Build the rank from biggest differences first, then refine with adjacent checks. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-cs-099",
      "type": "ordering",
      "question": "Order by increasing partition tolerance (availability-biased).",
      "items": [
        "Strict global sync writes",
        "Single-region quorum",
        "Regional quorum with degraded read modes",
        "Flexible degraded mode with explicit safety boundaries"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Availability under partitions increases as coordination strictness narrows.",
      "detailedExplanation": "This prompt is really about \"order by increasing partition tolerance (availability-biased)\". Order by relative scale and bottleneck effect, then validate neighboring items. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ]
    },
    {
      "id": "cc-cs-100",
      "type": "ordering",
      "question": "Order replacement procedure for a voter node.",
      "items": [
        "Add replacement as non-voter",
        "Catch up log state",
        "Promote to voter",
        "Remove old voter and revalidate quorum"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Promote only after catch-up to preserve quorum safety.",
      "detailedExplanation": "The decision turns on \"order replacement procedure for a voter node\". Order by relative scale and bottleneck effect, then validate neighboring items. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    }
  ]
}
