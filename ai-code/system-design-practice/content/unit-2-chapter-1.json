{
  "unit": 2,
  "unitTitle": "Data Modeling",
  "chapter": 1,
  "chapterTitle": "Entity Identification",
  "chapterDescription": "Given a scenario, identify the core entities that need their own tables.",
  "problems": [
    {
      "id": "ent-001",
      "type": "multiple-choice",
      "question": "You're building a blog platform. Which of these is most clearly a core entity?",
      "options": ["Post title", "Author", "Publication date", "Word count"],
      "correct": 1,
      "explanation": "Author is an entity (has identity, attributes, relationships). The others are attributes of a Post entity.",
      "detailedExplanation": "The core signal here is \"you're building a blog platform\". Reject options that conflict with the primary access pattern or index strategy. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-002",
      "type": "multi-select",
      "question": "E-commerce site: select all that should be separate entities (tables).",
      "options": ["Product", "Price", "Customer", "Order", "Shipping address"],
      "correctIndices": [0, 2, 3, 4],
      "explanation": "Product, Customer, Order, and Shipping Address are entities. Price is typically an attribute of Product (or a separate Price entity if you need price history).",
      "detailedExplanation": "Use \"e-commerce site: select all that should be separate entities (tables)\" as your starting point, then verify tradeoffs carefully. Treat every option as a separate true/false test under the same constraints. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-003",
      "type": "numeric-input",
      "question": "A user describes: 'Customers place orders for products from vendors.' How many core entities are explicitly mentioned?",
      "answer": 4,
      "tolerance": "exact",
      "explanation": "Four entities: Customer, Order, Product, Vendor. Each has distinct identity and relationships.",
      "detailedExplanation": "This prompt is really about \"user describes: 'Customers place orders for products from vendors\". Write the unit conversion path explicitly, then calculate, then sanity-check magnitude. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-004",
      "type": "multiple-choice",
      "question": "In a hotel booking system, which is NOT typically its own entity?",
      "options": ["Room", "Guest", "Reservation", "Check-in time"],
      "correct": 3,
      "explanation": "Check-in time is an attribute of Reservation, not a separate entity. Room, Guest, and Reservation each have their own identity and lifecycle.",
      "detailedExplanation": "The decision turns on \"in a hotel booking system, which is NOT typically its own entity\". Prefer the schema/index decision that minimizes query and write amplification for this workload. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-005",
      "type": "multiple-choice",
      "question": "What's the key characteristic that makes something an entity rather than an attribute?",
      "options": [
        "It has a name",
        "It has its own identity and can have multiple attributes",
        "It's a noun",
        "It appears in requirements"
      ],
      "correct": 1,
      "explanation": "An entity has its own identity (can be referenced independently) and can have multiple attributes. Not all nouns are entities—some are attributes.",
      "detailedExplanation": "Read this as a scenario about \"what's the key characteristic that makes something an entity rather than an attribute\". Discard modeling choices that look clean but perform poorly for the target queries. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-006",
      "type": "multi-select",
      "question": "Social media app: which should be entities?",
      "options": [
        "User",
        "Post",
        "Like count",
        "Comment",
        "Follower relationship"
      ],
      "correctIndices": [0, 1, 3, 4],
      "explanation": "User, Post, Comment, and Follower relationship are entities. Like count is a derived attribute (or Likes could be an entity if you need to track who liked what).",
      "detailedExplanation": "The key clue in this question is \"social media app: which should be entities\". Treat every option as a separate true/false test under the same constraints. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-007",
      "type": "multiple-choice",
      "question": "A 'Like' on a social media post—entity or attribute?",
      "options": [
        "Always an entity",
        "Always an attribute",
        "Entity if you need to know WHO liked it",
        "Depends on the database type"
      ],
      "correct": 2,
      "explanation": "If you only need a count, it's an attribute. If you need to track which users liked which posts (for feeds, notifications), Like becomes an entity with user_id and post_id.",
      "detailedExplanation": "Start from \"'Like' on a social media post—entity or attribute\", then pressure-test the result against the options. Prefer the schema/index decision that minimizes query and write amplification for this workload. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-008",
      "type": "ordering",
      "question": "Rank these from MOST to LEAST likely to be its own entity in a typical system:",
      "items": ["User", "Email address", "Created timestamp", "Payment method"],
      "correctOrder": [0, 3, 1, 2],
      "explanation": "User is almost always an entity. Payment method often needs its own table (users have multiple). Email might be an attribute or entity depending on multi-email support. Timestamp is almost always an attribute.",
      "detailedExplanation": "If you keep \"rank these from MOST to LEAST likely to be its own entity in a typical system:\" in view, the correct answer separates faster. Order by relative scale and bottleneck effect, then validate neighboring items. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-009",
      "type": "multiple-choice",
      "question": "You're modeling a library system. 'Book copy' vs 'Book title'—how many entities?",
      "options": [
        "1 (just Book)",
        "2 (Book and Copy are separate entities)",
        "1 (Copy is an attribute)",
        "Depends on if it's digital"
      ],
      "correct": 1,
      "explanation": "Two entities: Book (title, author, ISBN) and Copy (physical item, condition, location). A library has multiple copies of the same book title.",
      "detailedExplanation": "The core signal here is \"you're modeling a library system\". Discard modeling choices that look clean but perform poorly for the target queries. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-010",
      "type": "numeric-input",
      "question": "Ride-sharing app: 'Drivers give rides to passengers in vehicles.' How many entities?",
      "answer": 4,
      "tolerance": "exact",
      "explanation": "Four entities: Driver, Ride, Passenger (User), Vehicle. Each has distinct identity and attributes.",
      "detailedExplanation": "This prompt is really about \"ride-sharing app: 'Drivers give rides to passengers in vehicles\". Normalize units before computing so conversion mistakes do not propagate. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-011",
      "type": "multi-select",
      "question": "Calendar/scheduling app: select all entities.",
      "options": ["Event", "Start time", "Attendee", "Reminder", "Calendar"],
      "correctIndices": [0, 2, 3, 4],
      "explanation": "Event, Attendee (User), Reminder, and Calendar are entities. Start time is an attribute of Event.",
      "detailedExplanation": "Use \"calendar/scheduling app: select all entities\" as your starting point, then verify tradeoffs carefully. Avoid pattern guessing and evaluate each candidate directly against the scenario. A good message-system answer defines guarantees clearly for both producer and consumer paths. Common pitfall: assuming exactly-once without idempotency.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "ent-012",
      "type": "multiple-choice",
      "question": "In an inventory system, why is 'Location' typically its own entity?",
      "options": [
        "Locations have names",
        "Multiple items can be at the same location, and locations have their own attributes",
        "SQL requires it",
        "It's a noun"
      ],
      "correct": 1,
      "explanation": "Location is an entity because multiple items reference the same location, and locations have their own attributes (address, capacity, manager).",
      "detailedExplanation": "The core signal here is \"in an inventory system, why is 'Location' typically its own entity\". Reject options that conflict with the primary access pattern or index strategy. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "ent-013",
      "type": "two-stage",
      "stages": [
        {
          "question": "Food delivery app: 'Customers order food from restaurants.' How many entities in this sentence?",
          "options": ["2", "3", "4", "5"],
          "correct": 1,
          "explanation": "Three explicit entities: Customer, Order, Restaurant. Food/Menu Item is implied but not stated.",
          "detailedExplanation": "The key clue in this question is \"food delivery app: 'Customers order food from restaurants\". Solve this as chained reasoning where stage two must respect stage one assumptions. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: unbounded cardinality in joins or fan-out."
        },
        {
          "question": "Now add: 'Drivers deliver the orders.' How many TOTAL entities?",
          "options": ["3", "4", "5", "6"],
          "correct": 1,
          "explanation": "Four entities total: Customer, Order, Restaurant, Driver. 'Deliver' is an action/status on Order, not a new entity.",
          "detailedExplanation": "Read this as a scenario about \"now add: 'Drivers deliver the orders\". Do not reset assumptions between stages; carry forward prior constraints directly. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: unbounded cardinality in joins or fan-out."
        }
      ],
      "detailedExplanation": "If you keep \"entity Identification\" in view, the correct answer separates faster. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-014",
      "type": "multiple-choice",
      "question": "Why might 'Address' be its own entity instead of columns on User?",
      "options": [
        "Addresses are long strings",
        "Users might have multiple addresses (home, work, shipping)",
        "Addresses have zip codes",
        "Database normalization rules require it"
      ],
      "correct": 1,
      "explanation": "If users can have multiple addresses, Address needs to be its own entity with a foreign key to User. If users have exactly one address, it could be columns on User.",
      "detailedExplanation": "Start from \"might 'Address' be its own entity instead of columns on User\", then pressure-test the result against the options. Prefer the schema/index decision that minimizes query and write amplification for this workload. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-015",
      "type": "multi-select",
      "question": "Job board: select all entities.",
      "options": [
        "Job posting",
        "Company",
        "Applicant",
        "Application",
        "Salary range"
      ],
      "correctIndices": [0, 1, 2, 3],
      "explanation": "Job posting, Company, Applicant (User), and Application are entities. Salary range is an attribute of Job posting.",
      "detailedExplanation": "The key clue in this question is \"job board: select all entities\". Treat every option as a separate true/false test under the same constraints. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-016",
      "type": "multiple-choice",
      "question": "In a messaging app, is 'Conversation' an entity?",
      "options": [
        "No, messages are enough",
        "Yes, it groups messages and has its own attributes",
        "Only for group chats",
        "Only if using NoSQL"
      ],
      "correct": 1,
      "explanation": "Conversation is typically an entity—it has participants, created_at, last_message_at, and groups related messages. Without it, finding 'all messages between users A and B' is expensive.",
      "detailedExplanation": "Read this as a scenario about \"in a messaging app, is 'Conversation' an entity\". Discard modeling choices that look clean but perform poorly for the target queries. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-017",
      "type": "numeric-input",
      "question": "Music streaming: 'Artists release albums containing songs. Users create playlists.' How many entities?",
      "answer": 5,
      "tolerance": "exact",
      "explanation": "Five entities: Artist, Album, Song, User, Playlist. Each has distinct identity and relationships.",
      "detailedExplanation": "The decision turns on \"music streaming: 'Artists release albums containing songs\". Write the unit conversion path explicitly, then calculate, then sanity-check magnitude. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-018",
      "type": "multiple-choice",
      "question": "When does 'Tag' deserve to be its own entity?",
      "options": [
        "When tags are long strings",
        "When multiple items can share the same tag",
        "When you use PostgreSQL",
        "Always"
      ],
      "correct": 1,
      "explanation": "If multiple posts/products share tags and you want to query 'all items with tag X', Tag should be an entity. If tags are just searchable text per item, they could be an array attribute.",
      "detailedExplanation": "This prompt is really about \"'Tag' deserve to be its own entity\". Reject options that conflict with the primary access pattern or index strategy. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-019",
      "type": "ordering",
      "question": "E-commerce: rank by how likely each is to be its own entity (MOST to LEAST):",
      "items": ["Order", "Order line item", "Product description", "SKU"],
      "correctOrder": [0, 1, 3, 2],
      "explanation": "Order is always an entity. Order line item (what was ordered) is usually separate. SKU might be a Product variant entity. Product description is typically just an attribute.",
      "detailedExplanation": "Use \"e-commerce: rank by how likely each is to be its own entity (MOST to LEAST):\" as your starting point, then verify tradeoffs carefully. Place obvious extremes first, then sort the middle by pairwise comparison. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-020",
      "type": "multi-select",
      "question": "Healthcare appointment system: select all entities.",
      "options": [
        "Patient",
        "Doctor",
        "Appointment",
        "Appointment duration",
        "Medical specialty"
      ],
      "correctIndices": [0, 1, 2, 4],
      "explanation": "Patient, Doctor, Appointment, and Medical specialty (doctors can have multiple) are entities. Duration is an attribute of Appointment.",
      "detailedExplanation": "The key clue in this question is \"healthcare appointment system: select all entities\". Avoid pattern guessing and evaluate each candidate directly against the scenario. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-021",
      "type": "multiple-choice",
      "question": "You need to track product price history. How does this affect your model?",
      "options": [
        "Add a 'previous_price' column",
        "Price becomes its own entity with timestamps",
        "Use a JSON column for price history",
        "Price history isn't a data modeling concern"
      ],
      "correct": 1,
      "explanation": "To track price history, Price becomes an entity (product_id, price, effective_date). This lets you query historical prices and see price changes over time.",
      "detailedExplanation": "Start from \"you need to track product price history\", then pressure-test the result against the options. Discard modeling choices that look clean but perform poorly for the target queries. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-022",
      "type": "multiple-choice",
      "question": "In a survey/quiz app, what's the relationship between Question and Answer?",
      "options": [
        "Answer is an attribute of Question",
        "Both are entities—Question has many possible Answers",
        "Neither is an entity",
        "Depends on whether it's multiple choice"
      ],
      "correct": 1,
      "explanation": "Both are entities. A Question has multiple Answer options (for multiple choice) or a schema for expected answers. User responses are yet another entity.",
      "detailedExplanation": "The decision turns on \"in a survey/quiz app, what's the relationship between Question and Answer\". Discard modeling choices that look clean but perform poorly for the target queries. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-023",
      "type": "numeric-input",
      "question": "Project management tool: 'Teams have members. Members create tasks in projects. Tasks can have subtasks.' How many entities?",
      "answer": 5,
      "tolerance": "exact",
      "explanation": "Five entities: Team, Member (User), Task, Project, Subtask (or Task with parent_id). 'Have' and 'create' describe relationships, not entities.",
      "detailedExplanation": "Read this as a scenario about \"project management tool: 'Teams have members\". Normalize units before computing so conversion mistakes do not propagate. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-024",
      "type": "two-stage",
      "stages": [
        {
          "question": "Online course platform: 'Students enroll in courses.' How many entities?",
          "options": ["2", "3", "4"],
          "correct": 1,
          "explanation": "Three entities: Student (User), Enrollment, Course. Enrollment captures when, progress, completion status.",
          "detailedExplanation": "The decision turns on \"online course platform: 'Students enroll in courses\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: unbounded cardinality in joins or fan-out."
        },
        {
          "question": "Add: 'Courses have lessons. Students complete lessons.' How many TOTAL entities now?",
          "options": ["4", "5", "6"],
          "correct": 1,
          "explanation": "Five entities: Student, Enrollment, Course, Lesson, LessonCompletion. The completion state per student per lesson needs its own entity.",
          "detailedExplanation": "Start from \"add: 'Courses have lessons\", then pressure-test the result against the options. Do not reset assumptions between stages; carry forward prior constraints directly. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: schema optimized for entities instead of queries."
        }
      ],
      "detailedExplanation": "Use \"entity Identification\" as your starting point, then verify tradeoffs carefully. Do not reset assumptions between stages; carry forward prior constraints directly. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-025",
      "type": "multiple-choice",
      "question": "Is 'Category' for products typically an entity?",
      "options": [
        "No, store as a string on Product",
        "Yes, categories have names, descriptions, and hierarchies",
        "Only if you have more than 10 categories",
        "Only in relational databases"
      ],
      "correct": 1,
      "explanation": "Category is usually an entity—it has a name, maybe a parent category, description, and image. Products reference Category by ID.",
      "detailedExplanation": "This prompt is really about \"is 'Category' for products typically an entity\". Prefer the schema/index decision that minimizes query and write amplification for this workload. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-026",
      "type": "multi-select",
      "question": "Fitness tracking app: select all entities.",
      "options": [
        "User",
        "Workout",
        "Exercise",
        "Heart rate reading",
        "Workout duration"
      ],
      "correctIndices": [0, 1, 2, 3],
      "explanation": "User, Workout, Exercise, and Heart rate reading (time-series data point) are entities. Duration is an attribute of Workout.",
      "detailedExplanation": "If you keep \"fitness tracking app: select all entities\" in view, the correct answer separates faster. Validate each option independently; do not select statements that are only partially true. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-027",
      "type": "multiple-choice",
      "question": "When modeling a chat app, why separate Message from Attachment?",
      "options": [
        "Messages and attachments have different columns",
        "A message can have multiple attachments",
        "Attachments are larger",
        "SQL best practice"
      ],
      "correct": 1,
      "explanation": "A message can have 0, 1, or many attachments. Making Attachment a separate entity (with message_id FK) handles this cleanly.",
      "detailedExplanation": "The core signal here is \"modeling a chat app, why separate Message from Attachment\". Discard modeling choices that look clean but perform poorly for the target queries. Schema and index choices should follow access patterns and write/read amplification constraints. Keep quantities like 0 and 1 in aligned units before selecting an answer. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-028",
      "type": "ordering",
      "question": "Rank these by likelihood of being an entity (MOST to LEAST):",
      "items": ["Invoice", "Invoice line item", "Tax rate", "Invoice PDF URL"],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Invoice and line items are always entities. Tax rates often are (different rates by region). PDF URL is just an attribute.",
      "detailedExplanation": "The key clue in this question is \"rank these by likelihood of being an entity (MOST to LEAST):\". Order by relative scale and bottleneck effect, then validate neighboring items. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-029",
      "type": "multiple-choice",
      "question": "Flight booking system: is 'Seat' an entity?",
      "options": [
        "No, seat number is an attribute of Booking",
        "Yes, seats have their own properties and availability state",
        "Only for first class",
        "Only if seat selection costs extra"
      ],
      "correct": 1,
      "explanation": "Seat is typically an entity: it has a number, class, position (window/aisle), and availability per flight. Booking then references which Seat.",
      "detailedExplanation": "Start from \"flight booking system: is 'Seat' an entity\", then pressure-test the result against the options. Prioritize the option that best protects the reliability objective under the stated failure conditions. The strongest answer explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: meeting average goals while missing tail-risk.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "ent-030",
      "type": "numeric-input",
      "question": "Auction site: 'Sellers list items. Buyers place bids. Winning bids become orders.' How many entities?",
      "answer": 5,
      "tolerance": "exact",
      "explanation": "Five entities: Seller (User), Item, Buyer (User), Bid, Order. Seller and Buyer might be the same User table with different roles.",
      "detailedExplanation": "The core signal here is \"auction site: 'Sellers list items\". Keep every transformation in one unit system and check order of magnitude at the end. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-031",
      "type": "multi-select",
      "question": "Restaurant management: select all entities.",
      "options": [
        "Table",
        "Reservation",
        "Menu item",
        "Server/waiter",
        "Table capacity"
      ],
      "correctIndices": [0, 1, 2, 3],
      "explanation": "Table, Reservation, Menu item, and Server are entities. Table capacity is an attribute of Table.",
      "detailedExplanation": "If you keep \"restaurant management: select all entities\" in view, the correct answer separates faster. Avoid pattern guessing and evaluate each candidate directly against the scenario. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ]
    },
    {
      "id": "ent-032",
      "type": "multiple-choice",
      "question": "What makes 'Permission' in a role-based access system an entity?",
      "options": [
        "Permissions have long names",
        "Multiple roles can share the same permission",
        "It's required for security",
        "Permissions change frequently"
      ],
      "correct": 1,
      "explanation": "Permission is an entity because multiple roles can have the same permission, creating a many-to-many relationship. Each permission has a name and maybe a description.",
      "detailedExplanation": "This prompt is really about \"makes 'Permission' in a role-based access system an entity\". Discard modeling choices that look clean but perform poorly for the target queries. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-033",
      "type": "two-stage",
      "stages": [
        {
          "question": "Blog with comments: 'Users write posts. Users comment on posts.' How many entities?",
          "options": ["2", "3", "4"],
          "correct": 1,
          "explanation": "Three entities: User, Post, Comment. The same User entity is used for both authors and commenters.",
          "detailedExplanation": "The decision turns on \"blog with comments: 'Users write posts\". Solve this as chained reasoning where stage two must respect stage one assumptions. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: schema optimized for entities instead of queries."
        },
        {
          "question": "Add: 'Comments can be replies to other comments.' Does this add an entity?",
          "options": [
            "Yes, Reply is a new entity",
            "No, Comment gets a parent_comment_id",
            "Yes, Thread is a new entity",
            "Depends on the database"
          ],
          "correct": 1,
          "explanation": "No new entity needed. Comment gets a nullable parent_comment_id foreign key to itself, creating a tree structure.",
          "detailedExplanation": "Start from \"add: 'Comments can be replies to other comments\", then pressure-test the result against the options. Solve this as chained reasoning where stage two must respect stage one assumptions. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: indexing that over-amplifies writes."
        }
      ],
      "detailedExplanation": "Use \"entity Identification\" as your starting point, then verify tradeoffs carefully. Solve this as chained reasoning where stage two must respect stage one assumptions. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-034",
      "type": "multiple-choice",
      "question": "In a multi-tenant SaaS app, is 'Tenant/Organization' an entity?",
      "options": [
        "No, just add tenant_id to other tables",
        "Yes, it's a core entity that other data belongs to",
        "Only if you charge per tenant",
        "Only for enterprise plans"
      ],
      "correct": 1,
      "explanation": "Tenant/Organization is a core entity—it has a name, settings, billing info, and nearly all other entities belong to a tenant.",
      "detailedExplanation": "Read this as a scenario about \"in a multi-tenant SaaS app, is 'Tenant/Organization' an entity\". Discard modeling choices that look clean but perform poorly for the target queries. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-035",
      "type": "multi-select",
      "question": "Event ticketing: select all entities.",
      "options": ["Event", "Venue", "Ticket", "Seat", "Ticket price"],
      "correctIndices": [0, 1, 2, 3],
      "explanation": "Event, Venue, Ticket, and Seat are entities. Ticket price is an attribute (though it could be an entity for dynamic pricing).",
      "detailedExplanation": "The decision turns on \"event ticketing: select all entities\". Avoid pattern guessing and evaluate each candidate directly against the scenario. A good message-system answer defines guarantees clearly for both producer and consumer paths. Common pitfall: assuming exactly-once without idempotency.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "ent-036",
      "type": "multiple-choice",
      "question": "Notification system: is each Notification an entity?",
      "options": [
        "No, notifications are just logs",
        "Yes, each notification has state (read/unread), recipient, timestamp",
        "Only push notifications",
        "Only if persisted beyond delivery"
      ],
      "correct": 1,
      "explanation": "Notification is an entity—it has recipient, content, type, read/unread state, and timestamps. Users need to see their unread notifications.",
      "detailedExplanation": "Start from \"notification system: is each Notification an entity\", then pressure-test the result against the options. Reject options that conflict with the primary access pattern or index strategy. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-037",
      "type": "numeric-input",
      "question": "CRM system: 'Salespeople manage accounts. Accounts have contacts. Contacts participate in deals.' How many entities?",
      "answer": 4,
      "tolerance": "exact",
      "explanation": "Four entities: Salesperson (User), Account (Company), Contact, Deal. 'Manage' and 'participate' are relationships.",
      "detailedExplanation": "The key clue in this question is \"cRM system: 'Salespeople manage accounts\". Write the unit conversion path explicitly, then calculate, then sanity-check magnitude. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-038",
      "type": "ordering",
      "question": "Social network: rank by centrality to the data model (MOST to LEAST central):",
      "items": ["User", "Post", "Like", "Hashtag"],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "User is the most central (everything relates to users). Posts are core content. Likes connect users to content. Hashtags are metadata on posts.",
      "detailedExplanation": "The core signal here is \"social network: rank by centrality to the data model (MOST to LEAST central):\". Place obvious extremes first, then sort the middle by pairwise comparison. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        },
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        }
      ]
    },
    {
      "id": "ent-039",
      "type": "multiple-choice",
      "question": "When should 'Phone Number' be its own entity vs a column?",
      "options": [
        "Always a column—phone numbers are just strings",
        "Entity if users can have multiple phone numbers",
        "Entity only for international numbers",
        "Always an entity for normalization"
      ],
      "correct": 1,
      "explanation": "If users have exactly one phone number, it's a column. If users can have multiple (home, work, mobile), Phone Number becomes an entity with user_id FK.",
      "detailedExplanation": "If you keep \"'Phone Number' be its own entity vs a column\" in view, the correct answer separates faster. Discard modeling choices that look clean but perform poorly for the target queries. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-040",
      "type": "multi-select",
      "question": "Recipe app: select all entities.",
      "options": ["Recipe", "Ingredient", "Step", "Cooking time", "User"],
      "correctIndices": [0, 1, 2, 4],
      "explanation": "Recipe, Ingredient, Step, and User are entities. Cooking time is an attribute of Recipe.",
      "detailedExplanation": "The decision turns on \"recipe app: select all entities\". Avoid pattern guessing and evaluate each candidate directly against the scenario. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-041",
      "type": "multiple-choice",
      "question": "What's the risk of NOT making 'Country' an entity and just storing country names as strings?",
      "options": [
        "Strings use more storage",
        "Inconsistent data ('USA', 'United States', 'US')",
        "Slower queries",
        "No risk, strings are fine"
      ],
      "correct": 1,
      "explanation": "Without a Country entity, you'll get inconsistent values. A Country table with id and canonical name ensures consistency and lets you add country metadata.",
      "detailedExplanation": "Read this as a scenario about \"what's the risk of NOT making 'Country' an entity and just storing country names as\". Eliminate approaches that hand-wave conflict resolution or quorum behavior. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "ent-042",
      "type": "two-stage",
      "stages": [
        {
          "question": "Ride-sharing: 'Users request rides.' Is Ride an entity separate from RideRequest?",
          "options": [
            "No, just one Ride entity",
            "Yes, Request becomes Ride when matched",
            "Only the Ride entity matters",
            "Depends on the app"
          ],
          "correct": 0,
          "explanation": "Typically one entity: Ride. It starts as a request and transitions through states (requested, matched, in_progress, completed).",
          "detailedExplanation": "If you keep \"ride-sharing: 'Users request rides\" in view, the correct answer separates faster. Do not reset assumptions between stages; carry forward prior constraints directly. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: unbounded cardinality in joins or fan-out."
        },
        {
          "question": "If riders can schedule future rides, does this change your answer?",
          "options": [
            "No change",
            "Yes, ScheduledRide becomes separate",
            "Yes, now need both entities",
            "Add a scheduled boolean"
          ],
          "correct": 0,
          "explanation": "Still one entity. Ride gets a scheduled_for timestamp. Status flow handles both immediate and scheduled rides.",
          "detailedExplanation": "This prompt is really about \"if riders can schedule future rides, does this change your answer\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: schema optimized for entities instead of queries."
        }
      ],
      "detailedExplanation": "The key clue in this question is \"entity Identification\". Do not reset assumptions between stages; carry forward prior constraints directly. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-043",
      "type": "multiple-choice",
      "question": "Version control for documents: is 'Version' an entity?",
      "options": [
        "No, just keep the current document",
        "Yes, each version has content, author, and timestamp",
        "Only for important documents",
        "Only if you use Git"
      ],
      "correct": 1,
      "explanation": "Version is an entity if you need history. Each version has document_id, content/diff, author, timestamp. The Document entity tracks the current version.",
      "detailedExplanation": "Start from \"version control for documents: is 'Version' an entity\", then pressure-test the result against the options. Prefer the choice that keeps client behavior explicit while preserving evolvability. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "ent-044",
      "type": "numeric-input",
      "question": "Forum software: 'Users create threads in categories. Threads have posts. Users can follow threads.' How many entities?",
      "answer": 5,
      "tolerance": "exact",
      "explanation": "Five entities: User, Thread, Category, Post, ThreadFollow (user following a thread). 'Create' and 'have' are relationships.",
      "detailedExplanation": "If you keep \"forum software: 'Users create threads in categories\" in view, the correct answer separates faster. Normalize units before computing so conversion mistakes do not propagate. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "ent-045",
      "type": "multi-select",
      "question": "Banking app: select all entities.",
      "options": ["Account", "Transaction", "Balance", "User", "Transfer"],
      "correctIndices": [0, 1, 3, 4],
      "explanation": "Account, Transaction, User, and Transfer (a type of transaction between accounts) are entities. Balance is typically a derived attribute or cached value.",
      "detailedExplanation": "The core signal here is \"banking app: select all entities\". Avoid pattern guessing and evaluate each candidate directly against the scenario. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-046",
      "type": "multiple-choice",
      "question": "Is 'Follow' (user following another user) an entity or a relationship table?",
      "options": [
        "Just a relationship, not an entity",
        "It's both—relationship tables are entities",
        "Neither, store as JSON",
        "Only an entity if you track when"
      ],
      "correct": 1,
      "explanation": "A Follow table (follower_id, followed_id, created_at) is both a relationship table AND an entity. It has its own attributes and can be queried independently.",
      "detailedExplanation": "Use \"is 'Follow' (user following another user) an entity or a relationship table\" as your starting point, then verify tradeoffs carefully. Reject options that conflict with the primary access pattern or index strategy. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-047",
      "type": "ordering",
      "question": "Rank these by how commonly they're separate entities (MOST to LEAST common):",
      "items": ["User", "Address", "Phone number", "Middle name"],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "User is always an entity. Address is often separate (multiple per user). Phone is sometimes separate. Middle name is virtually always just a column.",
      "detailedExplanation": "This prompt is really about \"rank these by how commonly they're separate entities (MOST to LEAST common):\". Build the rank from biggest differences first, then refine with adjacent checks. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-048",
      "type": "multiple-choice",
      "question": "E-commerce: when is 'Inventory' a separate entity from 'Product'?",
      "options": [
        "When you have a lot of products",
        "When stock varies by location/warehouse",
        "When products are expensive",
        "Never—inventory is just a count on Product"
      ],
      "correct": 1,
      "explanation": "Inventory becomes an entity when quantity varies by location. Inventory(product_id, location_id, quantity) handles multi-warehouse stock.",
      "detailedExplanation": "The decision turns on \"e-commerce: when is 'Inventory' a separate entity from 'Product'\". Prefer the schema/index decision that minimizes query and write amplification for this workload. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-049",
      "type": "multi-select",
      "question": "Video streaming: select all entities.",
      "options": [
        "Video",
        "User",
        "Watch history entry",
        "Video resolution",
        "Playlist"
      ],
      "correctIndices": [0, 1, 2, 4],
      "explanation": "Video, User, Watch history entry (user watched video at time), and Playlist are entities. Resolution is an attribute or part of video encoding.",
      "detailedExplanation": "Read this as a scenario about \"video streaming: select all entities\". Validate each option independently; do not select statements that are only partially true. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-050",
      "type": "multiple-choice",
      "question": "Subscription service: is 'Plan' an entity?",
      "options": [
        "No, just store plan name on subscription",
        "Yes, plans have features, prices, and limits",
        "Only if you have multiple plans",
        "Only for B2B"
      ],
      "correct": 1,
      "explanation": "Plan is an entity—it has name, price, features, limits. Subscription references which Plan. This makes plan changes and grandfathering manageable.",
      "detailedExplanation": "Start from \"subscription service: is 'Plan' an entity\", then pressure-test the result against the options. Reject options that conflict with the primary access pattern or index strategy. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-051",
      "type": "two-stage",
      "stages": [
        {
          "question": "Calendar app: 'Users have calendars. Calendars have events.' How many entities?",
          "options": ["2", "3", "4"],
          "correct": 1,
          "explanation": "Three entities: User, Calendar, Event. Users might have multiple calendars (work, personal).",
          "detailedExplanation": "If you keep \"calendar app: 'Users have calendars\" in view, the correct answer separates faster. Solve this as chained reasoning where stage two must respect stage one assumptions. Throughput is only one part; replay behavior and consumer lag handling matter equally. Common pitfall: ordering loss during partition or replay changes."
        },
        {
          "question": "Add: 'Events can have multiple attendees who RSVP.' How many entities now?",
          "options": ["3", "4", "5"],
          "correct": 1,
          "explanation": "Four entities: User, Calendar, Event, EventAttendee (or RSVP). The attendee record tracks user_id, event_id, and RSVP status.",
          "detailedExplanation": "This prompt is really about \"add: 'Events can have multiple attendees who RSVP\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. Common pitfall: ordering loss during partition or replay changes."
        }
      ],
      "detailedExplanation": "The key clue in this question is \"entity Identification\". Do not reset assumptions between stages; carry forward prior constraints directly. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-052",
      "type": "multiple-choice",
      "question": "What's wrong with storing 'skills' as a comma-separated string on User?",
      "options": [
        "Strings are slow",
        "Can't index or query 'all users with skill X' efficiently",
        "Skills need to be unique",
        "Nothing, this is fine"
      ],
      "correct": 1,
      "explanation": "Comma-separated strings can't be efficiently queried or indexed. Making Skill an entity with a UserSkill junction table enables 'find users with skill X' queries.",
      "detailedExplanation": "Read this as a scenario about \"what's wrong with storing 'skills' as a comma-separated string on User\". Prefer the schema/index decision that minimizes query and write amplification for this workload. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-053",
      "type": "numeric-input",
      "question": "Analytics platform: 'Organizations have dashboards. Dashboards have widgets. Widgets show metrics.' How many entities?",
      "answer": 4,
      "tolerance": "exact",
      "explanation": "Four entities: Organization, Dashboard, Widget, Metric. Widgets reference which metrics to display.",
      "detailedExplanation": "The decision turns on \"analytics platform: 'Organizations have dashboards\". Keep every transformation in one unit system and check order of magnitude at the end. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-054",
      "type": "multi-select",
      "question": "Food delivery: select all entities.",
      "options": [
        "Restaurant",
        "Menu",
        "Menu item",
        "Order",
        "Estimated delivery time"
      ],
      "correctIndices": [0, 1, 2, 3],
      "explanation": "Restaurant, Menu, Menu item, and Order are entities. Estimated delivery time is a calculated or cached attribute.",
      "detailedExplanation": "This prompt is really about \"food delivery: select all entities\". Treat every option as a separate true/false test under the same constraints. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-055",
      "type": "multiple-choice",
      "question": "Why might 'Currency' be an entity in a global financial app?",
      "options": [
        "Currency codes are long",
        "Each currency has a code, symbol, decimal places, and exchange rates",
        "SQL requires it",
        "For internationalization"
      ],
      "correct": 1,
      "explanation": "Currency as an entity stores code (USD), symbol ($), decimal places (2), and enables exchange rate tracking. Amounts reference currency_id.",
      "detailedExplanation": "Use \"might 'Currency' be an entity in a global financial app\" as your starting point, then verify tradeoffs carefully. Reject options that conflict with the primary access pattern or index strategy. Schema and index choices should follow access patterns and write/read amplification constraints. If values like 2 appear, convert them into one unit basis before comparison. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-056",
      "type": "ordering",
      "question": "Issue tracker: rank by likelihood of being an entity (MOST to LEAST):",
      "items": ["Issue", "Comment", "Status", "Label"],
      "correctOrder": [0, 1, 3, 2],
      "explanation": "Issue and Comment are always entities. Label usually is (issues have multiple). Status might be an enum/attribute or an entity for custom workflows.",
      "detailedExplanation": "The core signal here is \"issue tracker: rank by likelihood of being an entity (MOST to LEAST):\". Place obvious extremes first, then sort the middle by pairwise comparison. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-057",
      "type": "multiple-choice",
      "question": "Appointment booking: is 'Time Slot' an entity?",
      "options": [
        "No, just store appointment time",
        "Yes, if providers define available slots in advance",
        "Only for calendar view",
        "Only if slots have duration"
      ],
      "correct": 1,
      "explanation": "If providers define availability as slots (9am-10am, 10am-11am), TimeSlot is an entity. Appointments book a specific slot. Without predefined slots, just store appointment datetime.",
      "detailedExplanation": "If you keep \"appointment booking: is 'Time Slot' an entity\" in view, the correct answer separates faster. Reject choices that sound good generally but do not reduce the concrete reliability risk in this scenario. The strongest answer explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "ent-058",
      "type": "multi-select",
      "question": "Polling/voting app: select all entities.",
      "options": ["Poll", "Option", "Vote", "Vote count", "User"],
      "correctIndices": [0, 1, 2, 4],
      "explanation": "Poll, Option, Vote, and User are entities. Vote count is a derived/cached value from counting Vote records.",
      "detailedExplanation": "Start from \"polling/voting app: select all entities\", then pressure-test the result against the options. Validate each option independently; do not select statements that are only partially true. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-059",
      "type": "multiple-choice",
      "question": "Multi-language content: how do you model translations?",
      "options": [
        "One column per language (title_en, title_es)",
        "Translation is an entity (content_id, language, text)",
        "Store all languages in JSON",
        "Use a translation service"
      ],
      "correct": 1,
      "explanation": "Translation as an entity (content_id, language_code, text) is most flexible. Adding new languages doesn't require schema changes.",
      "detailedExplanation": "The key clue in this question is \"multi-language content: how do you model translations\". Reject options that conflict with the primary access pattern or index strategy. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-060",
      "type": "numeric-input",
      "question": "Gym membership: 'Members have memberships. Memberships grant access to facilities. Members book classes.' How many entities?",
      "answer": 5,
      "tolerance": "exact",
      "explanation": "Five entities: Member (User), Membership, Facility, Class, ClassBooking. Membership might grant access to specific facilities.",
      "detailedExplanation": "Use \"gym membership: 'Members have memberships\" as your starting point, then verify tradeoffs carefully. Keep every transformation in one unit system and check order of magnitude at the end. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-061",
      "type": "two-stage",
      "stages": [
        {
          "question": "Wiki software: 'Users edit pages.' How many entities?",
          "options": ["2", "3", "4"],
          "correct": 0,
          "explanation": "Two entities: User and Page. 'Edit' is an action, not an entity... unless you need edit history.",
          "detailedExplanation": "Start from \"wiki software: 'Users edit pages\", then pressure-test the result against the options. Solve this as chained reasoning where stage two must respect stage one assumptions. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: unbounded cardinality in joins or fan-out."
        },
        {
          "question": "Add: 'Every edit is tracked with who, when, and what changed.' How many now?",
          "options": ["2", "3", "4"],
          "correct": 1,
          "explanation": "Three entities: User, Page, Revision (or Edit). Revision captures each change with user_id, page_id, content, timestamp.",
          "detailedExplanation": "The decision turns on \"add: 'Every edit is tracked with who, when, and what changed\". Solve this as chained reasoning where stage two must respect stage one assumptions. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: indexing that over-amplifies writes."
        }
      ],
      "detailedExplanation": "This prompt is really about \"entity Identification\". Solve this as chained reasoning where stage two must respect stage one assumptions. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-062",
      "type": "multiple-choice",
      "question": "When is 'File' or 'Attachment' typically its own entity?",
      "options": [
        "When files are large",
        "When files can be attached to multiple record types",
        "When using cloud storage",
        "Always"
      ],
      "correct": 1,
      "explanation": "File as an entity (with URL, type, size) is useful when files can be attached to posts, messages, comments, etc. Generic attachment system avoids duplicating file handling.",
      "detailedExplanation": "If you keep \"'File' or 'Attachment' typically its own entity\" in view, the correct answer separates faster. Discard modeling choices that look clean but perform poorly for the target queries. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-063",
      "type": "multi-select",
      "question": "HR system: select all entities.",
      "options": [
        "Employee",
        "Department",
        "Salary",
        "Job title",
        "Performance review"
      ],
      "correctIndices": [0, 1, 3, 4],
      "explanation": "Employee, Department, Job title (shared across employees), and Performance review are entities. Salary is typically an attribute (or entity for salary history).",
      "detailedExplanation": "The core signal here is \"hR system: select all entities\". Treat every option as a separate true/false test under the same constraints. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-064",
      "type": "multiple-choice",
      "question": "Is 'Session' (user login session) an entity?",
      "options": [
        "No, sessions are just tokens",
        "Yes, sessions have user, device, IP, expiry, and can be revoked",
        "Only for security-sensitive apps",
        "Only if using JWT"
      ],
      "correct": 1,
      "explanation": "Session is an entity—it tracks user_id, token, device info, IP, created_at, expires_at. Storing sessions enables 'revoke all sessions' and 'view active devices'.",
      "detailedExplanation": "The key clue in this question is \"is 'Session' (user login session) an entity\". Reject options that conflict with the primary access pattern or index strategy. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "RFC 7519: JSON Web Token (JWT)",
          "url": "https://www.rfc-editor.org/rfc/rfc7519"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "ent-065",
      "type": "ordering",
      "question": "E-learning: rank by likelihood of being an entity (MOST to LEAST):",
      "items": ["Course", "Lesson", "Quiz question", "Video duration"],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Course, Lesson, and Quiz question are entities with distinct identity. Video duration is an attribute of Lesson or Video.",
      "detailedExplanation": "Start from \"e-learning: rank by likelihood of being an entity (MOST to LEAST):\", then pressure-test the result against the options. Build the rank from biggest differences first, then refine with adjacent checks. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-066",
      "type": "multiple-choice",
      "question": "Review platform: is 'Rating' an entity or attribute?",
      "options": [
        "Attribute—it's just a number 1-5",
        "Entity—it captures who rated what and when",
        "Depends on whether you allow text reviews",
        "Neither—use a rating service"
      ],
      "correct": 1,
      "explanation": "Rating (or Review) is an entity: user_id, product_id, rating, review_text, created_at. This enables 'your reviews' and prevents duplicate reviews.",
      "detailedExplanation": "The decision turns on \"review platform: is 'Rating' an entity or attribute\". Prefer the schema/index decision that minimizes query and write amplification for this workload. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-067",
      "type": "numeric-input",
      "question": "Hotel chain: 'Guests book rooms at properties. Properties have amenities.' How many entities?",
      "answer": 5,
      "tolerance": "exact",
      "explanation": "Five entities: Guest (User), Booking (Reservation), Room, Property (Hotel), Amenity. Rooms belong to properties; amenities might be per-property or per-room.",
      "detailedExplanation": "Read this as a scenario about \"hotel chain: 'Guests book rooms at properties\". Keep every transformation in one unit system and check order of magnitude at the end. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-068",
      "type": "multi-select",
      "question": "Code repository: select all entities.",
      "options": [
        "Repository",
        "Commit",
        "Branch",
        "File content",
        "Pull request"
      ],
      "correctIndices": [0, 1, 2, 4],
      "explanation": "Repository, Commit, Branch, and Pull request are entities. File content is typically stored in blobs or the filesystem, referenced by commits.",
      "detailedExplanation": "Use \"code repository: select all entities\" as your starting point, then verify tradeoffs carefully. Validate each option independently; do not select statements that are only partially true. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-069",
      "type": "multiple-choice",
      "question": "What determines if 'Payment Method' should be an entity?",
      "options": [
        "Whether you use Stripe",
        "Whether users can save multiple payment methods",
        "Whether payments are large",
        "PCI compliance requires it"
      ],
      "correct": 1,
      "explanation": "If users can save multiple cards/bank accounts, Payment Method is an entity (user_id, type, last4, token). If it's one-time payments only, you might not persist payment methods.",
      "detailedExplanation": "This prompt is really about \"determines if 'Payment Method' should be an entity\". Prefer the schema/index decision that minimizes query and write amplification for this workload. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "RFC 7519: JSON Web Token (JWT)",
          "url": "https://www.rfc-editor.org/rfc/rfc7519"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "ent-070",
      "type": "two-stage",
      "stages": [
        {
          "question": "Referral program: 'Users refer friends.' What entity captures this?",
          "options": [
            "No new entity—add referred_by to User",
            "Referral entity with referrer_id and referred_id",
            "Both approaches work equally",
            "Use a graph database"
          ],
          "correct": 1,
          "explanation": "Referral as an entity captures who referred whom, when, and referral status (pending, completed). This is better than just referred_by for tracking multi-level referrals.",
          "detailedExplanation": "Read this as a scenario about \"referral program: 'Users refer friends\". Solve this as chained reasoning where stage two must respect stage one assumptions. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: unbounded cardinality in joins or fan-out."
        },
        {
          "question": "Add: 'Referrers earn rewards when referred friends make purchases.' Does this add an entity?",
          "options": [
            "No",
            "Yes, ReferralReward",
            "Yes, Purchase",
            "Yes, both"
          ],
          "correct": 3,
          "explanation": "Two more entities: Purchase (to track friend's purchases) and ReferralReward (to track rewards earned). Reward links referral to the triggering purchase.",
          "detailedExplanation": "The key clue in this question is \"add: 'Referrers earn rewards when referred friends make purchases\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: indexing that over-amplifies writes."
        }
      ],
      "detailedExplanation": "Read this as a scenario about \"entity Identification\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-071",
      "type": "multiple-choice",
      "question": "Is 'ActivityLog' or 'AuditLog' an entity?",
      "options": [
        "No, logs go in files",
        "Yes, it records who did what, when, on which resource",
        "Only for compliance",
        "Only for admin users"
      ],
      "correct": 1,
      "explanation": "Audit log is an entity if you need to query it (show user activity, compliance reports). Records user_id, action, resource_type, resource_id, timestamp, old/new values.",
      "detailedExplanation": "The decision turns on \"is 'ActivityLog' or 'AuditLog' an entity\". Reject options that conflict with the primary access pattern or index strategy. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-072",
      "type": "multi-select",
      "question": "Dating app: select all entities.",
      "options": ["User", "Match", "Message", "Swipe", "Profile photo"],
      "correctIndices": [0, 1, 2, 3, 4],
      "explanation": "All five are entities. User, Match (mutual likes), Message, Swipe (like/pass record), and Profile photo (users have multiple) all have their own identity.",
      "detailedExplanation": "Start from \"dating app: select all entities\", then pressure-test the result against the options. Validate each option independently; do not select statements that are only partially true. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-073",
      "type": "numeric-input",
      "question": "Warehouse management: 'Products are stored in bins on shelves in aisles in warehouses.' How many location-related entities?",
      "answer": 4,
      "tolerance": "exact",
      "explanation": "Four location entities: Warehouse, Aisle, Shelf, Bin. Each level has its own identity and belongs to the level above. Product inventory references Bin.",
      "detailedExplanation": "The key clue in this question is \"warehouse management: 'Products are stored in bins on shelves in aisles in warehouses\". Write the unit conversion path explicitly, then calculate, then sanity-check magnitude. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-074",
      "type": "multiple-choice",
      "question": "Email marketing: is 'EmailCampaign' an entity separate from 'Email'?",
      "options": [
        "No, just send emails",
        "Yes, campaigns group emails and track aggregate stats",
        "Only for large lists",
        "Only if A/B testing"
      ],
      "correct": 1,
      "explanation": "Campaign is an entity (name, subject template, target segment). Each Email (campaign_id, recipient_id, sent_at, opened_at) tracks individual delivery.",
      "detailedExplanation": "The core signal here is \"email marketing: is 'EmailCampaign' an entity separate from 'Email'\". Discard modeling choices that look clean but perform poorly for the target queries. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-075",
      "type": "ordering",
      "question": "Invoice system: rank by likelihood of being an entity (MOST to LEAST):",
      "items": ["Invoice", "Line item", "Payment", "Due date"],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Invoice, Line item, and Payment are entities. Due date is an attribute of Invoice.",
      "detailedExplanation": "If you keep \"invoice system: rank by likelihood of being an entity (MOST to LEAST):\" in view, the correct answer separates faster. Place obvious extremes first, then sort the middle by pairwise comparison. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-076",
      "type": "multi-select",
      "question": "Online marketplace: select all entities.",
      "options": ["Seller", "Buyer", "Listing", "Review", "Average rating"],
      "correctIndices": [0, 1, 2, 3],
      "explanation": "Seller, Buyer (both User types), Listing, and Review are entities. Average rating is a derived/cached value.",
      "detailedExplanation": "This prompt is really about \"online marketplace: select all entities\". Treat every option as a separate true/false test under the same constraints. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-077",
      "type": "multiple-choice",
      "question": "Coupon/discount system: is 'Coupon' an entity?",
      "options": [
        "No, just apply discounts in code",
        "Yes, coupons have codes, rules, expiry, and usage limits",
        "Only for percentage discounts",
        "Only if transferable"
      ],
      "correct": 1,
      "explanation": "Coupon is an entity: code, discount_type, amount, min_order, expiry_date, max_uses, current_uses. CouponUsage tracks which users used which coupons.",
      "detailedExplanation": "Use \"coupon/discount system: is 'Coupon' an entity\" as your starting point, then verify tradeoffs carefully. Discard modeling choices that look clean but perform poorly for the target queries. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-078",
      "type": "two-stage",
      "stages": [
        {
          "question": "Messaging app with channels: 'Users join channels. Users send messages.' How many entities?",
          "options": ["2", "3", "4"],
          "correct": 2,
          "explanation": "Four entities: User, Channel, ChannelMembership (user's presence in a channel), Message. Membership tracks when joined and notification preferences.",
          "detailedExplanation": "Read this as a scenario about \"messaging app with channels: 'Users join channels\". Do not reset assumptions between stages; carry forward prior constraints directly. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: unbounded cardinality in joins or fan-out."
        },
        {
          "question": "Add: 'Messages can have reactions (emoji).' Does this add an entity?",
          "options": [
            "No, store as JSON on message",
            "Yes, Reaction entity",
            "Only if tracking who reacted",
            "Depends on emoji count"
          ],
          "correct": 1,
          "explanation": "Reaction is an entity if you need to know who added which reactions. Schema: message_id, user_id, emoji. Enables 'people who reacted' tooltip.",
          "detailedExplanation": "The key clue in this question is \"add: 'Messages can have reactions (emoji)\". Do not reset assumptions between stages; carry forward prior constraints directly. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: unbounded cardinality in joins or fan-out."
        }
      ],
      "detailedExplanation": "Read this as a scenario about \"entity Identification\". Solve this as chained reasoning where stage two must respect stage one assumptions. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-079",
      "type": "multiple-choice",
      "question": "Podcast platform: is 'Episode' separate from 'Podcast'?",
      "options": [
        "No, episodes are just audio files",
        "Yes, podcasts have multiple episodes with own metadata",
        "Only if episodes have transcripts",
        "Only for serialized podcasts"
      ],
      "correct": 1,
      "explanation": "Podcast is an entity (name, author, description). Episode is a separate entity (podcast_id, title, audio_url, duration, published_at). A podcast has many episodes.",
      "detailedExplanation": "The decision turns on \"podcast platform: is 'Episode' separate from 'Podcast'\". Discard modeling choices that look clean but perform poorly for the target queries. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-080",
      "type": "numeric-input",
      "question": "Ticketing system: 'Agents handle tickets from customers. Tickets can be escalated and have comments.' How many entities?",
      "answer": 4,
      "tolerance": "exact",
      "explanation": "Four entities: Agent (User), Ticket, Customer (User or separate), Comment. Escalation is a status change on Ticket, not a new entity.",
      "detailedExplanation": "If you keep \"ticketing system: 'Agents handle tickets from customers\" in view, the correct answer separates faster. Write the unit conversion path explicitly, then calculate, then sanity-check magnitude. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-081",
      "type": "multi-select",
      "question": "Appointment scheduling: select all entities.",
      "options": [
        "Provider",
        "Client",
        "Appointment",
        "Service type",
        "Duration"
      ],
      "correctIndices": [0, 1, 2, 3],
      "explanation": "Provider, Client (both User types), Appointment, and Service type (haircut, consultation, etc.) are entities. Duration is an attribute of Service type.",
      "detailedExplanation": "The core signal here is \"appointment scheduling: select all entities\". Treat every option as a separate true/false test under the same constraints. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-082",
      "type": "multiple-choice",
      "question": "When does 'Feature Flag' become an entity?",
      "options": [
        "When you have many flags",
        "When flags can target specific users or segments",
        "When using a feature flag service",
        "Feature flags shouldn't be in the database"
      ],
      "correct": 1,
      "explanation": "Feature Flag as an entity (name, enabled, targeting rules) lets you manage flags in the app. FeatureFlagOverride can target specific users or segments.",
      "detailedExplanation": "Use \"'Feature Flag' become an entity\" as your starting point, then verify tradeoffs carefully. Prefer the schema/index decision that minimizes query and write amplification for this workload. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-083",
      "type": "ordering",
      "question": "Social media: rank by how essential each entity is (MOST to LEAST):",
      "items": [
        "User",
        "Content (post)",
        "Relationship (follow)",
        "Engagement (like)"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "User is fundamental—no app without users. Content is the core activity. Relationships enable the social graph. Engagement is derived from interactions.",
      "detailedExplanation": "This prompt is really about \"social media: rank by how essential each entity is (MOST to LEAST):\". Order by relative scale and bottleneck effect, then validate neighboring items. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-084",
      "type": "multiple-choice",
      "question": "Multi-language app: is 'Language' an entity?",
      "options": [
        "No, just use string language codes",
        "Yes, languages have codes, names, and display settings",
        "Only for less common languages",
        "Only if using a CMS"
      ],
      "correct": 1,
      "explanation": "Language as an entity stores code (en), name (English), native name (English), RTL flag, date format. Useful for consistent language handling.",
      "detailedExplanation": "The decision turns on \"multi-language app: is 'Language' an entity\". Discard modeling choices that look clean but perform poorly for the target queries. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-085",
      "type": "numeric-input",
      "question": "Logistics: 'Packages travel from origin to destination through hubs on vehicles.' How many entities?",
      "answer": 4,
      "tolerance": "exact",
      "explanation": "Four entities: Package, Location (origin/destination/hub), Vehicle, and possibly Shipment (a trip). 'Travel' is the journey, tracked by shipment events.",
      "detailedExplanation": "Read this as a scenario about \"logistics: 'Packages travel from origin to destination through hubs on vehicles\". Write the unit conversion path explicitly, then calculate, then sanity-check magnitude. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-086",
      "type": "multi-select",
      "question": "News site: select all entities.",
      "options": ["Article", "Author", "Category", "Publish date", "Comment"],
      "correctIndices": [0, 1, 2, 4],
      "explanation": "Article, Author (User), Category, and Comment are entities. Publish date is an attribute of Article.",
      "detailedExplanation": "The key clue in this question is \"news site: select all entities\". Avoid pattern guessing and evaluate each candidate directly against the scenario. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-087",
      "type": "two-stage",
      "stages": [
        {
          "question": "Photo sharing: 'Users upload photos to albums.' How many entities?",
          "options": ["2", "3", "4"],
          "correct": 1,
          "explanation": "Three entities: User, Photo, Album. Photos belong to albums; albums belong to users.",
          "detailedExplanation": "This prompt is really about \"photo sharing: 'Users upload photos to albums\". Solve this as chained reasoning where stage two must respect stage one assumptions. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: schema optimized for entities instead of queries."
        },
        {
          "question": "Add: 'Users can tag other users in photos.' Does this add an entity?",
          "options": [
            "No, add tagged_users array to Photo",
            "Yes, PhotoTag entity",
            "Only if tagging specific locations",
            "Depends on notification needs"
          ],
          "correct": 1,
          "explanation": "PhotoTag is an entity: photo_id, tagged_user_id, position (x,y). Enables querying 'photos I'm tagged in' and handling tag notifications.",
          "detailedExplanation": "If you keep \"add: 'Users can tag other users in photos\" in view, the correct answer separates faster. Do not reset assumptions between stages; carry forward prior constraints directly. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: unbounded cardinality in joins or fan-out."
        }
      ],
      "detailedExplanation": "Start from \"entity Identification\", then pressure-test the result against the options. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-088",
      "type": "multiple-choice",
      "question": "Reporting/BI tool: is 'Report' an entity?",
      "options": [
        "No, reports are just queries",
        "Yes, reports have definition, schedule, and recipients",
        "Only for scheduled reports",
        "Only if exports are saved"
      ],
      "correct": 1,
      "explanation": "Report as an entity stores name, query definition, filters, schedule, recipient list. ReportRun might track each execution with results.",
      "detailedExplanation": "If you keep \"reporting/BI tool: is 'Report' an entity\" in view, the correct answer separates faster. Prefer the schema/index decision that minimizes query and write amplification for this workload. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-089",
      "type": "multi-select",
      "question": "Inventory management: select all entities.",
      "options": [
        "Product",
        "SKU/Variant",
        "Location",
        "Stock level",
        "Supplier"
      ],
      "correctIndices": [0, 1, 2, 4],
      "explanation": "Product, SKU/Variant (size/color variants), Location (warehouse), and Supplier are entities. Stock level is an attribute of Inventory (product + location).",
      "detailedExplanation": "The core signal here is \"inventory management: select all entities\". Treat every option as a separate true/false test under the same constraints. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-090",
      "type": "numeric-input",
      "question": "Insurance: 'Customers buy policies. Policies cover risks. Customers file claims.' How many entities?",
      "answer": 4,
      "tolerance": "exact",
      "explanation": "Four entities: Customer, Policy, Risk (or Coverage type), Claim. 'Buy' creates a policy; 'file' creates a claim against a policy.",
      "detailedExplanation": "This prompt is really about \"insurance: 'Customers buy policies\". Write the unit conversion path explicitly, then calculate, then sanity-check magnitude. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-091",
      "type": "multiple-choice",
      "question": "When modeling an API: is 'APIKey' an entity?",
      "options": [
        "No, just store keys in config",
        "Yes, API keys have owner, permissions, created date, and can be revoked",
        "Only for third-party APIs",
        "Only if rate limiting"
      ],
      "correct": 1,
      "explanation": "APIKey is an entity: key_hash, owner (user or app), permissions/scopes, created_at, last_used_at, revoked_at. Enables key management and auditing.",
      "detailedExplanation": "Use \"modeling an API: is 'APIKey' an entity\" as your starting point, then verify tradeoffs carefully. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "ent-092",
      "type": "ordering",
      "question": "Blog platform: rank by how likely each is an entity (MOST to LEAST):",
      "items": ["Post", "Author", "Tag", "Paragraph"],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Post and Author are always entities. Tag usually is (many-to-many with posts). Paragraph is rarely a separate entity—usually post content is one text field.",
      "detailedExplanation": "The core signal here is \"blog platform: rank by how likely each is an entity (MOST to LEAST):\". Order by relative scale and bottleneck effect, then validate neighboring items. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-093",
      "type": "multi-select",
      "question": "Subscription box service: select all entities.",
      "options": [
        "Subscriber",
        "Subscription",
        "Box",
        "Product",
        "Shipping address"
      ],
      "correctIndices": [0, 1, 2, 3, 4],
      "explanation": "All five are entities. Subscriber (User), Subscription (plan, status), Box (specific shipment), Product (items in box), Shipping address (can differ from billing).",
      "detailedExplanation": "If you keep \"subscription box service: select all entities\" in view, the correct answer separates faster. Validate each option independently; do not select statements that are only partially true. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-094",
      "type": "multiple-choice",
      "question": "What distinguishes an 'entity' from a 'value object' in domain modeling?",
      "options": [
        "Entities are larger",
        "Entities have identity that persists across changes",
        "Value objects aren't stored",
        "There's no meaningful difference"
      ],
      "correct": 1,
      "explanation": "Entities have identity—a User is the same User even if name changes. Value objects are defined by their attributes—two Addresses with same values are interchangeable.",
      "detailedExplanation": "Start from \"distinguishes an 'entity' from a 'value object' in domain modeling\", then pressure-test the result against the options. Reject options that conflict with the primary access pattern or index strategy. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-095",
      "type": "two-stage",
      "stages": [
        {
          "question": "Fitness app: 'Users log workouts.' What entity captures a workout?",
          "options": [
            "Add columns to User",
            "Workout entity with user_id, date, duration",
            "Store in JSON on User",
            "No entity needed"
          ],
          "correct": 1,
          "explanation": "Workout is an entity: user_id, started_at, duration, type. Users have many workouts over time.",
          "detailedExplanation": "If you keep \"fitness app: 'Users log workouts\" in view, the correct answer separates faster. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: schema optimized for entities instead of queries."
        },
        {
          "question": "Add: 'Workouts contain multiple exercises with sets/reps.' How does the model change?",
          "options": [
            "Add exercises JSON to Workout",
            "Add WorkoutExercise and Set entities",
            "Just add columns",
            "Depends on reporting needs"
          ],
          "correct": 1,
          "explanation": "Add entities: Exercise (name, muscle group) and WorkoutExercise (workout_id, exercise_id, sets, reps, weight) or even Set as its own entity for detailed tracking.",
          "detailedExplanation": "This prompt is really about \"add: 'Workouts contain multiple exercises with sets/reps\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: indexing that over-amplifies writes."
        }
      ],
      "detailedExplanation": "The key clue in this question is \"entity Identification\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-096",
      "type": "numeric-input",
      "question": "Real estate: 'Agents list properties. Buyers view properties and make offers.' How many entities?",
      "answer": 5,
      "tolerance": "exact",
      "explanation": "Five entities: Agent (User), Property, Listing, Buyer (User), Offer. Listing connects agent to property with price and status.",
      "detailedExplanation": "Read this as a scenario about \"real estate: 'Agents list properties\". Keep every transformation in one unit system and check order of magnitude at the end. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: schema optimized for entities instead of queries.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-097",
      "type": "multi-select",
      "question": "Learning management system: select all entities.",
      "options": ["Student", "Course", "Assignment", "Grade", "Submission"],
      "correctIndices": [0, 1, 2, 3, 4],
      "explanation": "All five are entities. Grade might be on Submission (student's score for assignment) or a separate entity for flexibility. Submission captures what student turned in.",
      "detailedExplanation": "The decision turns on \"learning management system: select all entities\". Avoid pattern guessing and evaluate each candidate directly against the scenario. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-098",
      "type": "multiple-choice",
      "question": "Workflow automation: is 'WorkflowExecution' an entity?",
      "options": [
        "No, just run workflows",
        "Yes, it tracks each run with input, status, and output",
        "Only for failed runs",
        "Only for async workflows"
      ],
      "correct": 1,
      "explanation": "WorkflowExecution (or Run) is an entity: workflow_id, triggered_by, input_data, status, output_data, started_at, finished_at. Enables monitoring and debugging.",
      "detailedExplanation": "This prompt is really about \"workflow automation: is 'WorkflowExecution' an entity\". Discard modeling choices that look clean but perform poorly for the target queries. Schema and index choices should follow access patterns and write/read amplification constraints. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-099",
      "type": "ordering",
      "question": "CRM: rank by centrality to the data model (MOST to LEAST):",
      "items": ["Contact", "Company/Account", "Deal", "Activity/Note"],
      "correctOrder": [1, 0, 2, 3],
      "explanation": "Company/Account is often most central (B2B CRM). Contacts belong to companies. Deals involve companies and contacts. Activities are logged on the others.",
      "detailedExplanation": "Use \"cRM: rank by centrality to the data model (MOST to LEAST):\" as your starting point, then verify tradeoffs carefully. Order by relative scale and bottleneck effect, then validate neighboring items. Choose data shape based on workload paths, not on normalization dogma alone. Common pitfall: indexing that over-amplifies writes.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "ent-100",
      "type": "multiple-choice",
      "question": "What's the main question to ask when deciding if something should be an entity?",
      "options": [
        "Is it a noun?",
        "Does it need to be referenced independently or have multiple instances per parent?",
        "Is it important?",
        "Will it have many attributes?"
      ],
      "correct": 1,
      "explanation": "The key question: Does this thing need its own identity? Can there be multiple per parent? Will other things reference it? If yes to any, it's likely an entity.",
      "detailedExplanation": "The core signal here is \"what's the main question to ask when deciding if something should be an entity\". Prefer the schema/index decision that minimizes query and write amplification for this workload. Modeling quality is measured by query fit, cardinality behavior, and operational cost. Common pitfall: unbounded cardinality in joins or fan-out.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    }
  ]
}
