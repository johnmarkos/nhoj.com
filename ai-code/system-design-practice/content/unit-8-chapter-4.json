{
  "unit": 8,
  "unitTitle": "Consistency & Coordination",
  "chapter": 4,
  "chapterTitle": "Transactions & Isolation in Distributed Systems",
  "chapterDescription": "Balancing correctness and throughput across transaction boundaries, isolation guarantees, and cross-service failure modes.",
  "problems": [
    {
      "id": "cc-ti-001",
      "type": "multiple-choice",
      "question": "A checkout + inventory workflow is seeing lost updates under concurrent writes. Which transaction/isolation decision is strongest? The incident reproduced under synthetic concurrent load.",
      "options": [
        "Use optimistic concurrency with version checks on contention-prone rows plus retry policy.",
        "Lower isolation globally to maximize throughput and ignore anomalies.",
        "Rely on client retries to resolve all transactional conflicts safely.",
        "Treat distributed side effects as independent of transaction correctness."
      ],
      "correct": 0,
      "explanation": "Isolation/transaction strategy should be scoped to invariant-critical paths while keeping side effects safely coordinated.",
      "detailedExplanation": "Read this as a scenario about \"checkout + inventory workflow is seeing lost updates under concurrent writes\". Reject choices that sound good generally but do not reduce the concrete reliability risk in this scenario. The strongest answer explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ]
    },
    {
      "id": "cc-ti-002",
      "type": "multiple-choice",
      "question": "A payment + ledger posting pipeline is seeing write skew across related records. Which transaction/isolation decision is strongest? Recent retries amplified duplicate side effects.",
      "options": [
        "Lower isolation globally to maximize throughput and ignore anomalies.",
        "Rely on client retries to resolve all transactional conflicts safely.",
        "Treat distributed side effects as independent of transaction correctness.",
        "Use serializable/strong isolation only on invariant-critical transaction boundaries."
      ],
      "correct": 3,
      "explanation": "Isolation/transaction strategy should be scoped to invariant-critical paths while keeping side effects safely coordinated.",
      "detailedExplanation": "The key clue in this question is \"payment + ledger posting pipeline is seeing write skew across related records\". Prefer the option that preserves correctness guarantees for the stated consistency boundary. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-003",
      "type": "multiple-choice",
      "question": "A ticket booking reservation path is seeing phantom reads in range checks. Which transaction/isolation decision is strongest? Business requires strict invariant correctness on this path.",
      "options": [
        "Rely on client retries to resolve all transactional conflicts safely.",
        "Treat distributed side effects as independent of transaction correctness.",
        "Apply explicit locking or SELECT FOR UPDATE on shared invariant records.",
        "Lower isolation globally to maximize throughput and ignore anomalies."
      ],
      "correct": 2,
      "explanation": "Isolation/transaction strategy should be scoped to invariant-critical paths while keeping side effects safely coordinated.",
      "detailedExplanation": "Start from \"ticket booking reservation path is seeing phantom reads in range checks\", then pressure-test the result against the options. Discard choices that violate required invariants during concurrent or failed states. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-004",
      "type": "multiple-choice",
      "question": "A profile update + audit trail flow is seeing non-repeatable reads in multi-step logic. Which transaction/isolation decision is strongest? Latency is important but correctness takes priority here.",
      "options": [
        "Treat distributed side effects as independent of transaction correctness.",
        "Split critical invariant write path from eventually consistent side effects via outbox pattern.",
        "Lower isolation globally to maximize throughput and ignore anomalies.",
        "Rely on client retries to resolve all transactional conflicts safely."
      ],
      "correct": 1,
      "explanation": "Isolation/transaction strategy should be scoped to invariant-critical paths while keeping side effects safely coordinated.",
      "detailedExplanation": "If you keep \"profile update + audit trail flow is seeing non-repeatable reads in multi-step logic\" in view, the correct answer separates faster. Eliminate approaches that hand-wave conflict resolution or quorum behavior. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-005",
      "type": "multiple-choice",
      "question": "A multi-service order fulfillment is seeing partial failure between service boundaries. Which transaction/isolation decision is strongest? Current implementation spans multiple storage boundaries.",
      "options": [
        "Use saga with compensating actions where distributed 2PC is impractical.",
        "Lower isolation globally to maximize throughput and ignore anomalies.",
        "Rely on client retries to resolve all transactional conflicts safely.",
        "Treat distributed side effects as independent of transaction correctness."
      ],
      "correct": 0,
      "explanation": "Isolation/transaction strategy should be scoped to invariant-critical paths while keeping side effects safely coordinated.",
      "detailedExplanation": "The core signal here is \"multi-service order fulfillment is seeing partial failure between service boundaries\". Prefer the option that preserves correctness guarantees for the stated consistency boundary. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        },
        {
          "title": "Google Cloud Storage pricing",
          "url": "https://cloud.google.com/storage/pricing"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-006",
      "type": "multiple-choice",
      "question": "A cart merge + coupon validation path is seeing double-spend risk in concurrent debits. Which transaction/isolation decision is strongest? On-call reports intermittent race-condition behavior.",
      "options": [
        "Lower isolation globally to maximize throughput and ignore anomalies.",
        "Rely on client retries to resolve all transactional conflicts safely.",
        "Treat distributed side effects as independent of transaction correctness.",
        "Enforce idempotency keys on externally retried transactional endpoints."
      ],
      "correct": 3,
      "explanation": "Isolation/transaction strategy should be scoped to invariant-critical paths while keeping side effects safely coordinated.",
      "detailedExplanation": "Use \"cart merge + coupon validation path is seeing double-spend risk in concurrent debits\" as your starting point, then verify tradeoffs carefully. Eliminate approaches that hand-wave conflict resolution or quorum behavior. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-007",
      "type": "multiple-choice",
      "question": "A wallet debit + notification service is seeing stale reads before invariant checks. Which transaction/isolation decision is strongest? Audit findings flagged transactional ambiguity.",
      "options": [
        "Rely on client retries to resolve all transactional conflicts safely.",
        "Treat distributed side effects as independent of transaction correctness.",
        "Promote range-check logic to isolation level that prevents phantom-based violations.",
        "Lower isolation globally to maximize throughput and ignore anomalies."
      ],
      "correct": 2,
      "explanation": "Isolation/transaction strategy should be scoped to invariant-critical paths while keeping side effects safely coordinated.",
      "detailedExplanation": "This prompt is really about \"wallet debit + notification service is seeing stale reads before invariant checks\". Discard cache tactics that hide consistency bugs under high load. A strong caching answer names staleness limits, invalidation behavior, and keying strategy. Common pitfall: hot-key skew causing uneven load.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-008",
      "type": "multiple-choice",
      "question": "A shipping allocation + stock decrement flow is seeing deadlock contention at peak load. Which transaction/isolation decision is strongest? Rollback handling is currently inconsistent across services.",
      "options": [
        "Treat distributed side effects as independent of transaction correctness.",
        "Reduce deadlock risk via deterministic lock ordering and smaller transaction scope.",
        "Lower isolation globally to maximize throughput and ignore anomalies.",
        "Rely on client retries to resolve all transactional conflicts safely."
      ],
      "correct": 1,
      "explanation": "Isolation/transaction strategy should be scoped to invariant-critical paths while keeping side effects safely coordinated.",
      "detailedExplanation": "The decision turns on \"shipping allocation + stock decrement flow is seeing deadlock contention at peak load\". Discard choices that violate required invariants during concurrent or failed states. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-009",
      "type": "multiple-choice",
      "question": "A refund orchestration pipeline is seeing idempotency gaps during retries. Which transaction/isolation decision is strongest? The team needs a reversible first mitigation.",
      "options": [
        "Use transactional outbox to atomically persist state change + event emission intent.",
        "Lower isolation globally to maximize throughput and ignore anomalies.",
        "Rely on client retries to resolve all transactional conflicts safely.",
        "Treat distributed side effects as independent of transaction correctness."
      ],
      "correct": 0,
      "explanation": "Isolation/transaction strategy should be scoped to invariant-critical paths while keeping side effects safely coordinated.",
      "detailedExplanation": "Read this as a scenario about \"refund orchestration pipeline is seeing idempotency gaps during retries\". Prefer the option that preserves correctness guarantees for the stated consistency boundary. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-010",
      "type": "multiple-choice",
      "question": "A quota enforcement + usage write path is seeing cross-service commit ambiguity. Which transaction/isolation decision is strongest? Traffic spikes expose hidden isolation anomalies.",
      "options": [
        "Lower isolation globally to maximize throughput and ignore anomalies.",
        "Rely on client retries to resolve all transactional conflicts safely.",
        "Treat distributed side effects as independent of transaction correctness.",
        "Model invariant ownership to minimize multi-entity cross-service transactions."
      ],
      "correct": 3,
      "explanation": "Isolation/transaction strategy should be scoped to invariant-critical paths while keeping side effects safely coordinated.",
      "detailedExplanation": "Start from \"quota enforcement + usage write path is seeing cross-service commit ambiguity\", then pressure-test the result against the options. Prefer the choice that keeps client behavior explicit while preserving evolvability. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-011",
      "type": "multiple-choice",
      "question": "A document edit + permission update workflow is seeing lost updates under concurrent writes. Which transaction/isolation decision is strongest? A prior fix addressed symptoms but not root cause.",
      "options": [
        "Rely on client retries to resolve all transactional conflicts safely.",
        "Treat distributed side effects as independent of transaction correctness.",
        "Use optimistic concurrency with version checks on contention-prone rows plus retry policy.",
        "Lower isolation globally to maximize throughput and ignore anomalies."
      ],
      "correct": 2,
      "explanation": "Isolation/transaction strategy should be scoped to invariant-critical paths while keeping side effects safely coordinated.",
      "detailedExplanation": "The key clue in this question is \"document edit + permission update workflow is seeing lost updates under concurrent\". Discard choices that violate required invariants during concurrent or failed states. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-012",
      "type": "multiple-choice",
      "question": "A subscription renewal + entitlement grant path is seeing write skew across related records. Which transaction/isolation decision is strongest? Service-level retries are not transaction-aware today.",
      "options": [
        "Treat distributed side effects as independent of transaction correctness.",
        "Use serializable/strong isolation only on invariant-critical transaction boundaries.",
        "Lower isolation globally to maximize throughput and ignore anomalies.",
        "Rely on client retries to resolve all transactional conflicts safely."
      ],
      "correct": 1,
      "explanation": "Isolation/transaction strategy should be scoped to invariant-critical paths while keeping side effects safely coordinated.",
      "detailedExplanation": "Read this as a scenario about \"subscription renewal + entitlement grant path is seeing write skew across related\". Eliminate approaches that hand-wave conflict resolution or quorum behavior. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-013",
      "type": "multiple-choice",
      "question": "A marketplace purchase + seller payout flow is seeing phantom reads in range checks. Which transaction/isolation decision is strongest? Data model changes increased contention hotspots.",
      "options": [
        "Apply explicit locking or SELECT FOR UPDATE on shared invariant records.",
        "Lower isolation globally to maximize throughput and ignore anomalies.",
        "Rely on client retries to resolve all transactional conflicts safely.",
        "Treat distributed side effects as independent of transaction correctness."
      ],
      "correct": 0,
      "explanation": "Isolation/transaction strategy should be scoped to invariant-critical paths while keeping side effects safely coordinated.",
      "detailedExplanation": "The decision turns on \"marketplace purchase + seller payout flow is seeing phantom reads in range checks\". Prefer the option that preserves correctness guarantees for the stated consistency boundary. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "cc-ti-014",
      "type": "multiple-choice",
      "question": "A fraud hold + transaction commit path is seeing non-repeatable reads in multi-step logic. Which transaction/isolation decision is strongest? Current path mixes critical writes and side effects.",
      "options": [
        "Lower isolation globally to maximize throughput and ignore anomalies.",
        "Rely on client retries to resolve all transactional conflicts safely.",
        "Treat distributed side effects as independent of transaction correctness.",
        "Split critical invariant write path from eventually consistent side effects via outbox pattern."
      ],
      "correct": 3,
      "explanation": "Isolation/transaction strategy should be scoped to invariant-critical paths while keeping side effects safely coordinated.",
      "detailedExplanation": "This prompt is really about \"fraud hold + transaction commit path is seeing non-repeatable reads in multi-step logic\". Eliminate approaches that hand-wave conflict resolution or quorum behavior. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-015",
      "type": "multiple-choice",
      "question": "A seat assignment + payment capture flow is seeing partial failure between service boundaries. Which transaction/isolation decision is strongest? Cross-region latency made distributed locking slower.",
      "options": [
        "Rely on client retries to resolve all transactional conflicts safely.",
        "Treat distributed side effects as independent of transaction correctness.",
        "Use saga with compensating actions where distributed 2PC is impractical.",
        "Lower isolation globally to maximize throughput and ignore anomalies."
      ],
      "correct": 2,
      "explanation": "Isolation/transaction strategy should be scoped to invariant-critical paths while keeping side effects safely coordinated.",
      "detailedExplanation": "Use \"seat assignment + payment capture flow is seeing partial failure between service\" as your starting point, then verify tradeoffs carefully. Discard choices that violate required invariants during concurrent or failed states. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-016",
      "type": "multiple-choice",
      "question": "A identity verification + account activation flow is seeing double-spend risk in concurrent debits. Which transaction/isolation decision is strongest? Partial failure handling is not formally documented.",
      "options": [
        "Treat distributed side effects as independent of transaction correctness.",
        "Enforce idempotency keys on externally retried transactional endpoints.",
        "Lower isolation globally to maximize throughput and ignore anomalies.",
        "Rely on client retries to resolve all transactional conflicts safely."
      ],
      "correct": 1,
      "explanation": "Isolation/transaction strategy should be scoped to invariant-critical paths while keeping side effects safely coordinated.",
      "detailedExplanation": "The core signal here is \"identity verification + account activation flow is seeing double-spend risk in\". Discard choices that violate required invariants during concurrent or failed states. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-017",
      "type": "multiple-choice",
      "question": "A campaign publish + cache invalidation path is seeing stale reads before invariant checks. Which transaction/isolation decision is strongest? The issue appears only under concurrent tenant activity.",
      "options": [
        "Promote range-check logic to isolation level that prevents phantom-based violations.",
        "Lower isolation globally to maximize throughput and ignore anomalies.",
        "Rely on client retries to resolve all transactional conflicts safely.",
        "Treat distributed side effects as independent of transaction correctness."
      ],
      "correct": 0,
      "explanation": "Isolation/transaction strategy should be scoped to invariant-critical paths while keeping side effects safely coordinated.",
      "detailedExplanation": "If you keep \"campaign publish + cache invalidation path is seeing stale reads before invariant checks\" in view, the correct answer separates faster. Prefer the choice that balances hit rate with clear staleness and invalidation behavior. Cache design quality is mostly about correctness boundaries, not only hit rate. Common pitfall: hot-key skew causing uneven load.",
      "references": [
        {
          "title": "Redis Documentation",
          "url": "https://redis.io/docs/latest/"
        },
        {
          "title": "Cache-Aside pattern",
          "url": "https://learn.microsoft.com/en-us/azure/architecture/patterns/cache-aside"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-018",
      "type": "multiple-choice",
      "question": "A service-plan upgrade + billing adjustment is seeing deadlock contention at peak load. Which transaction/isolation decision is strongest? Metrics show lock waits rising before errors.",
      "options": [
        "Lower isolation globally to maximize throughput and ignore anomalies.",
        "Rely on client retries to resolve all transactional conflicts safely.",
        "Treat distributed side effects as independent of transaction correctness.",
        "Reduce deadlock risk via deterministic lock ordering and smaller transaction scope."
      ],
      "correct": 3,
      "explanation": "Isolation/transaction strategy should be scoped to invariant-critical paths while keeping side effects safely coordinated.",
      "detailedExplanation": "Start from \"service-plan upgrade + billing adjustment is seeing deadlock contention at peak load\", then pressure-test the result against the options. Discard choices that violate required invariants during concurrent or failed states. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-019",
      "type": "multiple-choice",
      "question": "A batch settlement + reporting close process is seeing idempotency gaps during retries. Which transaction/isolation decision is strongest? The team wants to avoid global strongest isolation everywhere.",
      "options": [
        "Rely on client retries to resolve all transactional conflicts safely.",
        "Treat distributed side effects as independent of transaction correctness.",
        "Use transactional outbox to atomically persist state change + event emission intent.",
        "Lower isolation globally to maximize throughput and ignore anomalies."
      ],
      "correct": 2,
      "explanation": "Isolation/transaction strategy should be scoped to invariant-critical paths while keeping side effects safely coordinated.",
      "detailedExplanation": "The key clue in this question is \"batch settlement + reporting close process is seeing idempotency gaps during retries\". Eliminate approaches that hand-wave conflict resolution or quorum behavior. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-020",
      "type": "multiple-choice",
      "question": "A notification preference + downstream sync flow is seeing cross-service commit ambiguity. Which transaction/isolation decision is strongest? Critical entities are a subset of total traffic.",
      "options": [
        "Treat distributed side effects as independent of transaction correctness.",
        "Model invariant ownership to minimize multi-entity cross-service transactions.",
        "Lower isolation globally to maximize throughput and ignore anomalies.",
        "Rely on client retries to resolve all transactional conflicts safely."
      ],
      "correct": 1,
      "explanation": "Isolation/transaction strategy should be scoped to invariant-critical paths while keeping side effects safely coordinated.",
      "detailedExplanation": "Use \"notification preference + downstream sync flow is seeing cross-service commit ambiguity\" as your starting point, then verify tradeoffs carefully. Discard choices that violate required invariants during concurrent or failed states. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-021",
      "type": "multiple-choice",
      "question": "A checkout + inventory workflow is seeing lost updates under concurrent writes. Which transaction/isolation decision is strongest? Recent deployment changed transaction boundaries.",
      "options": [
        "Use optimistic concurrency with version checks on contention-prone rows plus retry policy.",
        "Lower isolation globally to maximize throughput and ignore anomalies.",
        "Rely on client retries to resolve all transactional conflicts safely.",
        "Treat distributed side effects as independent of transaction correctness."
      ],
      "correct": 0,
      "explanation": "Isolation/transaction strategy should be scoped to invariant-critical paths while keeping side effects safely coordinated.",
      "detailedExplanation": "This prompt is really about \"checkout + inventory workflow is seeing lost updates under concurrent writes\". Eliminate approaches that hand-wave conflict resolution or quorum behavior. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-022",
      "type": "multiple-choice",
      "question": "A payment + ledger posting pipeline is seeing write skew across related records. Which transaction/isolation decision is strongest? SLO pressure discourages blanket heavy locking.",
      "options": [
        "Lower isolation globally to maximize throughput and ignore anomalies.",
        "Rely on client retries to resolve all transactional conflicts safely.",
        "Treat distributed side effects as independent of transaction correctness.",
        "Use serializable/strong isolation only on invariant-critical transaction boundaries."
      ],
      "correct": 3,
      "explanation": "Isolation/transaction strategy should be scoped to invariant-critical paths while keeping side effects safely coordinated.",
      "detailedExplanation": "If you keep \"payment + ledger posting pipeline is seeing write skew across related records\" in view, the correct answer separates faster. Eliminate answers that do not directly address the failure mode, recovery path, or blast radius. Tie the decision to concrete operational outcomes, not abstract reliability language. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-023",
      "type": "multiple-choice",
      "question": "A ticket booking reservation path is seeing phantom reads in range checks. Which transaction/isolation decision is strongest? Incident review requires explicit isolation-level rationale.",
      "options": [
        "Rely on client retries to resolve all transactional conflicts safely.",
        "Treat distributed side effects as independent of transaction correctness.",
        "Apply explicit locking or SELECT FOR UPDATE on shared invariant records.",
        "Lower isolation globally to maximize throughput and ignore anomalies."
      ],
      "correct": 2,
      "explanation": "Isolation/transaction strategy should be scoped to invariant-critical paths while keeping side effects safely coordinated.",
      "detailedExplanation": "The core signal here is \"ticket booking reservation path is seeing phantom reads in range checks\". Eliminate answers that do not directly address the failure mode, recovery path, or blast radius. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-024",
      "type": "multiple-choice",
      "question": "A profile update + audit trail flow is seeing non-repeatable reads in multi-step logic. Which transaction/isolation decision is strongest? Compensation logic is present but not consistently triggered.",
      "options": [
        "Treat distributed side effects as independent of transaction correctness.",
        "Split critical invariant write path from eventually consistent side effects via outbox pattern.",
        "Lower isolation globally to maximize throughput and ignore anomalies.",
        "Rely on client retries to resolve all transactional conflicts safely."
      ],
      "correct": 1,
      "explanation": "Isolation/transaction strategy should be scoped to invariant-critical paths while keeping side effects safely coordinated.",
      "detailedExplanation": "The key clue in this question is \"profile update + audit trail flow is seeing non-repeatable reads in multi-step logic\". Prefer the option that preserves correctness guarantees for the stated consistency boundary. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-025",
      "type": "multiple-choice",
      "question": "A multi-service order fulfillment is seeing partial failure between service boundaries. Which transaction/isolation decision is strongest? A dependent service sometimes commits later than expected.",
      "options": [
        "Use saga with compensating actions where distributed 2PC is impractical.",
        "Lower isolation globally to maximize throughput and ignore anomalies.",
        "Rely on client retries to resolve all transactional conflicts safely.",
        "Treat distributed side effects as independent of transaction correctness."
      ],
      "correct": 0,
      "explanation": "Isolation/transaction strategy should be scoped to invariant-critical paths while keeping side effects safely coordinated.",
      "detailedExplanation": "Start from \"multi-service order fulfillment is seeing partial failure between service boundaries\", then pressure-test the result against the options. Discard choices that violate required invariants during concurrent or failed states. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-026",
      "type": "multiple-choice",
      "question": "A cart merge + coupon validation path is seeing double-spend risk in concurrent debits. Which transaction/isolation decision is strongest? Observability now includes conflict/retry counters.",
      "options": [
        "Lower isolation globally to maximize throughput and ignore anomalies.",
        "Rely on client retries to resolve all transactional conflicts safely.",
        "Treat distributed side effects as independent of transaction correctness.",
        "Enforce idempotency keys on externally retried transactional endpoints."
      ],
      "correct": 3,
      "explanation": "Isolation/transaction strategy should be scoped to invariant-critical paths while keeping side effects safely coordinated.",
      "detailedExplanation": "The decision turns on \"cart merge + coupon validation path is seeing double-spend risk in concurrent debits\". Prioritize the option that best protects the reliability objective under the stated failure conditions. Tie the decision to concrete operational outcomes, not abstract reliability language. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Retry pattern",
          "url": "https://learn.microsoft.com/en-us/azure/architecture/patterns/retry"
        }
      ]
    },
    {
      "id": "cc-ti-027",
      "type": "multiple-choice",
      "question": "A wallet debit + notification service is seeing stale reads before invariant checks. Which transaction/isolation decision is strongest? The workflow is sensitive to duplicate external callbacks.",
      "options": [
        "Rely on client retries to resolve all transactional conflicts safely.",
        "Treat distributed side effects as independent of transaction correctness.",
        "Promote range-check logic to isolation level that prevents phantom-based violations.",
        "Lower isolation globally to maximize throughput and ignore anomalies."
      ],
      "correct": 2,
      "explanation": "Isolation/transaction strategy should be scoped to invariant-critical paths while keeping side effects safely coordinated.",
      "detailedExplanation": "Read this as a scenario about \"wallet debit + notification service is seeing stale reads before invariant checks\". Reject options that improve speed but weaken freshness or invalidation correctness. A strong caching answer names staleness limits, invalidation behavior, and keying strategy. Common pitfall: invalidation races under concurrent writes.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-028",
      "type": "multiple-choice",
      "question": "A shipping allocation + stock decrement flow is seeing deadlock contention at peak load. Which transaction/isolation decision is strongest? Business accepts eventual consistency for non-critical side effects.",
      "options": [
        "Treat distributed side effects as independent of transaction correctness.",
        "Reduce deadlock risk via deterministic lock ordering and smaller transaction scope.",
        "Lower isolation globally to maximize throughput and ignore anomalies.",
        "Rely on client retries to resolve all transactional conflicts safely."
      ],
      "correct": 1,
      "explanation": "Isolation/transaction strategy should be scoped to invariant-critical paths while keeping side effects safely coordinated.",
      "detailedExplanation": "Use \"shipping allocation + stock decrement flow is seeing deadlock contention at peak load\" as your starting point, then verify tradeoffs carefully. Discard choices that violate required invariants during concurrent or failed states. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ]
    },
    {
      "id": "cc-ti-029",
      "type": "multiple-choice",
      "question": "A refund orchestration pipeline is seeing idempotency gaps during retries. Which transaction/isolation decision is strongest? Data ownership is split across service boundaries.",
      "options": [
        "Use transactional outbox to atomically persist state change + event emission intent.",
        "Lower isolation globally to maximize throughput and ignore anomalies.",
        "Rely on client retries to resolve all transactional conflicts safely.",
        "Treat distributed side effects as independent of transaction correctness."
      ],
      "correct": 0,
      "explanation": "Isolation/transaction strategy should be scoped to invariant-critical paths while keeping side effects safely coordinated.",
      "detailedExplanation": "This prompt is really about \"refund orchestration pipeline is seeing idempotency gaps during retries\". Discard choices that violate required invariants during concurrent or failed states. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-030",
      "type": "multiple-choice",
      "question": "A quota enforcement + usage write path is seeing cross-service commit ambiguity. Which transaction/isolation decision is strongest? Consistency bugs are harming user trust and reconciliation.",
      "options": [
        "Lower isolation globally to maximize throughput and ignore anomalies.",
        "Rely on client retries to resolve all transactional conflicts safely.",
        "Treat distributed side effects as independent of transaction correctness.",
        "Model invariant ownership to minimize multi-entity cross-service transactions."
      ],
      "correct": 3,
      "explanation": "Isolation/transaction strategy should be scoped to invariant-critical paths while keeping side effects safely coordinated.",
      "detailedExplanation": "Read this as a scenario about \"quota enforcement + usage write path is seeing cross-service commit ambiguity\". Eliminate designs that create ambiguous API semantics or brittle versioning paths. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-031",
      "type": "multiple-choice",
      "question": "A document edit + permission update workflow is seeing lost updates under concurrent writes. Which transaction/isolation decision is strongest? The fix must keep throughput acceptable at peak.",
      "options": [
        "Rely on client retries to resolve all transactional conflicts safely.",
        "Treat distributed side effects as independent of transaction correctness.",
        "Use optimistic concurrency with version checks on contention-prone rows plus retry policy.",
        "Lower isolation globally to maximize throughput and ignore anomalies."
      ],
      "correct": 2,
      "explanation": "Isolation/transaction strategy should be scoped to invariant-critical paths while keeping side effects safely coordinated.",
      "detailedExplanation": "The decision turns on \"document edit + permission update workflow is seeing lost updates under concurrent\". Eliminate approaches that hand-wave conflict resolution or quorum behavior. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-032",
      "type": "multiple-choice",
      "question": "A subscription renewal + entitlement grant path is seeing write skew across related records. Which transaction/isolation decision is strongest? Rollback semantics should be deterministic for operators.",
      "options": [
        "Treat distributed side effects as independent of transaction correctness.",
        "Use serializable/strong isolation only on invariant-critical transaction boundaries.",
        "Lower isolation globally to maximize throughput and ignore anomalies.",
        "Rely on client retries to resolve all transactional conflicts safely."
      ],
      "correct": 1,
      "explanation": "Isolation/transaction strategy should be scoped to invariant-critical paths while keeping side effects safely coordinated.",
      "detailedExplanation": "Start from \"subscription renewal + entitlement grant path is seeing write skew across related\", then pressure-test the result against the options. Discard choices that violate required invariants during concurrent or failed states. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-033",
      "type": "multiple-choice",
      "question": "A marketplace purchase + seller payout flow is seeing phantom reads in range checks. Which transaction/isolation decision is strongest? The current model assumes rare conflicts that are now frequent.",
      "options": [
        "Apply explicit locking or SELECT FOR UPDATE on shared invariant records.",
        "Lower isolation globally to maximize throughput and ignore anomalies.",
        "Rely on client retries to resolve all transactional conflicts safely.",
        "Treat distributed side effects as independent of transaction correctness."
      ],
      "correct": 0,
      "explanation": "Isolation/transaction strategy should be scoped to invariant-critical paths while keeping side effects safely coordinated.",
      "detailedExplanation": "The key clue in this question is \"marketplace purchase + seller payout flow is seeing phantom reads in range checks\". Discard choices that violate required invariants during concurrent or failed states. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-034",
      "type": "multiple-choice",
      "question": "A fraud hold + transaction commit path is seeing non-repeatable reads in multi-step logic. Which transaction/isolation decision is strongest? Product added a new invariant without storage redesign.",
      "options": [
        "Lower isolation globally to maximize throughput and ignore anomalies.",
        "Rely on client retries to resolve all transactional conflicts safely.",
        "Treat distributed side effects as independent of transaction correctness.",
        "Split critical invariant write path from eventually consistent side effects via outbox pattern."
      ],
      "correct": 3,
      "explanation": "Isolation/transaction strategy should be scoped to invariant-critical paths while keeping side effects safely coordinated.",
      "detailedExplanation": "The core signal here is \"fraud hold + transaction commit path is seeing non-repeatable reads in multi-step logic\". Eliminate approaches that hand-wave conflict resolution or quorum behavior. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        },
        {
          "title": "Google Cloud Storage pricing",
          "url": "https://cloud.google.com/storage/pricing"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-035",
      "type": "multiple-choice",
      "question": "A seat assignment + payment capture flow is seeing partial failure between service boundaries. Which transaction/isolation decision is strongest? Post-incident prevention is required with test coverage.",
      "options": [
        "Rely on client retries to resolve all transactional conflicts safely.",
        "Treat distributed side effects as independent of transaction correctness.",
        "Use saga with compensating actions where distributed 2PC is impractical.",
        "Lower isolation globally to maximize throughput and ignore anomalies."
      ],
      "correct": 2,
      "explanation": "Isolation/transaction strategy should be scoped to invariant-critical paths while keeping side effects safely coordinated.",
      "detailedExplanation": "If you keep \"seat assignment + payment capture flow is seeing partial failure between service\" in view, the correct answer separates faster. Eliminate answers that do not directly address the failure mode, recovery path, or blast radius. Tie the decision to concrete operational outcomes, not abstract reliability language. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-036",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: payment + ledger posting pipeline exhibits non-repeatable reads in multi-step logic. What is the primary diagnosis?",
          "options": [
            "The current transaction design for payment + ledger posting pipeline mismatches non-repeatable reads in multi-step logic, causing correctness risk.",
            "Isolation anomalies are purely observability artifacts with no data impact.",
            "Transaction boundaries do not matter if retries are enabled.",
            "Cross-service partial failures can be ignored if local DB commits succeed."
          ],
          "correct": 0,
          "explanation": "The issue is a transaction/isolation mismatch with domain invariants and failure boundaries.",
          "detailedExplanation": "Start from \"scenario: payment + ledger posting pipeline exhibits non-repeatable reads in multi-step\", then pressure-test the result against the options. Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while preserving throughput?",
          "options": [
            "Force one universal transaction pattern on all workflows regardless invariants.",
            "Disable conflict checks to reduce latency and operational noise.",
            "Accept occasional invariant violations and reconcile manually later.",
            "Apply explicit locking or SELECT FOR UPDATE on shared invariant records."
          ],
          "correct": 3,
          "explanation": "Apply targeted stronger controls where invariants demand them and keep non-critical paths lighter.",
          "detailedExplanation": "The decision turns on \"after confirming diagnosis, what is the strongest next change while preserving\". Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "This prompt is really about \"transactions & Isolation in Distributed Systems\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-037",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: ticket booking reservation path exhibits partial failure between service boundaries. What is the primary diagnosis?",
          "options": [
            "Isolation anomalies are purely observability artifacts with no data impact.",
            "Transaction boundaries do not matter if retries are enabled.",
            "Cross-service partial failures can be ignored if local DB commits succeed.",
            "The current transaction design for ticket booking reservation path mismatches partial failure between service boundaries, causing correctness risk."
          ],
          "correct": 3,
          "explanation": "The issue is a transaction/isolation mismatch with domain invariants and failure boundaries.",
          "detailedExplanation": "The decision turns on \"scenario: ticket booking reservation path exhibits partial failure between service\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under retry storms?",
          "options": [
            "Disable conflict checks to reduce latency and operational noise.",
            "Accept occasional invariant violations and reconcile manually later.",
            "Split critical invariant write path from eventually consistent side effects via outbox pattern.",
            "Force one universal transaction pattern on all workflows regardless invariants."
          ],
          "correct": 2,
          "explanation": "Apply targeted stronger controls where invariants demand them and keep non-critical paths lighter.",
          "detailedExplanation": "Start from \"after confirming diagnosis, what is the strongest next change under retry storms\", then pressure-test the result against the options. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Tie the decision to concrete operational outcomes, not abstract reliability language. Common pitfall: assuming recovery speed without operational proof."
        }
      ],
      "detailedExplanation": "Use \"transactions & Isolation in Distributed Systems\" as your starting point, then verify tradeoffs carefully. Solve this as chained reasoning where stage two must respect stage one assumptions. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-038",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: profile update + audit trail flow exhibits double-spend risk in concurrent debits. What is the primary diagnosis?",
          "options": [
            "Transaction boundaries do not matter if retries are enabled.",
            "Cross-service partial failures can be ignored if local DB commits succeed.",
            "The current transaction design for profile update + audit trail flow mismatches double-spend risk in concurrent debits, causing correctness risk.",
            "Isolation anomalies are purely observability artifacts with no data impact."
          ],
          "correct": 2,
          "explanation": "The issue is a transaction/isolation mismatch with domain invariants and failure boundaries.",
          "detailedExplanation": "Read this as a scenario about \"scenario: profile update + audit trail flow exhibits double-spend risk in concurrent\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change during partial downstream failure?",
          "options": [
            "Accept occasional invariant violations and reconcile manually later.",
            "Use saga with compensating actions where distributed 2PC is impractical.",
            "Force one universal transaction pattern on all workflows regardless invariants.",
            "Disable conflict checks to reduce latency and operational noise."
          ],
          "correct": 1,
          "explanation": "Apply targeted stronger controls where invariants demand them and keep non-critical paths lighter.",
          "detailedExplanation": "The key clue in this question is \"after confirming diagnosis, what is the strongest next change during partial downstream\". Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "Read this as a scenario about \"transactions & Isolation in Distributed Systems\". Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-039",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: multi-service order fulfillment exhibits stale reads before invariant checks. What is the primary diagnosis?",
          "options": [
            "Cross-service partial failures can be ignored if local DB commits succeed.",
            "The current transaction design for multi-service order fulfillment mismatches stale reads before invariant checks, causing correctness risk.",
            "Isolation anomalies are purely observability artifacts with no data impact.",
            "Transaction boundaries do not matter if retries are enabled."
          ],
          "correct": 1,
          "explanation": "The issue is a transaction/isolation mismatch with domain invariants and failure boundaries.",
          "detailedExplanation": "Use \"scenario: multi-service order fulfillment exhibits stale reads before invariant checks\" as your starting point, then verify tradeoffs carefully. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. A strong caching answer names staleness limits, invalidation behavior, and keying strategy. Common pitfall: invalidation races under concurrent writes."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with strict audit requirements?",
          "options": [
            "Enforce idempotency keys on externally retried transactional endpoints.",
            "Force one universal transaction pattern on all workflows regardless invariants.",
            "Disable conflict checks to reduce latency and operational noise.",
            "Accept occasional invariant violations and reconcile manually later."
          ],
          "correct": 0,
          "explanation": "Apply targeted stronger controls where invariants demand them and keep non-critical paths lighter.",
          "detailedExplanation": "The core signal here is \"after confirming diagnosis, what is the strongest next change with strict audit\". Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "The decision turns on \"transactions & Isolation in Distributed Systems\". Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-040",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: cart merge + coupon validation path exhibits deadlock contention at peak load. What is the primary diagnosis?",
          "options": [
            "The current transaction design for cart merge + coupon validation path mismatches deadlock contention at peak load, causing correctness risk.",
            "Isolation anomalies are purely observability artifacts with no data impact.",
            "Transaction boundaries do not matter if retries are enabled.",
            "Cross-service partial failures can be ignored if local DB commits succeed."
          ],
          "correct": 0,
          "explanation": "The issue is a transaction/isolation mismatch with domain invariants and failure boundaries.",
          "detailedExplanation": "The key clue in this question is \"scenario: cart merge + coupon validation path exhibits deadlock contention at peak load\". Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change without overusing global serializable mode?",
          "options": [
            "Force one universal transaction pattern on all workflows regardless invariants.",
            "Disable conflict checks to reduce latency and operational noise.",
            "Accept occasional invariant violations and reconcile manually later.",
            "Promote range-check logic to isolation level that prevents phantom-based violations."
          ],
          "correct": 3,
          "explanation": "Apply targeted stronger controls where invariants demand them and keep non-critical paths lighter.",
          "detailedExplanation": "Read this as a scenario about \"after confirming diagnosis, what is the strongest next change without overusing global\". Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "If you keep \"transactions & Isolation in Distributed Systems\" in view, the correct answer separates faster. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-041",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: wallet debit + notification service exhibits idempotency gaps during retries. What is the primary diagnosis?",
          "options": [
            "Isolation anomalies are purely observability artifacts with no data impact.",
            "Transaction boundaries do not matter if retries are enabled.",
            "Cross-service partial failures can be ignored if local DB commits succeed.",
            "The current transaction design for wallet debit + notification service mismatches idempotency gaps during retries, causing correctness risk."
          ],
          "correct": 3,
          "explanation": "The issue is a transaction/isolation mismatch with domain invariants and failure boundaries.",
          "detailedExplanation": "The core signal here is \"scenario: wallet debit + notification service exhibits idempotency gaps during retries\". Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change during peak contention windows?",
          "options": [
            "Disable conflict checks to reduce latency and operational noise.",
            "Accept occasional invariant violations and reconcile manually later.",
            "Reduce deadlock risk via deterministic lock ordering and smaller transaction scope.",
            "Force one universal transaction pattern on all workflows regardless invariants."
          ],
          "correct": 2,
          "explanation": "Apply targeted stronger controls where invariants demand them and keep non-critical paths lighter.",
          "detailedExplanation": "Use \"after confirming diagnosis, what is the strongest next change during peak contention\" as your starting point, then verify tradeoffs carefully. Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "The core signal here is \"transactions & Isolation in Distributed Systems\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-042",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: shipping allocation + stock decrement flow exhibits cross-service commit ambiguity. What is the primary diagnosis?",
          "options": [
            "Transaction boundaries do not matter if retries are enabled.",
            "Cross-service partial failures can be ignored if local DB commits succeed.",
            "The current transaction design for shipping allocation + stock decrement flow mismatches cross-service commit ambiguity, causing correctness risk.",
            "Isolation anomalies are purely observability artifacts with no data impact."
          ],
          "correct": 2,
          "explanation": "The issue is a transaction/isolation mismatch with domain invariants and failure boundaries.",
          "detailedExplanation": "The decision turns on \"scenario: shipping allocation + stock decrement flow exhibits cross-service commit\". Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with distributed side effects present?",
          "options": [
            "Accept occasional invariant violations and reconcile manually later.",
            "Use transactional outbox to atomically persist state change + event emission intent.",
            "Force one universal transaction pattern on all workflows regardless invariants.",
            "Disable conflict checks to reduce latency and operational noise."
          ],
          "correct": 1,
          "explanation": "Apply targeted stronger controls where invariants demand them and keep non-critical paths lighter.",
          "detailedExplanation": "Start from \"after confirming diagnosis, what is the strongest next change with distributed side\", then pressure-test the result against the options. Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "Use \"transactions & Isolation in Distributed Systems\" as your starting point, then verify tradeoffs carefully. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-043",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: refund orchestration pipeline exhibits lost updates under concurrent writes. What is the primary diagnosis?",
          "options": [
            "Cross-service partial failures can be ignored if local DB commits succeed.",
            "The current transaction design for refund orchestration pipeline mismatches lost updates under concurrent writes, causing correctness risk.",
            "Isolation anomalies are purely observability artifacts with no data impact.",
            "Transaction boundaries do not matter if retries are enabled."
          ],
          "correct": 1,
          "explanation": "The issue is a transaction/isolation mismatch with domain invariants and failure boundaries.",
          "detailedExplanation": "Start from \"scenario: refund orchestration pipeline exhibits lost updates under concurrent writes\", then pressure-test the result against the options. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under cross-service latency variance?",
          "options": [
            "Model invariant ownership to minimize multi-entity cross-service transactions.",
            "Force one universal transaction pattern on all workflows regardless invariants.",
            "Disable conflict checks to reduce latency and operational noise.",
            "Accept occasional invariant violations and reconcile manually later."
          ],
          "correct": 0,
          "explanation": "Apply targeted stronger controls where invariants demand them and keep non-critical paths lighter.",
          "detailedExplanation": "The decision turns on \"after confirming diagnosis, what is the strongest next change under cross-service\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "This prompt is really about \"transactions & Isolation in Distributed Systems\". Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-044",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: quota enforcement + usage write path exhibits write skew across related records. What is the primary diagnosis?",
          "options": [
            "The current transaction design for quota enforcement + usage write path mismatches write skew across related records, causing correctness risk.",
            "Isolation anomalies are purely observability artifacts with no data impact.",
            "Transaction boundaries do not matter if retries are enabled.",
            "Cross-service partial failures can be ignored if local DB commits succeed."
          ],
          "correct": 0,
          "explanation": "The issue is a transaction/isolation mismatch with domain invariants and failure boundaries.",
          "detailedExplanation": "Use \"scenario: quota enforcement + usage write path exhibits write skew across related\" as your starting point, then verify tradeoffs carefully. Solve this as chained reasoning where stage two must respect stage one assumptions. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: interface design coupled too tightly to internal implementation."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while preventing duplicate commits?",
          "options": [
            "Force one universal transaction pattern on all workflows regardless invariants.",
            "Disable conflict checks to reduce latency and operational noise.",
            "Accept occasional invariant violations and reconcile manually later.",
            "Use optimistic concurrency with version checks on contention-prone rows plus retry policy."
          ],
          "correct": 3,
          "explanation": "Apply targeted stronger controls where invariants demand them and keep non-critical paths lighter.",
          "detailedExplanation": "The core signal here is \"after confirming diagnosis, what is the strongest next change while preventing\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "The decision turns on \"transactions & Isolation in Distributed Systems\". Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-045",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: document edit + permission update workflow exhibits phantom reads in range checks. What is the primary diagnosis?",
          "options": [
            "Isolation anomalies are purely observability artifacts with no data impact.",
            "Transaction boundaries do not matter if retries are enabled.",
            "Cross-service partial failures can be ignored if local DB commits succeed.",
            "The current transaction design for document edit + permission update workflow mismatches phantom reads in range checks, causing correctness risk."
          ],
          "correct": 3,
          "explanation": "The issue is a transaction/isolation mismatch with domain invariants and failure boundaries.",
          "detailedExplanation": "Read this as a scenario about \"scenario: document edit + permission update workflow exhibits phantom reads in range\". Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change before broad rollout?",
          "options": [
            "Disable conflict checks to reduce latency and operational noise.",
            "Accept occasional invariant violations and reconcile manually later.",
            "Use serializable/strong isolation only on invariant-critical transaction boundaries.",
            "Force one universal transaction pattern on all workflows regardless invariants."
          ],
          "correct": 2,
          "explanation": "Apply targeted stronger controls where invariants demand them and keep non-critical paths lighter.",
          "detailedExplanation": "The key clue in this question is \"after confirming diagnosis, what is the strongest next change before broad rollout\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "Read this as a scenario about \"transactions & Isolation in Distributed Systems\". Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-046",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: subscription renewal + entitlement grant path exhibits non-repeatable reads in multi-step logic. What is the primary diagnosis?",
          "options": [
            "Transaction boundaries do not matter if retries are enabled.",
            "Cross-service partial failures can be ignored if local DB commits succeed.",
            "The current transaction design for subscription renewal + entitlement grant path mismatches non-repeatable reads in multi-step logic, causing correctness risk.",
            "Isolation anomalies are purely observability artifacts with no data impact."
          ],
          "correct": 2,
          "explanation": "The issue is a transaction/isolation mismatch with domain invariants and failure boundaries.",
          "detailedExplanation": "If you keep \"scenario: subscription renewal + entitlement grant path exhibits non-repeatable reads\" in view, the correct answer separates faster. Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with deterministic rollback needs?",
          "options": [
            "Accept occasional invariant violations and reconcile manually later.",
            "Apply explicit locking or SELECT FOR UPDATE on shared invariant records.",
            "Force one universal transaction pattern on all workflows regardless invariants.",
            "Disable conflict checks to reduce latency and operational noise."
          ],
          "correct": 1,
          "explanation": "Apply targeted stronger controls where invariants demand them and keep non-critical paths lighter.",
          "detailedExplanation": "This prompt is really about \"after confirming diagnosis, what is the strongest next change with deterministic\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "The key clue in this question is \"transactions & Isolation in Distributed Systems\". Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-047",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: marketplace purchase + seller payout flow exhibits partial failure between service boundaries. What is the primary diagnosis?",
          "options": [
            "Cross-service partial failures can be ignored if local DB commits succeed.",
            "The current transaction design for marketplace purchase + seller payout flow mismatches partial failure between service boundaries, causing correctness risk.",
            "Isolation anomalies are purely observability artifacts with no data impact.",
            "Transaction boundaries do not matter if retries are enabled."
          ],
          "correct": 1,
          "explanation": "The issue is a transaction/isolation mismatch with domain invariants and failure boundaries.",
          "detailedExplanation": "This prompt is really about \"scenario: marketplace purchase + seller payout flow exhibits partial failure between\". Solve this as chained reasoning where stage two must respect stage one assumptions. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under strict inventory correctness?",
          "options": [
            "Split critical invariant write path from eventually consistent side effects via outbox pattern.",
            "Force one universal transaction pattern on all workflows regardless invariants.",
            "Disable conflict checks to reduce latency and operational noise.",
            "Accept occasional invariant violations and reconcile manually later."
          ],
          "correct": 0,
          "explanation": "Apply targeted stronger controls where invariants demand them and keep non-critical paths lighter.",
          "detailedExplanation": "If you keep \"after confirming diagnosis, what is the strongest next change under strict inventory\" in view, the correct answer separates faster. Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "Start from \"transactions & Isolation in Distributed Systems\", then pressure-test the result against the options. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-048",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: fraud hold + transaction commit path exhibits double-spend risk in concurrent debits. What is the primary diagnosis?",
          "options": [
            "The current transaction design for fraud hold + transaction commit path mismatches double-spend risk in concurrent debits, causing correctness risk.",
            "Isolation anomalies are purely observability artifacts with no data impact.",
            "Transaction boundaries do not matter if retries are enabled.",
            "Cross-service partial failures can be ignored if local DB commits succeed."
          ],
          "correct": 0,
          "explanation": "The issue is a transaction/isolation mismatch with domain invariants and failure boundaries.",
          "detailedExplanation": "The key clue in this question is \"scenario: fraud hold + transaction commit path exhibits double-spend risk in concurrent\". Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while minimizing lock duration?",
          "options": [
            "Force one universal transaction pattern on all workflows regardless invariants.",
            "Disable conflict checks to reduce latency and operational noise.",
            "Accept occasional invariant violations and reconcile manually later.",
            "Use saga with compensating actions where distributed 2PC is impractical."
          ],
          "correct": 3,
          "explanation": "Apply targeted stronger controls where invariants demand them and keep non-critical paths lighter.",
          "detailedExplanation": "Read this as a scenario about \"after confirming diagnosis, what is the strongest next change while minimizing lock\". Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "If you keep \"transactions & Isolation in Distributed Systems\" in view, the correct answer separates faster. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-049",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: seat assignment + payment capture flow exhibits stale reads before invariant checks. What is the primary diagnosis?",
          "options": [
            "Isolation anomalies are purely observability artifacts with no data impact.",
            "Transaction boundaries do not matter if retries are enabled.",
            "Cross-service partial failures can be ignored if local DB commits succeed.",
            "The current transaction design for seat assignment + payment capture flow mismatches stale reads before invariant checks, causing correctness risk."
          ],
          "correct": 3,
          "explanation": "The issue is a transaction/isolation mismatch with domain invariants and failure boundaries.",
          "detailedExplanation": "The core signal here is \"scenario: seat assignment + payment capture flow exhibits stale reads before invariant\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. A strong caching answer names staleness limits, invalidation behavior, and keying strategy. Common pitfall: hot-key skew causing uneven load."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change during recovery from incident backlog?",
          "options": [
            "Disable conflict checks to reduce latency and operational noise.",
            "Accept occasional invariant violations and reconcile manually later.",
            "Enforce idempotency keys on externally retried transactional endpoints.",
            "Force one universal transaction pattern on all workflows regardless invariants."
          ],
          "correct": 2,
          "explanation": "Apply targeted stronger controls where invariants demand them and keep non-critical paths lighter.",
          "detailedExplanation": "Use \"after confirming diagnosis, what is the strongest next change during recovery from\" as your starting point, then verify tradeoffs carefully. Do not reset assumptions between stages; carry forward prior constraints directly. Tie the decision to concrete operational outcomes, not abstract reliability language. Common pitfall: meeting average goals while missing tail-risk."
        }
      ],
      "detailedExplanation": "The core signal here is \"transactions & Isolation in Distributed Systems\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-050",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: identity verification + account activation flow exhibits deadlock contention at peak load. What is the primary diagnosis?",
          "options": [
            "Transaction boundaries do not matter if retries are enabled.",
            "Cross-service partial failures can be ignored if local DB commits succeed.",
            "The current transaction design for identity verification + account activation flow mismatches deadlock contention at peak load, causing correctness risk.",
            "Isolation anomalies are purely observability artifacts with no data impact."
          ],
          "correct": 2,
          "explanation": "The issue is a transaction/isolation mismatch with domain invariants and failure boundaries.",
          "detailedExplanation": "Start from \"scenario: identity verification + account activation flow exhibits deadlock contention\", then pressure-test the result against the options. Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with bounded operational complexity?",
          "options": [
            "Accept occasional invariant violations and reconcile manually later.",
            "Promote range-check logic to isolation level that prevents phantom-based violations.",
            "Force one universal transaction pattern on all workflows regardless invariants.",
            "Disable conflict checks to reduce latency and operational noise."
          ],
          "correct": 1,
          "explanation": "Apply targeted stronger controls where invariants demand them and keep non-critical paths lighter.",
          "detailedExplanation": "The decision turns on \"after confirming diagnosis, what is the strongest next change with bounded operational\". Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "This prompt is really about \"transactions & Isolation in Distributed Systems\". Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-051",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: campaign publish + cache invalidation path exhibits idempotency gaps during retries. What is the primary diagnosis?",
          "options": [
            "Cross-service partial failures can be ignored if local DB commits succeed.",
            "The current transaction design for campaign publish + cache invalidation path mismatches idempotency gaps during retries, causing correctness risk.",
            "Isolation anomalies are purely observability artifacts with no data impact.",
            "Transaction boundaries do not matter if retries are enabled."
          ],
          "correct": 1,
          "explanation": "The issue is a transaction/isolation mismatch with domain invariants and failure boundaries.",
          "detailedExplanation": "The decision turns on \"scenario: campaign publish + cache invalidation path exhibits idempotency gaps during\". Do not reset assumptions between stages; carry forward prior constraints directly. A strong caching answer names staleness limits, invalidation behavior, and keying strategy. Common pitfall: stale data despite high hit rates."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under mixed criticality operations?",
          "options": [
            "Reduce deadlock risk via deterministic lock ordering and smaller transaction scope.",
            "Force one universal transaction pattern on all workflows regardless invariants.",
            "Disable conflict checks to reduce latency and operational noise.",
            "Accept occasional invariant violations and reconcile manually later."
          ],
          "correct": 0,
          "explanation": "Apply targeted stronger controls where invariants demand them and keep non-critical paths lighter.",
          "detailedExplanation": "Start from \"after confirming diagnosis, what is the strongest next change under mixed criticality\", then pressure-test the result against the options. Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "Use \"transactions & Isolation in Distributed Systems\" as your starting point, then verify tradeoffs carefully. Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-052",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: service-plan upgrade + billing adjustment exhibits cross-service commit ambiguity. What is the primary diagnosis?",
          "options": [
            "The current transaction design for service-plan upgrade + billing adjustment mismatches cross-service commit ambiguity, causing correctness risk.",
            "Isolation anomalies are purely observability artifacts with no data impact.",
            "Transaction boundaries do not matter if retries are enabled.",
            "Cross-service partial failures can be ignored if local DB commits succeed."
          ],
          "correct": 0,
          "explanation": "The issue is a transaction/isolation mismatch with domain invariants and failure boundaries.",
          "detailedExplanation": "The core signal here is \"scenario: service-plan upgrade + billing adjustment exhibits cross-service commit\". Solve this as chained reasoning where stage two must respect stage one assumptions. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while preserving API idempotency?",
          "options": [
            "Force one universal transaction pattern on all workflows regardless invariants.",
            "Disable conflict checks to reduce latency and operational noise.",
            "Accept occasional invariant violations and reconcile manually later.",
            "Use transactional outbox to atomically persist state change + event emission intent."
          ],
          "correct": 3,
          "explanation": "Apply targeted stronger controls where invariants demand them and keep non-critical paths lighter.",
          "detailedExplanation": "Use \"after confirming diagnosis, what is the strongest next change while preserving API\" as your starting point, then verify tradeoffs carefully. Do not reset assumptions between stages; carry forward prior constraints directly. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: interface design coupled too tightly to internal implementation."
        }
      ],
      "detailedExplanation": "The core signal here is \"transactions & Isolation in Distributed Systems\". Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-053",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: batch settlement + reporting close process exhibits lost updates under concurrent writes. What is the primary diagnosis?",
          "options": [
            "Isolation anomalies are purely observability artifacts with no data impact.",
            "Transaction boundaries do not matter if retries are enabled.",
            "Cross-service partial failures can be ignored if local DB commits succeed.",
            "The current transaction design for batch settlement + reporting close process mismatches lost updates under concurrent writes, causing correctness risk."
          ],
          "correct": 3,
          "explanation": "The issue is a transaction/isolation mismatch with domain invariants and failure boundaries.",
          "detailedExplanation": "The key clue in this question is \"scenario: batch settlement + reporting close process exhibits lost updates under\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change during multi-tenant concurrency spikes?",
          "options": [
            "Disable conflict checks to reduce latency and operational noise.",
            "Accept occasional invariant violations and reconcile manually later.",
            "Model invariant ownership to minimize multi-entity cross-service transactions.",
            "Force one universal transaction pattern on all workflows regardless invariants."
          ],
          "correct": 2,
          "explanation": "Apply targeted stronger controls where invariants demand them and keep non-critical paths lighter.",
          "detailedExplanation": "Read this as a scenario about \"after confirming diagnosis, what is the strongest next change during multi-tenant\". Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "If you keep \"transactions & Isolation in Distributed Systems\" in view, the correct answer separates faster. Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-054",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: notification preference + downstream sync flow exhibits write skew across related records. What is the primary diagnosis?",
          "options": [
            "Transaction boundaries do not matter if retries are enabled.",
            "Cross-service partial failures can be ignored if local DB commits succeed.",
            "The current transaction design for notification preference + downstream sync flow mismatches write skew across related records, causing correctness risk.",
            "Isolation anomalies are purely observability artifacts with no data impact."
          ],
          "correct": 2,
          "explanation": "The issue is a transaction/isolation mismatch with domain invariants and failure boundaries.",
          "detailedExplanation": "This prompt is really about \"scenario: notification preference + downstream sync flow exhibits write skew across\". Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with clear compensation semantics?",
          "options": [
            "Accept occasional invariant violations and reconcile manually later.",
            "Use optimistic concurrency with version checks on contention-prone rows plus retry policy.",
            "Force one universal transaction pattern on all workflows regardless invariants.",
            "Disable conflict checks to reduce latency and operational noise."
          ],
          "correct": 1,
          "explanation": "Apply targeted stronger controls where invariants demand them and keep non-critical paths lighter.",
          "detailedExplanation": "If you keep \"after confirming diagnosis, what is the strongest next change with clear compensation\" in view, the correct answer separates faster. Solve this as chained reasoning where stage two must respect stage one assumptions. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "Start from \"transactions & Isolation in Distributed Systems\", then pressure-test the result against the options. Solve this as chained reasoning where stage two must respect stage one assumptions. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-055",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: checkout + inventory workflow exhibits phantom reads in range checks. What is the primary diagnosis?",
          "options": [
            "Cross-service partial failures can be ignored if local DB commits succeed.",
            "The current transaction design for checkout + inventory workflow mismatches phantom reads in range checks, causing correctness risk.",
            "Isolation anomalies are purely observability artifacts with no data impact.",
            "Transaction boundaries do not matter if retries are enabled."
          ],
          "correct": 1,
          "explanation": "The issue is a transaction/isolation mismatch with domain invariants and failure boundaries.",
          "detailedExplanation": "If you keep \"scenario: checkout + inventory workflow exhibits phantom reads in range checks\" in view, the correct answer separates faster. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under constrained database resources?",
          "options": [
            "Use serializable/strong isolation only on invariant-critical transaction boundaries.",
            "Force one universal transaction pattern on all workflows regardless invariants.",
            "Disable conflict checks to reduce latency and operational noise.",
            "Accept occasional invariant violations and reconcile manually later."
          ],
          "correct": 0,
          "explanation": "Apply targeted stronger controls where invariants demand them and keep non-critical paths lighter.",
          "detailedExplanation": "This prompt is really about \"after confirming diagnosis, what is the strongest next change under constrained\". Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "The key clue in this question is \"transactions & Isolation in Distributed Systems\". Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-056",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: payment + ledger posting pipeline exhibits non-repeatable reads in multi-step logic. What is the primary diagnosis?",
          "options": [
            "The current transaction design for payment + ledger posting pipeline mismatches non-repeatable reads in multi-step logic, causing correctness risk.",
            "Isolation anomalies are purely observability artifacts with no data impact.",
            "Transaction boundaries do not matter if retries are enabled.",
            "Cross-service partial failures can be ignored if local DB commits succeed."
          ],
          "correct": 0,
          "explanation": "The issue is a transaction/isolation mismatch with domain invariants and failure boundaries.",
          "detailedExplanation": "Read this as a scenario about \"scenario: payment + ledger posting pipeline exhibits non-repeatable reads in multi-step\". Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while reducing deadlock frequency?",
          "options": [
            "Force one universal transaction pattern on all workflows regardless invariants.",
            "Disable conflict checks to reduce latency and operational noise.",
            "Accept occasional invariant violations and reconcile manually later.",
            "Apply explicit locking or SELECT FOR UPDATE on shared invariant records."
          ],
          "correct": 3,
          "explanation": "Apply targeted stronger controls where invariants demand them and keep non-critical paths lighter.",
          "detailedExplanation": "The key clue in this question is \"after confirming diagnosis, what is the strongest next change while reducing deadlock\". Solve this as chained reasoning where stage two must respect stage one assumptions. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "Read this as a scenario about \"transactions & Isolation in Distributed Systems\". Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-057",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: ticket booking reservation path exhibits partial failure between service boundaries. What is the primary diagnosis?",
          "options": [
            "Isolation anomalies are purely observability artifacts with no data impact.",
            "Transaction boundaries do not matter if retries are enabled.",
            "Cross-service partial failures can be ignored if local DB commits succeed.",
            "The current transaction design for ticket booking reservation path mismatches partial failure between service boundaries, causing correctness risk."
          ],
          "correct": 3,
          "explanation": "The issue is a transaction/isolation mismatch with domain invariants and failure boundaries.",
          "detailedExplanation": "Use \"scenario: ticket booking reservation path exhibits partial failure between service\" as your starting point, then verify tradeoffs carefully. Solve this as chained reasoning where stage two must respect stage one assumptions. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change during schema evolution changes?",
          "options": [
            "Disable conflict checks to reduce latency and operational noise.",
            "Accept occasional invariant violations and reconcile manually later.",
            "Split critical invariant write path from eventually consistent side effects via outbox pattern.",
            "Force one universal transaction pattern on all workflows regardless invariants."
          ],
          "correct": 2,
          "explanation": "Apply targeted stronger controls where invariants demand them and keep non-critical paths lighter.",
          "detailedExplanation": "The core signal here is \"after confirming diagnosis, what is the strongest next change during schema evolution\". Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "The decision turns on \"transactions & Isolation in Distributed Systems\". Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-058",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: profile update + audit trail flow exhibits double-spend risk in concurrent debits. What is the primary diagnosis?",
          "options": [
            "Transaction boundaries do not matter if retries are enabled.",
            "Cross-service partial failures can be ignored if local DB commits succeed.",
            "The current transaction design for profile update + audit trail flow mismatches double-spend risk in concurrent debits, causing correctness risk.",
            "Isolation anomalies are purely observability artifacts with no data impact."
          ],
          "correct": 2,
          "explanation": "The issue is a transaction/isolation mismatch with domain invariants and failure boundaries.",
          "detailedExplanation": "Start from \"scenario: profile update + audit trail flow exhibits double-spend risk in concurrent\", then pressure-test the result against the options. Solve this as chained reasoning where stage two must respect stage one assumptions. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with explicit failure-mode documentation?",
          "options": [
            "Accept occasional invariant violations and reconcile manually later.",
            "Use saga with compensating actions where distributed 2PC is impractical.",
            "Force one universal transaction pattern on all workflows regardless invariants.",
            "Disable conflict checks to reduce latency and operational noise."
          ],
          "correct": 1,
          "explanation": "Apply targeted stronger controls where invariants demand them and keep non-critical paths lighter.",
          "detailedExplanation": "The decision turns on \"after confirming diagnosis, what is the strongest next change with explicit\". Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "This prompt is really about \"transactions & Isolation in Distributed Systems\". Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-059",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: multi-service order fulfillment exhibits stale reads before invariant checks. What is the primary diagnosis?",
          "options": [
            "Cross-service partial failures can be ignored if local DB commits succeed.",
            "The current transaction design for multi-service order fulfillment mismatches stale reads before invariant checks, causing correctness risk.",
            "Isolation anomalies are purely observability artifacts with no data impact.",
            "Transaction boundaries do not matter if retries are enabled."
          ],
          "correct": 1,
          "explanation": "The issue is a transaction/isolation mismatch with domain invariants and failure boundaries.",
          "detailedExplanation": "The decision turns on \"scenario: multi-service order fulfillment exhibits stale reads before invariant checks\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. A strong caching answer names staleness limits, invalidation behavior, and keying strategy. Common pitfall: invalidation races under concurrent writes."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while keeping p99 acceptable?",
          "options": [
            "Enforce idempotency keys on externally retried transactional endpoints.",
            "Force one universal transaction pattern on all workflows regardless invariants.",
            "Disable conflict checks to reduce latency and operational noise.",
            "Accept occasional invariant violations and reconcile manually later."
          ],
          "correct": 0,
          "explanation": "Apply targeted stronger controls where invariants demand them and keep non-critical paths lighter.",
          "detailedExplanation": "Start from \"after confirming diagnosis, what is the strongest next change while keeping p99\", then pressure-test the result against the options. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: assuming recovery speed without operational proof."
        }
      ],
      "detailedExplanation": "Use \"transactions & Isolation in Distributed Systems\" as your starting point, then verify tradeoffs carefully. Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-060",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: cart merge + coupon validation path exhibits deadlock contention at peak load. What is the primary diagnosis?",
          "options": [
            "The current transaction design for cart merge + coupon validation path mismatches deadlock contention at peak load, causing correctness risk.",
            "Isolation anomalies are purely observability artifacts with no data impact.",
            "Transaction boundaries do not matter if retries are enabled.",
            "Cross-service partial failures can be ignored if local DB commits succeed."
          ],
          "correct": 0,
          "explanation": "The issue is a transaction/isolation mismatch with domain invariants and failure boundaries.",
          "detailedExplanation": "If you keep \"scenario: cart merge + coupon validation path exhibits deadlock contention at peak load\" in view, the correct answer separates faster. Solve this as chained reasoning where stage two must respect stage one assumptions. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under controlled canary rollout?",
          "options": [
            "Force one universal transaction pattern on all workflows regardless invariants.",
            "Disable conflict checks to reduce latency and operational noise.",
            "Accept occasional invariant violations and reconcile manually later.",
            "Promote range-check logic to isolation level that prevents phantom-based violations."
          ],
          "correct": 3,
          "explanation": "Apply targeted stronger controls where invariants demand them and keep non-critical paths lighter.",
          "detailedExplanation": "This prompt is really about \"after confirming diagnosis, what is the strongest next change under controlled canary\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "The key clue in this question is \"transactions & Isolation in Distributed Systems\". Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-061",
      "type": "multi-select",
      "question": "When is serializable isolation typically justified? (Select all that apply)",
      "options": [
        "Strict invariant enforcement paths",
        "Double-spend/oversell prevention",
        "All read-only analytics paths",
        "Regulatory-critical correctness boundaries"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Serializable isolation is expensive and should be focused on high-value correctness paths.",
      "detailedExplanation": "Start from \"serializable isolation typically justified? (Select all that apply)\", then pressure-test the result against the options. Avoid pattern guessing and evaluate each candidate directly against the scenario. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-062",
      "type": "multi-select",
      "question": "Which are classic isolation anomalies? (Select all that apply)",
      "options": [
        "Lost update",
        "Write skew",
        "Guaranteed deterministic ordering everywhere",
        "Phantom reads"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Lost updates, write skew, and phantoms are common anomalies under weaker isolation.",
      "detailedExplanation": "The decision turns on \"classic isolation anomalies? (Select all that apply)\". Validate each option independently; do not select statements that are only partially true. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-063",
      "type": "multi-select",
      "question": "Distributed transaction alternatives to 2PC often include which? (Select all that apply)",
      "options": [
        "Saga with compensating actions",
        "Transactional outbox",
        "Blind eventual retries without idempotency",
        "Idempotent command handling"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Sagas/outbox/idempotency are practical patterns for cross-service consistency.",
      "detailedExplanation": "Read this as a scenario about \"distributed transaction alternatives to 2PC often include which? (Select all that apply)\". Treat every option as a separate true/false test under the same constraints. Throughput is only one part; replay behavior and consumer lag handling matter equally. Common pitfall: assuming exactly-once without idempotency.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-064",
      "type": "multi-select",
      "question": "To reduce deadlocks, which practices help? (Select all that apply)",
      "options": [
        "Consistent lock acquisition order",
        "Keep transactions short",
        "Acquire locks in random order to spread contention",
        "Reduce touched rows per transaction"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Deterministic ordering and smaller scopes reduce deadlock probability.",
      "detailedExplanation": "Use \"to reduce deadlocks, which practices help? (Select all that apply)\" as your starting point, then verify tradeoffs carefully. Avoid pattern guessing and evaluate each candidate directly against the scenario. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-065",
      "type": "multi-select",
      "question": "Idempotency is especially important for which cases? (Select all that apply)",
      "options": [
        "Client retries after timeouts",
        "At-least-once message delivery",
        "Single in-memory local operation only",
        "External callback replays"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Idempotency protects correctness when duplicate attempts occur.",
      "detailedExplanation": "This prompt is really about \"idempotency is especially important for which cases? (Select all that apply)\". Treat every option as a separate true/false test under the same constraints. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-066",
      "type": "multi-select",
      "question": "Outbox pattern helps with which guarantees? (Select all that apply)",
      "options": [
        "State change and event intent persist atomically",
        "Avoiding dual-write race between DB and broker",
        "Global total order of all events",
        "Reliable async publication with replay"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Outbox addresses dual-write safety and reliable event publication.",
      "detailedExplanation": "If you keep \"outbox pattern helps with which guarantees? (Select all that apply)\" in view, the correct answer separates faster. Avoid pattern guessing and evaluate each candidate directly against the scenario. A good message-system answer defines guarantees clearly for both producer and consumer paths. Common pitfall: ordering loss during partition or replay changes.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-067",
      "type": "multi-select",
      "question": "Signs that isolation is too weak include which? (Select all that apply)",
      "options": [
        "Intermittent invariant violations under concurrency",
        "Frequent reconciliation corrections",
        "Consistent correctness under load tests",
        "Race-condition bug reports tied to peak traffic"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Weak isolation often surfaces as intermittent yet expensive correctness failures.",
      "detailedExplanation": "The core signal here is \"signs that isolation is too weak include which? (Select all that apply)\". Treat every option as a separate true/false test under the same constraints. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-068",
      "type": "multi-select",
      "question": "When may weaker isolation be acceptable? (Select all that apply)",
      "options": [
        "Non-critical derived data paths",
        "Read-only analytics with tolerance for minor staleness",
        "Hard financial invariants",
        "Workflows with compensating controls and bounded impact"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Weaker isolation can work where business impact of anomalies is limited and controlled.",
      "detailedExplanation": "The key clue in this question is \"may weaker isolation be acceptable? (Select all that apply)\". Avoid pattern guessing and evaluate each candidate directly against the scenario. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-069",
      "type": "multi-select",
      "question": "Which controls protect against write skew? (Select all that apply)",
      "options": [
        "Serializable isolation or equivalent checks",
        "Materialized constraint locks/check rows",
        "Ignoring concurrent predicate reads",
        "Application-level invariant revalidation before commit"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Write skew requires predicate-aware or invariant-aware protections.",
      "detailedExplanation": "Start from \"controls protect against write skew? (Select all that apply)\", then pressure-test the result against the options. Validate each option independently; do not select statements that are only partially true. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-070",
      "type": "multi-select",
      "question": "Good saga design practices include which? (Select all that apply)",
      "options": [
        "Explicit compensation for each step",
        "Clear timeout and retry semantics",
        "Assume compensation can never fail",
        "Persist saga state transitions durably"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Sagas need durable progress tracking and explicit compensation strategy.",
      "detailedExplanation": "The core signal here is \"good saga design practices include which? (Select all that apply)\". Treat every option as a separate true/false test under the same constraints. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-071",
      "type": "multi-select",
      "question": "For cross-service correctness, useful patterns include which? (Select all that apply)",
      "options": [
        "Idempotent commands/events",
        "Versioned state transitions",
        "Ad hoc side effects outside transaction model",
        "Ownership boundaries minimizing distributed writes"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Robust distributed correctness comes from explicit boundaries and replay-safe semantics.",
      "detailedExplanation": "If you keep \"for cross-service correctness, useful patterns include which? (Select all that apply)\" in view, the correct answer separates faster. Avoid pattern guessing and evaluate each candidate directly against the scenario. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-072",
      "type": "multi-select",
      "question": "Which metrics are useful for transaction/isolation health? (Select all that apply)",
      "options": [
        "Conflict retry rate",
        "Deadlock count",
        "Only average CPU",
        "Invariant-violation incident rate"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Conflict, deadlock, and invariant metrics reveal isolation effectiveness.",
      "detailedExplanation": "This prompt is really about \"metrics are useful for transaction/isolation health? (Select all that apply)\". Avoid pattern guessing and evaluate each candidate directly against the scenario. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-073",
      "type": "multi-select",
      "question": "When using optimistic concurrency, which are required? (Select all that apply)",
      "options": [
        "Version/timestamp compare on write",
        "Retry strategy for conflicts",
        "Guaranteed zero conflicts by design",
        "Bounded retry/backoff policy"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "OCC requires conflict detection and safe retry behavior.",
      "detailedExplanation": "Use \"using optimistic concurrency, which are required? (Select all that apply)\" as your starting point, then verify tradeoffs carefully. Validate each option independently; do not select statements that are only partially true. The strongest answer explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Retry pattern",
          "url": "https://learn.microsoft.com/en-us/azure/architecture/patterns/retry"
        }
      ]
    },
    {
      "id": "cc-ti-074",
      "type": "multi-select",
      "question": "Common 2PC concerns in high-scale systems include which? (Select all that apply)",
      "options": [
        "Coordinator availability sensitivity",
        "Increased latency/lock duration",
        "Automatic elimination of partial failures",
        "Operational complexity under partitions"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "2PC can improve atomicity but at significant availability/latency complexity costs.",
      "detailedExplanation": "Read this as a scenario about \"common 2PC concerns in high-scale systems include which? (Select all that apply)\". Avoid pattern guessing and evaluate each candidate directly against the scenario. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-075",
      "type": "multi-select",
      "question": "To keep transaction scope healthy, which tactics help? (Select all that apply)",
      "options": [
        "Minimize work inside transaction",
        "Avoid external calls in transaction boundary",
        "Combine unrelated writes in one giant transaction",
        "Precompute non-critical data outside critical path"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Smaller, focused transactions reduce contention and failure blast radius.",
      "detailedExplanation": "The decision turns on \"to keep transaction scope healthy, which tactics help? (Select all that apply)\". Validate each option independently; do not select statements that are only partially true. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-076",
      "type": "multi-select",
      "question": "Which anti-patterns commonly create isolation bugs? (Select all that apply)",
      "options": [
        "Assuming retries imply correctness",
        "Undocumented isolation assumptions",
        "Explicit invariant tests in CI load scenarios",
        "Mixing critical and non-critical writes without boundary"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Implicit assumptions and boundary blur are common root causes.",
      "detailedExplanation": "Start from \"anti-patterns commonly create isolation bugs? (Select all that apply)\", then pressure-test the result against the options. Validate each option independently; do not select statements that are only partially true. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-077",
      "type": "multi-select",
      "question": "Rollback/compensation quality improves with which? (Select all that apply)",
      "options": [
        "Deterministic compensating commands",
        "Observable saga state transitions",
        "Best-effort undocumented manual fixes only",
        "Idempotent compensation execution"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Compensation must be explicit, observable, and replay-safe.",
      "detailedExplanation": "The key clue in this question is \"rollback/compensation quality improves with which? (Select all that apply)\". Avoid pattern guessing and evaluate each candidate directly against the scenario. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-078",
      "type": "numeric-input",
      "question": "A service processes 1,800,000 tx/day. Conflict retry rate is 1.4%. Retries/day?",
      "answer": 25200,
      "unit": "transactions",
      "tolerance": 0.03,
      "explanation": "0.014 * 1,800,000 = 25,200.",
      "detailedExplanation": "The core signal here is \"service processes 1,800,000 tx/day\". Write the unit conversion path explicitly, then calculate, then sanity-check magnitude. The strongest answer explains how failure mode, mitigation speed, and blast radius interact. Numbers such as 1,800 and 000 should be normalized first so downstream reasoning stays consistent. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Retry pattern",
          "url": "https://learn.microsoft.com/en-us/azure/architecture/patterns/retry"
        }
      ]
    },
    {
      "id": "cc-ti-079",
      "type": "numeric-input",
      "question": "Deadlock incidents are 72/day; each costs 35s to recover. Total deadlock recovery minutes/day?",
      "answer": 42,
      "unit": "minutes",
      "tolerance": 0.05,
      "explanation": "72*35 = 2,520 seconds = 42 minutes.",
      "detailedExplanation": "If you keep \"deadlock incidents are 72/day\" in view, the correct answer separates faster. Write the unit conversion path explicitly, then calculate, then sanity-check magnitude. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Numbers such as 72 and 35s should be normalized first so downstream reasoning stays consistent. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-080",
      "type": "numeric-input",
      "question": "Outbox publisher drains 9,000 events/min. Backlog is 540,000 events. Minutes to drain (no new events)?",
      "answer": 60,
      "unit": "minutes",
      "tolerance": 0,
      "explanation": "540,000 / 9,000 = 60 minutes.",
      "detailedExplanation": "The decision turns on \"outbox publisher drains 9,000 events/min\". Normalize units before computing so conversion mistakes do not propagate. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. If values like 9,000 and 540,000 appear, convert them into one unit basis before comparison. Common pitfall: assuming exactly-once without idempotency.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-081",
      "type": "numeric-input",
      "question": "A critical endpoint has 95,000 req/hour. Duplicate callback rate is 0.6%. Duplicate attempts/hour?",
      "answer": 570,
      "unit": "requests",
      "tolerance": 0.03,
      "explanation": "0.006 * 95,000 = 570.",
      "detailedExplanation": "Read this as a scenario about \"critical endpoint has 95,000 req/hour\". Keep every transformation in one unit system and check order of magnitude at the end. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Keep quantities like 95,000 and 0.6 in aligned units before selecting an answer. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-082",
      "type": "numeric-input",
      "question": "Transaction p99 is 280ms. Lock-delay time contributes 95ms. What percent of p99 is lock-delay time?",
      "answer": 33.93,
      "unit": "%",
      "tolerance": 0.3,
      "explanation": "95 / 280 = 33.93%.",
      "detailedExplanation": "The key clue in this question is \"transaction p99 is 280ms\". Normalize units before computing so conversion mistakes do not propagate. Tie the decision to concrete operational outcomes, not abstract reliability language. If values like 280ms and 95ms appear, convert them into one unit basis before comparison. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "Percentile",
          "url": "https://en.wikipedia.org/wiki/Percentile"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-083",
      "type": "numeric-input",
      "question": "A saga has 5 steps with independent 99.5% success each. Approximate end-to-end success probability (%)?",
      "answer": 97.52,
      "unit": "%",
      "tolerance": 0.2,
      "explanation": "0.995^5 = 0.9752 (97.52%).",
      "detailedExplanation": "Start from \"saga has 5 steps with independent 99\", then pressure-test the result against the options. Normalize units before computing so conversion mistakes do not propagate. Consistency decisions should be explicit about which conflicts are acceptable and why. If values like 5 and 99.5 appear, convert them into one unit basis before comparison. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-084",
      "type": "numeric-input",
      "question": "Inventory check allows 120ms budget; current serializable transaction adds 45ms over baseline. Remaining budget?",
      "answer": 75,
      "unit": "ms",
      "tolerance": 0,
      "explanation": "120 - 45 = 75ms remaining.",
      "detailedExplanation": "If you keep \"inventory check allows 120ms budget\" in view, the correct answer separates faster. Keep every transformation in one unit system and check order of magnitude at the end. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Keep quantities like 120ms and 45ms in aligned units before selecting an answer. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-085",
      "type": "numeric-input",
      "question": "A lock hotspot key sees 6,600 attempts/min, 15% blocked >1s. Blocked attempts/min?",
      "answer": 990,
      "unit": "attempts",
      "tolerance": 0.02,
      "explanation": "0.15 * 6,600 = 990.",
      "detailedExplanation": "The core signal here is \"lock hotspot key sees 6,600 attempts/min, 15% blocked >1s\". Write the unit conversion path explicitly, then calculate, then sanity-check magnitude. Consistency decisions should be explicit about which conflicts are acceptable and why. Numbers such as 6,600 and 15 should be normalized first so downstream reasoning stays consistent. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-086",
      "type": "numeric-input",
      "question": "Compensation workflow resolves 92% automatically out of 25,000 failed sagas/day. Manual interventions/day?",
      "answer": 2000,
      "unit": "sagas",
      "tolerance": 0.03,
      "explanation": "8% of 25,000 = 2,000.",
      "detailedExplanation": "Use \"compensation workflow resolves 92% automatically out of 25,000 failed sagas/day\" as your starting point, then verify tradeoffs carefully. Write the unit conversion path explicitly, then calculate, then sanity-check magnitude. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Numbers such as 92 and 25,000 should be normalized first so downstream reasoning stays consistent. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-087",
      "type": "numeric-input",
      "question": "If 18% of operations require strict isolation out of 140,000 ops/min, strict-isolation ops/min?",
      "answer": 25200,
      "unit": "ops/min",
      "tolerance": 0.02,
      "explanation": "0.18 * 140,000 = 25,200.",
      "detailedExplanation": "This prompt is really about \"if 18% of operations require strict isolation out of 140,000 ops/min, strict-isolation\". Keep every transformation in one unit system and check order of magnitude at the end. Strong answers connect quorum/coordination settings to concrete correctness goals. Keep quantities like 18 and 140,000 in aligned units before selecting an answer. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-088",
      "type": "numeric-input",
      "question": "A transaction path costs $0.00045 per call at 2,400,000 calls/day. Daily cost?",
      "answer": 1080,
      "unit": "USD",
      "tolerance": 0.02,
      "explanation": "2,400,000 * 0.00045 = $1,080.",
      "detailedExplanation": "The decision turns on \"transaction path costs $0\". Normalize units before computing so conversion mistakes do not propagate. Strong answers connect quorum/coordination settings to concrete correctness goals. If values like 0.00045 and 2,400 appear, convert them into one unit basis before comparison. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-089",
      "type": "numeric-input",
      "question": "Write skew incidents dropped from 480/day to 96/day after isolation change. Percent reduction?",
      "answer": 80,
      "unit": "%",
      "tolerance": 0.2,
      "explanation": "(480-96)/480 = 80%.",
      "detailedExplanation": "Read this as a scenario about \"write skew incidents dropped from 480/day to 96/day after isolation change\". Write the unit conversion path explicitly, then calculate, then sanity-check magnitude. Strong answers connect quorum/coordination settings to concrete correctness goals. Numbers such as 480 and 96 should be normalized first so downstream reasoning stays consistent. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-090",
      "type": "ordering",
      "question": "Order a transaction design flow for invariant-critical paths.",
      "items": [
        "Define invariant boundary",
        "Choose isolation/concurrency control",
        "Implement retries/compensation semantics",
        "Validate under contention tests"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Start with invariant definition, then enforce and validate.",
      "detailedExplanation": "Start from \"order a transaction design flow for invariant-critical paths\", then pressure-test the result against the options. Place obvious extremes first, then sort the middle by pairwise comparison. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-091",
      "type": "ordering",
      "question": "Order by increasing isolation strength (typical).",
      "items": [
        "Read committed",
        "Repeatable read",
        "Snapshot isolation",
        "Serializable"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Guarantee strength and cost generally rise together.",
      "detailedExplanation": "The key clue in this question is \"order by increasing isolation strength (typical)\". Build the rank from biggest differences first, then refine with adjacent checks. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-092",
      "type": "ordering",
      "question": "Order deadlock mitigation steps from immediate to structural.",
      "items": [
        "Retry with backoff",
        "Enforce lock acquisition order",
        "Reduce transaction scope",
        "Refactor data ownership boundaries"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Quick operational mitigation first, structural fixes next.",
      "detailedExplanation": "Read this as a scenario about \"order deadlock mitigation steps from immediate to structural\". Place obvious extremes first, then sort the middle by pairwise comparison. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-093",
      "type": "ordering",
      "question": "Order distributed transaction fallback maturity.",
      "items": [
        "Ad hoc manual compensation",
        "Documented compensation scripts",
        "Saga state machine with durable log",
        "Saga with tests/alerts and replay safety"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Maturity increases with explicit automation and validation.",
      "detailedExplanation": "The decision turns on \"order distributed transaction fallback maturity\". Place obvious extremes first, then sort the middle by pairwise comparison. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-094",
      "type": "ordering",
      "question": "Order by increasing risk of invariant violation.",
      "items": [
        "Serializable critical section",
        "OCC with strict version checks",
        "Weak isolation with periodic reconcile",
        "Uncoordinated eventually consistent writes"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Risk grows as correctness constraints weaken.",
      "detailedExplanation": "This prompt is really about \"order by increasing risk of invariant violation\". Place obvious extremes first, then sort the middle by pairwise comparison. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-095",
      "type": "ordering",
      "question": "Order dual-write safety patterns from weakest to strongest.",
      "items": [
        "DB write then best-effort event publish",
        "Retry publish on failure",
        "Transactional outbox + relay",
        "Outbox + idempotent consumer + replay audit"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Outbox + idempotency + audit provides strongest practical safety.",
      "detailedExplanation": "Use \"order dual-write safety patterns from weakest to strongest\" as your starting point, then verify tradeoffs carefully. Order by relative scale and bottleneck effect, then validate neighboring items. Throughput is only one part; replay behavior and consumer lag handling matter equally. Common pitfall: ordering loss during partition or replay changes.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-096",
      "type": "ordering",
      "question": "Order by increasing throughput impact (typical).",
      "items": [
        "Narrow strict path + broad eventual side effects",
        "Entity-tiered tunable isolation",
        "Large serializable transaction scope",
        "Global synchronous distributed transaction"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Broader strict coordination generally reduces throughput.",
      "detailedExplanation": "The core signal here is \"order by increasing throughput impact (typical)\". Build the rank from biggest differences first, then refine with adjacent checks. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-097",
      "type": "ordering",
      "question": "Order rollback handling robustness.",
      "items": [
        "Manual rollback notes",
        "Scripted rollback per service",
        "Coordinated compensation workflow",
        "Tested compensation workflow with observability"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Robustness improves with automation, coordination, and testing.",
      "detailedExplanation": "If you keep \"order rollback handling robustness\" in view, the correct answer separates faster. Build the rank from biggest differences first, then refine with adjacent checks. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-098",
      "type": "ordering",
      "question": "Order by strongest evidence for isolation tuning success.",
      "items": [
        "Lower average latency only",
        "Lower conflict retries",
        "Lower invariant violation incidents",
        "Lower violations with stable latency/cost under load tests"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Success must include correctness and operational trade-offs.",
      "detailedExplanation": "Start from \"order by strongest evidence for isolation tuning success\", then pressure-test the result against the options. Place obvious extremes first, then sort the middle by pairwise comparison. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-099",
      "type": "ordering",
      "question": "Order migration safety for transaction-boundary changes.",
      "items": [
        "Canary path",
        "Shadow invariant checks",
        "Progressive expansion",
        "Post-rollout regression guardrails"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Staged rollout with shadow checks lowers migration risk.",
      "detailedExplanation": "The key clue in this question is \"order migration safety for transaction-boundary changes\". Order by relative scale and bottleneck effect, then validate neighboring items. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-ti-100",
      "type": "ordering",
      "question": "Order by increasing operational complexity.",
      "items": [
        "Single DB local transaction",
        "Cross-service idempotent workflow",
        "Saga orchestration with compensation",
        "Distributed consensus-backed transaction coordination"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Cross-service coordination increases complexity and cost.",
      "detailedExplanation": "Read this as a scenario about \"order by increasing operational complexity\". Order by relative scale and bottleneck effect, then validate neighboring items. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    }
  ]
}
