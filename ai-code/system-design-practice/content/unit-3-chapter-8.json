{
  "unit": 3,
  "unitTitle": "API Design",
  "chapter": 8,
  "chapterTitle": "API Design Scenarios",
  "chapterDescription": "Integrative scenarios combining REST design, pagination, rate limiting, versioning, error handling, and paradigm selection.",
  "problems": [
    {
      "id": "api-001",
      "type": "two-stage",
      "question": "You're designing a public API for an e-commerce platform. Third-party developers will build apps showing product catalogs.",
      "stages": [
        {
          "question": "What's the most important API design consideration?",
          "options": [
            "Clear documentation and predictable behavior",
            "Maximum performance",
            "GraphQL for flexibility",
            "Minimal endpoints"
          ],
          "correct": 0,
          "explanation": "For public APIs, developer experience is paramount. Clear docs, consistent conventions, and predictable behavior enable third parties to integrate successfully.",
          "detailedExplanation": "For public APIs, developer experience is paramount. Clear docs, consistent conventions, and predictable behavior enable third parties to integrate successfully. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "How should you handle breaking changes?",
          "options": [
            "Version the API and maintain old versions during migration",
            "Update all endpoints and notify developers",
            "Use feature flags",
            "Avoid changes entirely"
          ],
          "correct": 0,
          "explanation": "Public APIs need versioning strategy. Maintain old versions, give deprecation warnings, and provide migration guides to avoid breaking third-party apps.",
          "detailedExplanation": "Public APIs need versioning strategy. Maintain old versions, give deprecation warnings, and provide migration guides to avoid breaking third-party apps. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-002",
      "type": "two-stage",
      "question": "A mobile banking app needs to display account balances, recent transactions, and pending payments on the home screen.",
      "stages": [
        {
          "question": "What's the primary API design concern for mobile?",
          "options": [
            "Minimize requests and payload size",
            "Use WebSocket for all data",
            "Return all data in one giant response",
            "Use GraphQL exclusively"
          ],
          "correct": 0,
          "explanation": "Mobile has limited bandwidth and battery. Minimize round trips (aggregate endpoints or GraphQL) and keep payloads small (only needed fields).",
          "detailedExplanation": "Mobile has limited bandwidth and battery. Minimize round trips (aggregate endpoints or GraphQL) and keep payloads small (only needed fields). Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "How should you design the home screen endpoint?",
          "options": [
            "Single endpoint returning aggregated data for the screen",
            "Three separate endpoints called in parallel",
            "WebSocket subscription for all data",
            "Long polling for updates"
          ],
          "correct": 0,
          "explanation": "A BFF-style endpoint returning exactly what the home screen needs reduces latency and simplifies the mobile client.",
          "detailedExplanation": "A BFF-style endpoint returning exactly what the home screen needs reduces latency and simplifies the mobile client. Convert targets into concrete counts and time budgets first, then reason about whether incident frequency and recovery time can satisfy them."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-003",
      "type": "multi-select",
      "question": "You're designing a payment processing API. Which are critical requirements?",
      "options": [
        "Idempotency keys for all mutations",
        "Detailed audit logging",
        "Synchronous confirmation before returning",
        "Maximum throughput optimization"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "Payment APIs need idempotency (prevent double charges), audit trails (compliance), and synchronous confirmation (users need to know payment succeeded). Throughput matters but correctness comes first.",
      "detailedExplanation": "Payment APIs need idempotency (prevent double charges), audit trails (compliance), and synchronous confirmation (users need to know payment succeeded). Throughput matters but correctness comes first. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-004",
      "type": "two-stage",
      "question": "Your payment API receives a request, processes the payment, but the response times out before reaching the client.",
      "stages": [
        {
          "question": "What happens when the client retries with the same idempotency key?",
          "options": [
            "Server returns the original successful response",
            "Payment is processed again",
            "Server returns an error",
            "Request is queued"
          ],
          "correct": 0,
          "explanation": "With idempotency keys, the server recognizes the retry and returns the stored response from the original successful payment.",
          "detailedExplanation": "With idempotency keys, the server recognizes the retry and returns the stored response from the original successful payment. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "How long should idempotency keys be stored?",
          "options": [
            "Long enough to cover retry windows (24-48 hours typical)",
            "Forever",
            "5 minutes",
            "Until the next request"
          ],
          "correct": 0,
          "explanation": "Store long enough for reasonable retry scenarios but not forever (storage costs). 24-48 hours covers most legitimate retry patterns.",
          "detailedExplanation": "Store long enough for reasonable retry scenarios but not forever (storage costs). 24-48 hours covers most legitimate retry patterns. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-005",
      "type": "ordering",
      "question": "Order these steps for designing a new public API:",
      "items": [
        "Define use cases and requirements",
        "Design resource model and endpoints",
        "Write OpenAPI specification",
        "Implement and test",
        "Document and publish"
      ],
      "correctOrder": [0, 1, 2, 3, 4],
      "explanation": "Start with requirements, design the API contract, formalize it (OpenAPI), implement against the spec, then document for consumers.",
      "detailedExplanation": "Start with requirements, design the API contract, formalize it (OpenAPI), implement against the spec, then document for consumers. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-006",
      "type": "two-stage",
      "question": "You're building an API for a social media platform. Users can post content, follow others, and see a personalized feed.",
      "stages": [
        {
          "question": "How should the feed endpoint handle pagination?",
          "options": [
            "Cursor-based pagination with timestamps or IDs",
            "Page numbers",
            "Offset/limit",
            "Return all items"
          ],
          "correct": 0,
          "explanation": "Feeds change constantly. Cursor-based pagination (using post ID or timestamp) maintains consistency even as new posts appear.",
          "detailedExplanation": "Feeds change constantly. Cursor-based pagination (using post ID or timestamp) maintains consistency even as new posts appear. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "A user scrolls their feed, new posts are added at the top. How should the API handle this?",
          "options": [
            "Client uses cursor to fetch stable pages, separately polls for new count",
            "Automatically insert new posts in response",
            "Invalidate all cached pages",
            "Use WebSocket only"
          ],
          "correct": 0,
          "explanation": "Cursor-based pagination returns stable results. A separate endpoint or header can indicate new posts available, letting the client decide when to refresh.",
          "detailedExplanation": "Cursor-based pagination returns stable results. A separate endpoint or header can indicate new posts available, letting the client decide when to refresh. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-007",
      "type": "multiple-choice",
      "question": "A social media API needs to return posts with author info, like counts, and comment previews. What's the best approach?",
      "options": [
        "Include embedded data with expansion parameters",
        "Require separate requests for each piece",
        "Always return everything",
        "Use GraphQL exclusively"
      ],
      "correct": 0,
      "explanation": "Provide expansion parameters (e.g., ?expand=author,comments) so clients can request related data in one call when needed, avoiding both over-fetching and under-fetching.",
      "detailedExplanation": "Provide expansion parameters (e.g., ?expand=author,comments) so clients can request related data in one call when needed, avoiding both over-fetching and under-fetching. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-008",
      "type": "two-stage",
      "question": "Your API serves both a web dashboard (needs lots of data) and a mobile app (needs minimal data).",
      "stages": [
        {
          "question": "What architectural pattern addresses this?",
          "options": [
            "Backend for Frontend (BFF) or field selection",
            "Single endpoint for all clients",
            "Separate APIs with duplicated logic",
            "Force all clients to use full responses"
          ],
          "correct": 0,
          "explanation": "BFF provides client-specific endpoints, or field selection (?fields=id,name) lets clients specify what they need. Both avoid over-fetching.",
          "detailedExplanation": "BFF provides client-specific endpoints, or field selection (?fields=id,name) lets clients specify what they need. Both avoid over-fetching. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "When would GraphQL be a better solution than BFFs?",
          "options": [
            "When client requirements vary frequently and unpredictably",
            "When all clients need the same data",
            "When caching is critical",
            "When the team is new to GraphQL"
          ],
          "correct": 0,
          "explanation": "GraphQL's flexibility shines when different clients have varying, evolving needs. It shifts query composition to clients without backend changes.",
          "detailedExplanation": "GraphQL's flexibility shines when different clients have varying, evolving needs. It shifts query composition to clients without backend changes. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-009",
      "type": "multi-select",
      "question": "You're designing an API for a multi-tenant SaaS application. What tenant isolation concerns apply?",
      "options": [
        "Tenant ID in every request (header or path)",
        "Data filtering at query level",
        "Rate limits per tenant",
        "Separate databases per tenant"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "Tenant identification, data filtering, and per-tenant rate limits are essential. Separate databases are one implementation choice, not an API design requirement.",
      "detailedExplanation": "Tenant identification, data filtering, and per-tenant rate limits are essential. Separate databases are one implementation choice, not an API design requirement. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-010",
      "type": "two-stage",
      "question": "Your multi-tenant API accidentally returned data from tenant A to tenant B due to a bug.",
      "stages": [
        {
          "question": "What API design could have prevented this?",
          "options": [
            "Enforce tenant ID at middleware level before reaching handlers",
            "Trust application code to filter correctly",
            "Use separate endpoints per tenant",
            "Encrypt all responses"
          ],
          "correct": 0,
          "explanation": "Tenant isolation should be enforced at the infrastructure/middleware layer, not left to individual handlers. Defense in depth prevents bugs from causing data leaks.",
          "detailedExplanation": "Tenant isolation should be enforced at the infrastructure/middleware layer, not left to individual handlers. Defense in depth prevents bugs from causing data leaks. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "How should tenant context be passed in requests?",
          "options": [
            "Derived from authentication token, not client-supplied",
            "Query parameter",
            "Request body field",
            "Client chooses any tenant"
          ],
          "correct": 0,
          "explanation": "Derive tenant from the authenticated identity. Never trust client-supplied tenant IDs for authorization—that enables cross-tenant access.",
          "detailedExplanation": "Derive tenant from the authenticated identity. Never trust client-supplied tenant IDs for authorization—that enables cross-tenant access. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-011",
      "type": "multiple-choice",
      "question": "A ride-sharing app needs real-time driver location updates. What's the best API approach?",
      "options": [
        "WebSocket for continuous location streaming",
        "Polling every second",
        "Server-Sent Events",
        "Long polling"
      ],
      "correct": 0,
      "explanation": "WebSocket provides efficient bidirectional communication for high-frequency updates. The driver sends location updates, passengers receive them in real-time.",
      "detailedExplanation": "WebSocket provides efficient bidirectional communication for high-frequency updates. The driver sends location updates, passengers receive them in real-time. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "RFC 6455: The WebSocket Protocol",
          "url": "https://www.rfc-editor.org/rfc/rfc6455"
        }
      ]
    },
    {
      "id": "api-012",
      "type": "two-stage",
      "question": "You're designing the API for ride-sharing driver locations. Thousands of drivers send updates every few seconds.",
      "stages": [
        {
          "question": "What's the main scalability challenge?",
          "options": [
            "Managing thousands of persistent WebSocket connections",
            "Database write throughput",
            "Response payload size",
            "API versioning"
          ],
          "correct": 0,
          "explanation": "Each driver maintains a persistent connection. Scaling to thousands requires careful connection management, load balancing, and possibly connection state distribution.",
          "detailedExplanation": "Each driver maintains a persistent connection. Scaling to thousands requires careful connection management, load balancing, and possibly connection state distribution. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "How should you architect the location update system?",
          "options": [
            "Pub/sub system (Redis/Kafka) behind WebSocket servers",
            "Direct database writes from each connection",
            "Queue all updates for batch processing",
            "In-memory only, no persistence"
          ],
          "correct": 0,
          "explanation": "A pub/sub system decouples WebSocket servers from consumers. Location updates are published, and interested parties (passenger apps) subscribe to relevant drivers.",
          "detailedExplanation": "A pub/sub system decouples WebSocket servers from consumers. Location updates are published, and interested parties (passenger apps) subscribe to relevant drivers. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-013",
      "type": "ordering",
      "question": "Order these real-time technologies by implementation complexity (simplest to most complex):",
      "items": [
        "Polling",
        "Long polling",
        "Server-Sent Events",
        "WebSocket",
        "gRPC streaming"
      ],
      "correctOrder": [0, 1, 2, 3, 4],
      "explanation": "Polling is simplest (standard HTTP). Long polling adds connection management. SSE is straightforward server push. WebSocket needs handshake and framing. gRPC requires protobuf and HTTP/2.",
      "detailedExplanation": "Polling is simplest (standard HTTP). Long polling adds connection management. SSE is straightforward server push. WebSocket needs handshake and framing. gRPC requires protobuf and HTTP/2. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "RFC 6455: The WebSocket Protocol",
          "url": "https://www.rfc-editor.org/rfc/rfc6455"
        }
      ]
    },
    {
      "id": "api-014",
      "type": "two-stage",
      "question": "A collaborative document editor needs to sync changes between users in real-time.",
      "stages": [
        {
          "question": "What communication pattern is most appropriate?",
          "options": [
            "WebSocket with operational transforms or CRDTs",
            "REST with frequent polling",
            "GraphQL subscriptions only",
            "Webhooks between clients"
          ],
          "correct": 0,
          "explanation": "Real-time collaboration needs low-latency bidirectional communication (WebSocket) combined with conflict resolution algorithms (OT or CRDTs).",
          "detailedExplanation": "Real-time collaboration needs low-latency bidirectional communication (WebSocket) combined with conflict resolution algorithms (OT or CRDTs). Convert targets into concrete counts and time budgets first, then reason about whether incident frequency and recovery time can satisfy them."
        },
        {
          "question": "How should the API handle conflicting edits from two users?",
          "options": [
            "Use operational transformation to merge changes",
            "Last write wins",
            "Lock the document for editing",
            "Reject the second edit"
          ],
          "correct": 0,
          "explanation": "Operational transformation or CRDTs automatically merge concurrent edits, allowing true real-time collaboration without locks or data loss.",
          "detailedExplanation": "Operational transformation or CRDTs automatically merge concurrent edits, allowing true real-time collaboration without locks or data loss. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-015",
      "type": "multi-select",
      "question": "You're designing an IoT API for smart home devices. What considerations apply?",
      "options": [
        "Minimize payload size for bandwidth-constrained devices",
        "Support intermittent connectivity",
        "Consider device authentication (not just user auth)",
        "Use only REST for simplicity"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "IoT needs efficient protocols, offline handling, and device-level authentication. Protocol choice (MQTT, CoAP, gRPC) depends on constraints—REST isn't always ideal.",
      "detailedExplanation": "IoT needs efficient protocols, offline handling, and device-level authentication. Protocol choice (MQTT, CoAP, gRPC) depends on constraints—REST isn't always ideal. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-016",
      "type": "two-stage",
      "question": "Smart sensors send temperature readings every minute. You need to store and query this time-series data.",
      "stages": [
        {
          "question": "How should the data ingestion API be designed?",
          "options": [
            "Batch endpoint accepting multiple readings per request",
            "Individual POST for each reading",
            "WebSocket stream from each sensor",
            "Polling sensors from the server"
          ],
          "correct": 0,
          "explanation": "Batching reduces connection overhead and is ideal for periodic readings. Sensors accumulate readings and send in batches, reducing API calls significantly.",
          "detailedExplanation": "Batching reduces connection overhead and is ideal for periodic readings. Sensors accumulate readings and send in batches, reducing API calls significantly. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "How should the query API handle time-range queries for aggregated data?",
          "options": [
            "Pre-aggregate data and provide resolution parameters",
            "Return all raw data points",
            "Only support last 24 hours",
            "Compute aggregations on every request"
          ],
          "correct": 0,
          "explanation": "Pre-aggregate at various resolutions (hourly, daily). Let clients request appropriate granularity to balance detail vs. response size.",
          "detailedExplanation": "Pre-aggregate at various resolutions (hourly, daily). Let clients request appropriate granularity to balance detail vs. response size. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-017",
      "type": "multiple-choice",
      "question": "Your API needs to support file uploads up to 1GB. What's the best approach?",
      "options": [
        "Multipart upload with chunking and resumability",
        "Single POST with file in body",
        "Base64 encode in JSON",
        "Require external storage (S3) URLs only"
      ],
      "correct": 0,
      "explanation": "Large files need chunked uploads with resumability to handle network issues. Multipart uploads allow progress tracking and recovery from partial failures.",
      "detailedExplanation": "Large files need chunked uploads with resumability to handle network issues. Multipart uploads allow progress tracking and recovery from partial failures. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        }
      ]
    },
    {
      "id": "api-018",
      "type": "two-stage",
      "question": "Users upload videos (500MB-2GB) to your platform. The upload often fails on mobile networks.",
      "stages": [
        {
          "question": "What upload mechanism should you implement?",
          "options": [
            "Resumable chunked uploads with progress tracking",
            "Single request uploads",
            "Client-side compression first",
            "Smaller file size limits"
          ],
          "correct": 0,
          "explanation": "Resumable uploads let clients continue from where they left off after network interruption. Track progress server-side by chunk.",
          "detailedExplanation": "Resumable uploads let clients continue from where they left off after network interruption. Track progress server-side by chunk. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "What should the API return after initiating an upload?",
          "options": [
            "Upload ID and URL for subsequent chunk uploads",
            "Final video URL",
            "Processing status",
            "Nothing until complete"
          ],
          "correct": 0,
          "explanation": "Return an upload session ID. The client uses this to upload chunks and query progress. The ID enables resumability after disconnection.",
          "detailedExplanation": "Return an upload session ID. The client uses this to upload chunks and query progress. The ID enables resumability after disconnection. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-019",
      "type": "ordering",
      "question": "Order the steps for a resumable file upload API flow:",
      "items": [
        "POST to initiate upload, receive session ID",
        "PUT chunks with byte range headers",
        "Server tracks received chunks",
        "Client queries progress after reconnection",
        "POST to complete upload when all chunks received"
      ],
      "correctOrder": [0, 1, 2, 3, 4],
      "explanation": "Initiate session, upload chunks (server tracks them), check progress if needed, then explicitly complete when done.",
      "detailedExplanation": "Initiate session, upload chunks (server tracks them), check progress if needed, then explicitly complete when done. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-020",
      "type": "two-stage",
      "question": "You're building a search API for an e-commerce site with millions of products.",
      "stages": [
        {
          "question": "How should search results be paginated?",
          "options": [
            "Cursor-based with search_after for deep pagination",
            "Page numbers with offset",
            "Return all results",
            "Limit to first 100 results only"
          ],
          "correct": 0,
          "explanation": "Search engines perform poorly with deep offset pagination. Cursor-based (search_after in Elasticsearch) maintains consistency and performance for deep pages.",
          "detailedExplanation": "Search engines perform poorly with deep offset pagination. Cursor-based (search_after in Elasticsearch) maintains consistency and performance for deep pages. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "How should faceted filtering be exposed in the API?",
          "options": [
            "Query parameters for filters, response includes facet counts",
            "Separate endpoints per facet",
            "Client computes facets from all results",
            "GraphQL only"
          ],
          "correct": 0,
          "explanation": "Accept filter parameters in the request, return matching results plus facet counts (e.g., category counts) so users can refine their search.",
          "detailedExplanation": "Accept filter parameters in the request, return matching results plus facet counts (e.g., category counts) so users can refine their search. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-021",
      "type": "multi-select",
      "question": "Your search API needs to handle these requirements. Which affect API design?",
      "options": [
        "Autocomplete suggestions as user types",
        "Spelling correction",
        "Personalized results based on user history",
        "Sub-100ms response time"
      ],
      "correctIndices": [0, 2],
      "explanation": "Autocomplete needs a separate endpoint optimized for speed and partial queries. Personalization may require user context in requests. Spelling correction and latency are backend concerns.",
      "detailedExplanation": "Autocomplete needs a separate endpoint optimized for speed and partial queries. Personalization may require user context in requests. Spelling correction and latency are backend concerns. Convert targets into concrete counts and time budgets first, then reason about whether incident frequency and recovery time can satisfy them.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-022",
      "type": "two-stage",
      "question": "You're designing an API for a booking system (hotels, flights). Multiple users might try to book the same room.",
      "stages": [
        {
          "question": "How should the API handle concurrent booking attempts?",
          "options": [
            "Optimistic locking with version/ETag validation",
            "First-come-first-served with database locks",
            "Queue all bookings for sequential processing",
            "Allow overbooking, reconcile later"
          ],
          "correct": 0,
          "explanation": "Optimistic locking lets users attempt bookings concurrently. The first to commit wins; others get conflict errors and can retry with fresh availability.",
          "detailedExplanation": "Optimistic locking lets users attempt bookings concurrently. The first to commit wins; others get conflict errors and can retry with fresh availability. Convert targets into concrete counts and time budgets first, then reason about whether incident frequency and recovery time can satisfy them."
        },
        {
          "question": "What status code indicates another user booked the room first?",
          "options": [
            "409 Conflict",
            "400 Bad Request",
            "404 Not Found",
            "503 Service Unavailable"
          ],
          "correct": 0,
          "explanation": "409 Conflict indicates the request conflicts with current state—the room is no longer available due to a concurrent booking.",
          "detailedExplanation": "409 Conflict indicates the request conflicts with current state—the room is no longer available due to a concurrent booking. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-023",
      "type": "multiple-choice",
      "question": "A booking API needs to reserve inventory temporarily while the user completes payment. What pattern should you use?",
      "options": [
        "Two-phase commit: reserve then confirm/release",
        "Immediate booking with cancellation",
        "Hold with automatic expiration (TTL)",
        "Optimistic booking without holds"
      ],
      "correct": 2,
      "explanation": "Temporary holds with TTL prevent inventory from being locked forever if users abandon checkout. Auto-release after timeout (e.g., 15 minutes) without explicit cancellation.",
      "detailedExplanation": "Temporary holds with TTL prevent inventory from being locked forever if users abandon checkout. Auto-release after timeout (e.g., 15 minutes) without explicit cancellation. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Redis Documentation",
          "url": "https://redis.io/docs/latest/"
        }
      ]
    },
    {
      "id": "api-024",
      "type": "ordering",
      "question": "Order these steps in a booking flow with inventory holds:",
      "items": [
        "Check availability",
        "Create hold with TTL",
        "Collect payment",
        "Convert hold to confirmed booking",
        "Release hold if payment fails"
      ],
      "correctOrder": [0, 1, 2, 3, 4],
      "explanation": "Check availability, create temporary hold, process payment, then either confirm booking or release hold based on payment result.",
      "detailedExplanation": "Check availability, create temporary hold, process payment, then either confirm booking or release hold based on payment result. Convert targets into concrete counts and time budgets first, then reason about whether incident frequency and recovery time can satisfy them.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        }
      ]
    },
    {
      "id": "api-025",
      "type": "two-stage",
      "question": "Your API aggregates data from three downstream services. One service is slow, causing timeouts.",
      "stages": [
        {
          "question": "What's the best response strategy?",
          "options": [
            "Return partial data with degradation indicator",
            "Wait for all services (increase timeout)",
            "Fail the entire request",
            "Cache everything to avoid calls"
          ],
          "correct": 0,
          "explanation": "Graceful degradation returns available data while indicating what's missing. Users get partial value rather than complete failure.",
          "detailedExplanation": "Graceful degradation returns available data while indicating what's missing. Users get partial value rather than complete failure. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "How should the API indicate which data is missing?",
          "options": [
            "Include a warnings/degraded field listing unavailable sections",
            "Return 206 Partial Content",
            "Null fields with no explanation",
            "Separate error response"
          ],
          "correct": 0,
          "explanation": "A warnings array or metadata section clearly communicates what's degraded, helping clients render appropriate UI.",
          "detailedExplanation": "A warnings array or metadata section clearly communicates what's degraded, helping clients render appropriate UI. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-026",
      "type": "multi-select",
      "question": "Your public API is being abused. What rate limiting strategies should you implement?",
      "options": [
        "Per-API-key limits",
        "Per-endpoint limits (expensive operations lower)",
        "Tiered limits by plan/pricing",
        "Global limit across all users"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "Combine per-key limits, endpoint-specific limits (search lower than reads), and plan-based tiers. Global limits don't distinguish legitimate high-volume users from abusers.",
      "detailedExplanation": "Combine per-key limits, endpoint-specific limits (search lower than reads), and plan-based tiers. Global limits don't distinguish legitimate high-volume users from abusers. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-027",
      "type": "two-stage",
      "question": "A partner integration sends bursty traffic—quiet for hours, then thousands of requests in minutes.",
      "stages": [
        {
          "question": "What rate limiting algorithm handles this best?",
          "options": [
            "Token bucket (allows bursts up to bucket size)",
            "Fixed window (strict per-minute limits)",
            "Leaky bucket (smooths traffic)",
            "No rate limiting for partners"
          ],
          "correct": 0,
          "explanation": "Token bucket allows accumulated capacity for bursts while maintaining overall rate limits. Perfect for legitimate bursty patterns.",
          "detailedExplanation": "Token bucket allows accumulated capacity for bursts while maintaining overall rate limits. Perfect for legitimate bursty patterns. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "How should you communicate rate limit status to the partner?",
          "options": [
            "X-RateLimit headers showing remaining quota and reset time",
            "Only return 429 when exceeded",
            "Email alerts at 80% usage",
            "Dashboard metrics only"
          ],
          "correct": 0,
          "explanation": "Standard rate limit headers (X-RateLimit-Remaining, X-RateLimit-Reset) let clients proactively manage their request rate before hitting limits.",
          "detailedExplanation": "Standard rate limit headers (X-RateLimit-Remaining, X-RateLimit-Reset) let clients proactively manage their request rate before hitting limits. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-028",
      "type": "multiple-choice",
      "question": "Your API documentation is outdated and developers complain. What's the best solution?",
      "options": [
        "Generate docs from OpenAPI spec that's validated against implementation",
        "Hire a technical writer",
        "Wiki that anyone can edit",
        "Code comments only"
      ],
      "correct": 0,
      "explanation": "Auto-generated docs from a validated OpenAPI spec stay in sync with implementation. Contract testing ensures the spec matches actual behavior.",
      "detailedExplanation": "Auto-generated docs from a validated OpenAPI spec stay in sync with implementation. Contract testing ensures the spec matches actual behavior. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-029",
      "type": "two-stage",
      "question": "You need to add a required field to an existing API request body.",
      "stages": [
        {
          "question": "Is this a breaking change?",
          "options": [
            "Yes—existing clients don't send the field",
            "No—it's just a new field",
            "Only if it affects responses",
            "Depends on the field type"
          ],
          "correct": 0,
          "explanation": "Adding a required request field breaks existing clients—their requests become invalid. Required fields in requests are breaking changes.",
          "detailedExplanation": "Adding a required request field breaks existing clients—their requests become invalid. Required fields in requests are breaking changes. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "How can you add this field without breaking clients?",
          "options": [
            "Make it optional with a default value, later require it with deprecation warning",
            "Create a new API version immediately",
            "Add it as required and notify clients",
            "Make it a header instead"
          ],
          "correct": 0,
          "explanation": "Add as optional with sensible default. After clients migrate, deprecate the default behavior, then eventually require the field.",
          "detailedExplanation": "Add as optional with sensible default. After clients migrate, deprecate the default behavior, then eventually require the field. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-030",
      "type": "multi-select",
      "question": "Which API changes are typically NOT breaking (backward compatible)?",
      "options": [
        "Adding optional request fields",
        "Adding response fields",
        "Adding new endpoints",
        "Removing response fields"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "Optional request fields, new response fields, and new endpoints are additive and don't break existing clients. Removing response fields breaks clients expecting them.",
      "detailedExplanation": "Optional request fields, new response fields, and new endpoints are additive and don't break existing clients. Removing response fields breaks clients expecting them. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-031",
      "type": "two-stage",
      "question": "You're migrating from REST to GraphQL for your mobile app API.",
      "stages": [
        {
          "question": "What migration strategy minimizes risk?",
          "options": [
            "Run both APIs in parallel during transition",
            "Big bang replacement",
            "GraphQL for new features only, keep REST",
            "Convert one endpoint at a time in place"
          ],
          "correct": 0,
          "explanation": "Parallel operation lets you migrate clients gradually, roll back if issues arise, and validate GraphQL behavior against REST baseline.",
          "detailedExplanation": "Parallel operation lets you migrate clients gradually, roll back if issues arise, and validate GraphQL behavior against REST baseline. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "How should the GraphQL layer fetch data during migration?",
          "options": [
            "GraphQL resolvers call existing REST endpoints or services",
            "Duplicate all business logic in GraphQL",
            "Direct database access only",
            "Require full backend rewrite first"
          ],
          "correct": 0,
          "explanation": "GraphQL can act as a facade over existing services. Resolvers call the same backends as REST endpoints, minimizing duplicate logic and risk.",
          "detailedExplanation": "GraphQL can act as a facade over existing services. Resolvers call the same backends as REST endpoints, minimizing duplicate logic and risk. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-032",
      "type": "ordering",
      "question": "Order these API migration phases:",
      "items": [
        "Analyze current API usage patterns",
        "Design new API with learnings",
        "Implement new API alongside old",
        "Migrate clients incrementally",
        "Deprecate and retire old API"
      ],
      "correctOrder": [0, 1, 2, 3, 4],
      "explanation": "Understand current usage, design improvements, run parallel, migrate clients gradually, then retire the old API when migration is complete.",
      "detailedExplanation": "Understand current usage, design improvements, run parallel, migrate clients gradually, then retire the old API when migration is complete. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-033",
      "type": "two-stage",
      "question": "Your API needs to support both JSON and XML response formats for legacy clients.",
      "stages": [
        {
          "question": "How should clients specify their preferred format?",
          "options": [
            "Accept header (content negotiation)",
            "Query parameter (?format=xml)",
            "Separate endpoints (/users.json, /users.xml)",
            "All responses include both"
          ],
          "correct": 0,
          "explanation": "Accept header is the standard HTTP mechanism for content negotiation. Accept: application/json or Accept: application/xml.",
          "detailedExplanation": "Accept header is the standard HTTP mechanism for content negotiation. Accept: application/json or Accept: application/xml. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "What should the API return if the Accept header requests an unsupported format?",
          "options": [
            "406 Not Acceptable",
            "Default to JSON",
            "400 Bad Request",
            "200 with error in body"
          ],
          "correct": 0,
          "explanation": "406 Not Acceptable indicates the server can't produce a response matching the Accept header. Include supported formats in the response.",
          "detailedExplanation": "406 Not Acceptable indicates the server can't produce a response matching the Accept header. Include supported formats in the response. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-034",
      "type": "multiple-choice",
      "question": "A webhook consumer is down for maintenance. How should your webhook system handle this?",
      "options": [
        "Queue events and retry with exponential backoff",
        "Drop events after first failure",
        "Hold all webhooks until consumer returns",
        "Require polling instead"
      ],
      "correct": 0,
      "explanation": "Queue failed deliveries and retry with backoff. Events should be persisted so they're not lost, but don't overwhelm the consumer when it returns.",
      "detailedExplanation": "Queue failed deliveries and retry with backoff. Events should be persisted so they're not lost, but don't overwhelm the consumer when it returns. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ]
    },
    {
      "id": "api-035",
      "type": "two-stage",
      "question": "Your webhook system needs to guarantee event delivery even if consumers are temporarily unavailable.",
      "stages": [
        {
          "question": "What delivery guarantee should you aim for?",
          "options": [
            "At-least-once delivery with consumer idempotency",
            "Exactly-once delivery",
            "Best-effort delivery",
            "At-most-once delivery"
          ],
          "correct": 0,
          "explanation": "At-least-once with idempotent consumers is practical. Exactly-once is extremely difficult. Consumers should handle duplicate events gracefully.",
          "detailedExplanation": "At-least-once with idempotent consumers is practical. Exactly-once is extremely difficult. Consumers should handle duplicate events gracefully. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "How long should you retry failed webhook deliveries?",
          "options": [
            "Configurable per-consumer, typically hours to days",
            "Forever until successful",
            "3 attempts only",
            "No retries—fail fast"
          ],
          "correct": 0,
          "explanation": "Allow consumers to configure retry policies. Default to reasonable bounds (e.g., retry for 24-72 hours) before giving up and alerting.",
          "detailedExplanation": "Allow consumers to configure retry policies. Default to reasonable bounds (e.g., retry for 24-72 hours) before giving up and alerting. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ]
    },
    {
      "id": "api-036",
      "type": "multi-select",
      "question": "You're designing a webhook system. What should each webhook event include?",
      "options": [
        "Event type and timestamp",
        "Unique event ID for deduplication",
        "HMAC signature for verification",
        "Full resource state (not just IDs)"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "Events need type, timestamp, unique ID (for idempotency), and signature (for security). Full state is optional—some prefer minimal payloads with IDs for fetching current state.",
      "detailedExplanation": "Events need type, timestamp, unique ID (for idempotency), and signature (for security). Full state is optional—some prefer minimal payloads with IDs for fetching current state. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ]
    },
    {
      "id": "api-037",
      "type": "two-stage",
      "question": "You need to expose an API for partners to pull large datasets (millions of rows) for analytics.",
      "stages": [
        {
          "question": "What's the best approach for bulk data export?",
          "options": [
            "Async export job that produces downloadable file",
            "Paginated API calls",
            "Single endpoint returning all data",
            "Real-time streaming"
          ],
          "correct": 0,
          "explanation": "For large datasets, async export is practical. Client requests export, server processes in background, notifies when file is ready for download.",
          "detailedExplanation": "For large datasets, async export is practical. Client requests export, server processes in background, notifies when file is ready for download. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "What file format is best for large dataset exports?",
          "options": [
            "CSV or JSONL (newline-delimited JSON) for streaming",
            "Single JSON array",
            "XML",
            "Protocol Buffers"
          ],
          "correct": 0,
          "explanation": "CSV and JSONL can be streamed and processed line-by-line without loading entirely into memory. Single JSON arrays require full parsing.",
          "detailedExplanation": "CSV and JSONL can be streamed and processed line-by-line without loading entirely into memory. Single JSON arrays require full parsing. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-038",
      "type": "ordering",
      "question": "Order these steps for an async bulk export API:",
      "items": [
        "POST to initiate export with parameters",
        "Return job ID immediately",
        "Process export in background",
        "Webhook or poll for completion",
        "Download file from provided URL"
      ],
      "correctOrder": [0, 1, 2, 3, 4],
      "explanation": "Client initiates export, gets job ID for tracking, server processes asynchronously, notifies on completion, client downloads result file.",
      "detailedExplanation": "Client initiates export, gets job ID for tracking, server processes asynchronously, notifies on completion, client downloads result file. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ]
    },
    {
      "id": "api-039",
      "type": "two-stage",
      "question": "Your API allows users to trigger expensive background jobs (report generation, data processing).",
      "stages": [
        {
          "question": "How should the API respond to job creation requests?",
          "options": [
            "202 Accepted with job ID and status URL",
            "200 OK after job completes",
            "201 Created with final result",
            "Redirect to results page"
          ],
          "correct": 0,
          "explanation": "202 Accepted indicates the request is accepted for processing. Return immediately with a job ID and URL to check status.",
          "detailedExplanation": "202 Accepted indicates the request is accepted for processing. Return immediately with a job ID and URL to check status. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "How should clients track job progress?",
          "options": [
            "Poll status endpoint or receive webhook on completion",
            "Keep connection open until done",
            "Email notification only",
            "Check database directly"
          ],
          "correct": 0,
          "explanation": "Provide a status endpoint for polling and/or webhook callback for notification. Let clients choose their preferred pattern.",
          "detailedExplanation": "Provide a status endpoint for polling and/or webhook callback for notification. Let clients choose their preferred pattern. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-040",
      "type": "multiple-choice",
      "question": "An API endpoint processes requests slowly (30+ seconds). What pattern should you use?",
      "options": [
        "Async processing with polling/callback for results",
        "Increase timeout limits",
        "Synchronous with loading spinner",
        "Split into multiple fast requests"
      ],
      "correct": 0,
      "explanation": "Long operations should be asynchronous. Return immediately with a job ID, process in background, let clients poll or receive callbacks.",
      "detailedExplanation": "Long operations should be asynchronous. Return immediately with a job ID, process in background, let clients poll or receive callbacks. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-041",
      "type": "two-stage",
      "question": "You're designing an API for a content management system. Content can be in draft, published, or archived states.",
      "stages": [
        {
          "question": "How should state transitions be represented in the API?",
          "options": [
            "Action-based endpoints: POST /articles/{id}/publish",
            "PATCH with state field",
            "Separate endpoints per state: PUT /published-articles/{id}",
            "DELETE and recreate with new state"
          ],
          "correct": 0,
          "explanation": "Action-based endpoints make state transitions explicit. Publishing might involve more than just changing a field—it's a business action.",
          "detailedExplanation": "Action-based endpoints make state transitions explicit. Publishing might involve more than just changing a field—it's a business action. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "What if publishing requires approval workflow?",
          "options": [
            "POST /articles/{id}/submit-for-review, separate approve endpoint",
            "Include approval in publish request",
            "Background job with status polling",
            "Webhook to notify approvers"
          ],
          "correct": 0,
          "explanation": "Model the workflow explicitly: submit for review, then approve/reject. Each action is a separate endpoint reflecting the business process.",
          "detailedExplanation": "Model the workflow explicitly: submit for review, then approve/reject. Each action is a separate endpoint reflecting the business process. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-042",
      "type": "multi-select",
      "question": "You're designing a notification preferences API. Users can opt in/out of various notification types. What design considerations apply?",
      "options": [
        "Model as resource: GET/PUT /users/{id}/notification-preferences",
        "Support partial updates for individual preferences",
        "Validate combinations (can't disable all if required)",
        "Return current state after updates"
      ],
      "correctIndices": [0, 1, 2, 3],
      "explanation": "All apply: treat preferences as a resource, allow partial updates (PATCH), validate business rules, and return updated state for confirmation.",
      "detailedExplanation": "All apply: treat preferences as a resource, allow partial updates (PATCH), validate business rules, and return updated state for confirmation. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-043",
      "type": "two-stage",
      "question": "A feature flag service needs an API for SDKs to fetch flag configurations.",
      "stages": [
        {
          "question": "What's most important for this API?",
          "options": [
            "Low latency and high availability",
            "Detailed error messages",
            "Versioning flexibility",
            "GraphQL support"
          ],
          "correct": 0,
          "explanation": "Feature flag APIs are called on every request in client apps. They must be extremely fast and highly available—downtime affects all dependent services.",
          "detailedExplanation": "Feature flag APIs are called on every request in client apps. They must be extremely fast and highly available—downtime affects all dependent services. Convert targets into concrete counts and time budgets first, then reason about whether incident frequency and recovery time can satisfy them."
        },
        {
          "question": "How should SDKs handle API failures?",
          "options": [
            "Use cached/default values and retry in background",
            "Throw exceptions to calling code",
            "Block until API responds",
            "Disable all features"
          ],
          "correct": 0,
          "explanation": "SDKs should cache flag values and fall back to cached/default values on failure. Never let feature flag service failure cascade to application failure.",
          "detailedExplanation": "SDKs should cache flag values and fall back to cached/default values on failure. Never let feature flag service failure cascade to application failure. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-044",
      "type": "ordering",
      "question": "Order these API design principles by priority for a public developer API:",
      "items": [
        "Consistency and predictability",
        "Comprehensive documentation",
        "Backward compatibility",
        "Performance optimization",
        "Feature completeness"
      ],
      "correctOrder": [0, 2, 1, 4, 3],
      "explanation": "Consistency helps developers learn patterns. Backward compatibility protects existing integrations. Good docs enable adoption. Features and performance follow.",
      "detailedExplanation": "Consistency helps developers learn patterns. Backward compatibility protects existing integrations. Good docs enable adoption. Features and performance follow. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "api-045",
      "type": "two-stage",
      "question": "Your e-commerce API needs to handle flash sales with 100x normal traffic for brief periods.",
      "stages": [
        {
          "question": "How should the API handle traffic spikes?",
          "options": [
            "Rate limiting with queue for excess requests",
            "Scale infinitely to handle all requests",
            "Reject all requests above capacity",
            "Pre-warm with predicted capacity"
          ],
          "correct": 0,
          "explanation": "Combination of rate limiting, queuing, and elastic scaling. Some requests may queue briefly rather than fail outright.",
          "detailedExplanation": "Combination of rate limiting, queuing, and elastic scaling. Some requests may queue briefly rather than fail outright. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "For inventory checks during flash sales, what consistency model is appropriate?",
          "options": [
            "Eventually consistent reads with optimistic writes",
            "Strongly consistent reads for every request",
            "No consistency guarantees",
            "Read-your-writes only"
          ],
          "correct": 0,
          "explanation": "Allow eventually consistent inventory reads for display (slightly stale is OK), but use optimistic locking at purchase time to prevent overselling.",
          "detailedExplanation": "Allow eventually consistent inventory reads for display (slightly stale is OK), but use optimistic locking at purchase time to prevent overselling. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-046",
      "type": "multi-select",
      "question": "You're designing an API for a marketplace connecting buyers and sellers. What entities need APIs?",
      "options": [
        "Products/listings",
        "Orders and transactions",
        "Reviews and ratings",
        "Internal analytics"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "Products, orders, and reviews are core marketplace entities needing APIs. Internal analytics typically aren't exposed via public APIs.",
      "detailedExplanation": "Products, orders, and reviews are core marketplace entities needing APIs. Internal analytics typically aren't exposed via public APIs. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-047",
      "type": "two-stage",
      "question": "Your marketplace API handles transactions between buyers and sellers with platform fees.",
      "stages": [
        {
          "question": "How should the order creation endpoint be designed?",
          "options": [
            "Single transaction endpoint handling payment split atomically",
            "Separate endpoints for buyer payment and seller credit",
            "Client coordinates multiple payment calls",
            "Queue for async processing"
          ],
          "correct": 0,
          "explanation": "Order creation should be atomic—buyer pays, platform takes fee, seller is credited all in one operation to prevent inconsistent states.",
          "detailedExplanation": "Order creation should be atomic—buyer pays, platform takes fee, seller is credited all in one operation to prevent inconsistent states. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "What if the payment provider is temporarily unavailable?",
          "options": [
            "Queue the order, process when available, notify user",
            "Fail immediately with retry instructions",
            "Degrade to cash-on-delivery",
            "Hold the UI until available"
          ],
          "correct": 0,
          "explanation": "For better UX, accept the order (with appropriate holds), queue payment processing, and notify users of status. Requires careful state management.",
          "detailedExplanation": "For better UX, accept the order (with appropriate holds), queue payment processing, and notify users of status. Requires careful state management. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-048",
      "type": "multiple-choice",
      "question": "A healthcare API handles patient data. What's the most critical API design consideration?",
      "options": [
        "Audit logging for all data access",
        "Fast response times",
        "GraphQL for flexibility",
        "Extensive caching"
      ],
      "correct": 0,
      "explanation": "Healthcare data requires strict audit trails for compliance (HIPAA, etc.). Every access must be logged with who, what, when, and why.",
      "detailedExplanation": "Healthcare data requires strict audit trails for compliance (HIPAA, etc.). Every access must be logged with who, what, when, and why. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-049",
      "type": "two-stage",
      "question": "Your healthcare API needs to support consent management—patients control who can access their data.",
      "stages": [
        {
          "question": "Where should consent checks occur?",
          "options": [
            "API middleware enforcing consent before data access",
            "Application code in each endpoint",
            "Database-level row security",
            "Client-side filtering"
          ],
          "correct": 0,
          "explanation": "Consent enforcement should be centralized in middleware—defense in depth. Don't rely on individual endpoints to remember consent checks.",
          "detailedExplanation": "Consent enforcement should be centralized in middleware—defense in depth. Don't rely on individual endpoints to remember consent checks. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "How should the API behave when consent is denied?",
          "options": [
            "403 Forbidden with clear explanation (without leaking data existence)",
            "404 Not Found (hide existence)",
            "Empty response",
            "200 with masked data"
          ],
          "correct": 0,
          "explanation": "403 clearly indicates access is denied due to permissions/consent. Be careful not to reveal sensitive information in the error message.",
          "detailedExplanation": "403 clearly indicates access is denied due to permissions/consent. Be careful not to reveal sensitive information in the error message. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-050",
      "type": "multi-select",
      "question": "You're designing an API for financial transactions. Which security measures are essential?",
      "options": [
        "TLS for all communications",
        "Request signing for integrity",
        "Idempotency keys",
        "IP whitelisting for all clients"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "TLS encrypts transport, request signing ensures integrity, idempotency prevents duplicates. IP whitelisting may be too restrictive for legitimate mobile/dynamic clients.",
      "detailedExplanation": "TLS encrypts transport, request signing ensures integrity, idempotency prevents duplicates. IP whitelisting may be too restrictive for legitimate mobile/dynamic clients. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-051",
      "type": "two-stage",
      "question": "You're building an API gateway for microservices. Services are deployed across multiple regions.",
      "stages": [
        {
          "question": "How should the gateway route requests to the appropriate region?",
          "options": [
            "Geo-based routing to nearest healthy region",
            "Random distribution",
            "Single primary region",
            "Client chooses region"
          ],
          "correct": 0,
          "explanation": "Route to nearest healthy region for best latency. Include health checks to avoid routing to degraded regions.",
          "detailedExplanation": "Route to nearest healthy region for best latency. Include health checks to avoid routing to degraded regions. Convert targets into concrete counts and time budgets first, then reason about whether incident frequency and recovery time can satisfy them."
        },
        {
          "question": "How should the API handle region failover?",
          "options": [
            "Automatic failover to next nearest healthy region",
            "Return error until primary recovers",
            "Queue requests for later",
            "Require client retry with different endpoint"
          ],
          "correct": 0,
          "explanation": "Automatic failover provides best user experience. The gateway handles routing complexity; clients don't need to know about regions.",
          "detailedExplanation": "Automatic failover provides best user experience. The gateway handles routing complexity; clients don't need to know about regions. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-052",
      "type": "ordering",
      "question": "Order these concerns when designing an API gateway:",
      "items": [
        "Authentication/authorization",
        "Rate limiting",
        "Request routing",
        "Response transformation",
        "Logging/monitoring"
      ],
      "correctOrder": [0, 1, 2, 3, 4],
      "explanation": "Authenticate first (reject unauthorized early), then rate limit, route to services, transform responses, and log throughout.",
      "detailedExplanation": "Authenticate first (reject unauthorized early), then rate limit, route to services, transform responses, and log throughout. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Token bucket",
          "url": "https://en.wikipedia.org/wiki/Token_bucket"
        }
      ]
    },
    {
      "id": "api-053",
      "type": "two-stage",
      "question": "Your public API uses API keys for authentication. You need to rotate a compromised key.",
      "stages": [
        {
          "question": "How should the API support key rotation?",
          "options": [
            "Allow multiple active keys per client during transition",
            "Immediate revocation and new key",
            "Gradual timeout of old key",
            "Require client downtime for rotation"
          ],
          "correct": 0,
          "explanation": "Support multiple concurrent keys so clients can deploy new keys before revoking old ones, enabling zero-downtime rotation.",
          "detailedExplanation": "Support multiple concurrent keys so clients can deploy new keys before revoking old ones, enabling zero-downtime rotation. Convert targets into concrete counts and time budgets first, then reason about whether incident frequency and recovery time can satisfy them."
        },
        {
          "question": "How should the API notify clients of suspicious key usage?",
          "options": [
            "Webhook notification with usage anomaly details",
            "Only log internally",
            "Immediate key revocation",
            "Email only"
          ],
          "correct": 0,
          "explanation": "Proactive webhook notifications let clients investigate and rotate keys quickly if compromised. Combine with internal alerting.",
          "detailedExplanation": "Proactive webhook notifications let clients investigate and rotate keys quickly if compromised. Combine with internal alerting. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-054",
      "type": "multi-select",
      "question": "You're implementing API key authentication. What metadata should be stored with each key?",
      "options": [
        "Associated user/organization",
        "Creation timestamp",
        "Permissions/scopes",
        "Last used timestamp"
      ],
      "correctIndices": [0, 1, 2, 3],
      "explanation": "Track ownership (who), creation (when/audit), permissions (what they can do), and usage (detect inactive/suspicious keys).",
      "detailedExplanation": "Track ownership (who), creation (when/audit), permissions (what they can do), and usage (detect inactive/suspicious keys). Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-055",
      "type": "two-stage",
      "question": "A client reports that your API returns different results for the same request.",
      "stages": [
        {
          "question": "What's the most likely cause?",
          "options": [
            "Caching inconsistency or eventual consistency",
            "API bug",
            "Network issues",
            "Client error"
          ],
          "correct": 0,
          "explanation": "Inconsistent results often indicate caching issues (serving stale data) or eventual consistency in distributed systems.",
          "detailedExplanation": "Inconsistent results often indicate caching issues (serving stale data) or eventual consistency in distributed systems. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "How should you investigate?",
          "options": [
            "Check request IDs to trace both requests through the system",
            "Ask client to retry",
            "Restart servers",
            "Ignore intermittent issues"
          ],
          "correct": 0,
          "explanation": "Request/correlation IDs let you trace both requests through logs to identify where results diverged—cache hit vs miss, different replicas, etc.",
          "detailedExplanation": "Request/correlation IDs let you trace both requests through logs to identify where results diverged—cache hit vs miss, different replicas, etc. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-056",
      "type": "multiple-choice",
      "question": "Your API needs to return data in the user's timezone. How should timezone be specified?",
      "options": [
        "Accept-Timezone header or query parameter with IANA timezone",
        "Server always uses UTC",
        "Detect from IP address",
        "Separate endpoints per timezone"
      ],
      "correct": 0,
      "explanation": "Let clients specify timezone via header or parameter using IANA names (America/New_York). Never guess from IP—users may be traveling or using VPNs.",
      "detailedExplanation": "Let clients specify timezone via header or parameter using IANA names (America/New_York). Never guess from IP—users may be traveling or using VPNs. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-057",
      "type": "two-stage",
      "question": "Your API returns timestamps. Users in different timezones are confused about when events occurred.",
      "stages": [
        {
          "question": "What timestamp format should the API use?",
          "options": [
            "ISO 8601 with timezone (or UTC with Z suffix)",
            "Unix timestamp",
            "Local time string",
            "Relative time (2 hours ago)"
          ],
          "correct": 0,
          "explanation": "ISO 8601 with timezone offset (2024-01-15T10:30:00-05:00) or UTC (2024-01-15T15:30:00Z) is unambiguous and widely supported.",
          "detailedExplanation": "ISO 8601 with timezone offset (2024-01-15T10:30:00-05:00) or UTC (2024-01-15T15:30:00Z) is unambiguous and widely supported. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "Should the API convert times to user's timezone?",
          "options": [
            "Return UTC; let clients convert for display",
            "Convert to user's timezone",
            "Include both UTC and local",
            "Depend on endpoint"
          ],
          "correct": 0,
          "explanation": "APIs typically return UTC for consistency. Clients convert to local timezone for display. This separates data format from presentation.",
          "detailedExplanation": "APIs typically return UTC for consistency. Clients convert to local timezone for display. This separates data format from presentation. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-058",
      "type": "multi-select",
      "question": "You're designing an internationalized API. What considerations apply?",
      "options": [
        "Accept-Language header for response language",
        "Currency and number formatting preferences",
        "UTF-8 encoding for all text",
        "Right-to-left text direction hints"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "Language preference via Accept-Language, locale-aware formatting, and UTF-8 are essential. Text direction is typically a presentation concern, not API data.",
      "detailedExplanation": "Language preference via Accept-Language, locale-aware formatting, and UTF-8 are essential. Text direction is typically a presentation concern, not API data. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-059",
      "type": "two-stage",
      "question": "Your API needs to support search across multiple languages.",
      "stages": [
        {
          "question": "How should the search endpoint handle language?",
          "options": [
            "Accept language parameter, use appropriate analyzer",
            "Search all languages simultaneously",
            "Separate search endpoints per language",
            "Client pre-processes queries"
          ],
          "correct": 0,
          "explanation": "Search engines need language-specific analyzers for stemming, tokenization, etc. Accept language parameter and route to appropriate analyzer.",
          "detailedExplanation": "Search engines need language-specific analyzers for stemming, tokenization, etc. Accept language parameter and route to appropriate analyzer. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "What about searching content that exists in multiple languages?",
          "options": [
            "Index each language version, search specified language(s)",
            "Translate query to all languages",
            "Only index primary language",
            "Store all languages in one field"
          ],
          "correct": 0,
          "explanation": "Index each language version separately with appropriate analyzers. Let users specify which language(s) to search.",
          "detailedExplanation": "Index each language version separately with appropriate analyzers. Let users specify which language(s) to search. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-060",
      "type": "ordering",
      "question": "Order these API testing types from fastest/cheapest to slowest/most expensive:",
      "items": [
        "Unit tests for handlers",
        "Contract tests",
        "Integration tests with mocked services",
        "End-to-end tests against real services",
        "Production smoke tests"
      ],
      "correctOrder": [0, 2, 1, 3, 4],
      "explanation": "Unit tests are fastest. Integration with mocks is quick. Contract tests verify agreements. E2E tests real systems. Production tests are slowest but validate reality.",
      "detailedExplanation": "Unit tests are fastest. Integration with mocks is quick. Contract tests verify agreements. E2E tests real systems. Production tests are slowest but validate reality. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-061",
      "type": "two-stage",
      "question": "You're implementing a recommendations API that should return personalized results.",
      "stages": [
        {
          "question": "How should user context be passed for personalization?",
          "options": [
            "Derive from authentication token, not explicit parameter",
            "Query parameter with user ID",
            "Request body with user profile",
            "Cookie-based identification"
          ],
          "correct": 0,
          "explanation": "User identity should come from authentication, not client-supplied parameters. This prevents impersonation and simplifies the API.",
          "detailedExplanation": "User identity should come from authentication, not client-supplied parameters. This prevents impersonation and simplifies the API. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "How should the API handle new users with no history?",
          "options": [
            "Return popular/default recommendations with explanation",
            "Return empty results",
            "Error indicating insufficient data",
            "Require onboarding first"
          ],
          "correct": 0,
          "explanation": "Gracefully degrade to popularity-based or default recommendations. Don't fail or return empty—provide value even with limited data.",
          "detailedExplanation": "Gracefully degrade to popularity-based or default recommendations. Don't fail or return empty—provide value even with limited data. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-062",
      "type": "multi-select",
      "question": "Your recommendations API response should include:",
      "options": [
        "Recommended items with relevance scores",
        "Explanation for why items were recommended",
        "Fallback indicator if personalization unavailable",
        "Full user profile"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "Return items with scores, explanations for transparency, and indicate when falling back to non-personalized results. Don't echo back full user profile—privacy concern.",
      "detailedExplanation": "Return items with scores, explanations for transparency, and indicate when falling back to non-personalized results. Don't echo back full user profile—privacy concern. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-063",
      "type": "two-stage",
      "question": "You're designing a configuration API for a SaaS product. Users can customize settings for their account.",
      "stages": [
        {
          "question": "How should hierarchical settings be modeled? (org → team → user)",
          "options": [
            "Merged configuration endpoint showing effective values with inheritance",
            "Separate endpoints per level",
            "Flat structure with all settings",
            "Client-side merging"
          ],
          "correct": 0,
          "explanation": "Provide an endpoint returning effective configuration with inheritance applied. Include metadata about where each value came from for transparency.",
          "detailedExplanation": "Provide an endpoint returning effective configuration with inheritance applied. Include metadata about where each value came from for transparency. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "How should overrides at lower levels be represented?",
          "options": [
            "PATCH to specific level, API shows override source in response",
            "DELETE to remove override, PATCH to set",
            "Different endpoints for override vs default",
            "Versioned configuration objects"
          ],
          "correct": 0,
          "explanation": "PATCH the specific level to override. The response should indicate which level each setting comes from (inherited vs overridden).",
          "detailedExplanation": "PATCH the specific level to override. The response should indicate which level each setting comes from (inherited vs overridden). Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-064",
      "type": "multiple-choice",
      "question": "An API consumer wants to receive events in order. Your system processes events in parallel. What should you do?",
      "options": [
        "Include sequence numbers; consumer reorders",
        "Force sequential processing (slower)",
        "Warn that ordering isn't guaranteed",
        "Timestamp-based ordering"
      ],
      "correct": 0,
      "explanation": "Include sequence numbers in events. Consumers can buffer briefly and reorder if needed. This balances performance (parallel processing) with consumer needs.",
      "detailedExplanation": "Include sequence numbers in events. Consumers can buffer briefly and reorder if needed. This balances performance (parallel processing) with consumer needs. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ]
    },
    {
      "id": "api-065",
      "type": "two-stage",
      "question": "Your event stream API delivers thousands of events per second to consumers.",
      "stages": [
        {
          "question": "What delivery mechanism is most appropriate?",
          "options": [
            "Persistent connection (WebSocket or gRPC stream)",
            "HTTP polling",
            "Webhooks for each event",
            "Email notifications"
          ],
          "correct": 0,
          "explanation": "High-volume event streams need persistent connections. WebSocket or gRPC streaming eliminates connection overhead for each event.",
          "detailedExplanation": "High-volume event streams need persistent connections. WebSocket or gRPC streaming eliminates connection overhead for each event. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "How should consumers handle backpressure when they can't keep up?",
          "options": [
            "Consumer signals capacity; server throttles or buffers",
            "Drop events consumer can't handle",
            "Disconnect slow consumers",
            "Unlimited buffering"
          ],
          "correct": 0,
          "explanation": "Backpressure mechanisms let consumers signal their processing capacity. The server can buffer (within limits) or slow down to match consumer speed.",
          "detailedExplanation": "Backpressure mechanisms let consumers signal their processing capacity. The server can buffer (within limits) or slow down to match consumer speed. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ]
    },
    {
      "id": "api-066",
      "type": "ordering",
      "question": "Order these approaches for consuming a high-volume event stream by reliability (most to least):",
      "items": [
        "Persistent queue with acknowledgments (Kafka-style)",
        "WebSocket with server-side buffer",
        "Webhooks with retry",
        "HTTP long polling"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Kafka-style queues guarantee delivery with consumer-controlled offset. WebSocket with buffering handles brief disconnects. Webhooks retry on failure. Polling can miss events between polls.",
      "detailedExplanation": "Kafka-style queues guarantee delivery with consumer-controlled offset. WebSocket with buffering handles brief disconnects. Webhooks retry on failure. Polling can miss events between polls. Convert targets into concrete counts and time budgets first, then reason about whether incident frequency and recovery time can satisfy them.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        }
      ]
    },
    {
      "id": "api-067",
      "type": "two-stage",
      "question": "You're designing a workflow API where users define multi-step processes (e.g., approval chains).",
      "stages": [
        {
          "question": "How should workflows be modeled in the API?",
          "options": [
            "Workflow as a resource with steps as embedded objects",
            "Each step as a separate resource with references",
            "Single endpoint with state machine logic",
            "Graph database for workflow definitions"
          ],
          "correct": 0,
          "explanation": "Model workflows as resources containing step definitions. This allows versioning the whole workflow and treating it as a coherent unit.",
          "detailedExplanation": "Model workflows as resources containing step definitions. This allows versioning the whole workflow and treating it as a coherent unit. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "How should workflow execution be tracked?",
          "options": [
            "Separate execution resource linked to workflow definition",
            "In-place updates to workflow resource",
            "Event stream of step completions",
            "Log-based tracking only"
          ],
          "correct": 0,
          "explanation": "Separate workflow definitions (templates) from executions (instances). Each execution tracks progress through the defined workflow.",
          "detailedExplanation": "Separate workflow definitions (templates) from executions (instances). Each execution tracks progress through the defined workflow. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-068",
      "type": "multi-select",
      "question": "Your workflow execution API should support:",
      "options": [
        "Starting new executions",
        "Querying current state",
        "Manual step completion/approval",
        "Cancellation"
      ],
      "correctIndices": [0, 1, 2, 3],
      "explanation": "Complete workflow APIs need: start executions, check status, advance steps (especially for human-in-the-loop), and cancel if needed.",
      "detailedExplanation": "Complete workflow APIs need: start executions, check status, advance steps (especially for human-in-the-loop), and cancel if needed. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-069",
      "type": "two-stage",
      "question": "A third-party developer complains your API is hard to use despite good documentation.",
      "stages": [
        {
          "question": "What's the most likely issue?",
          "options": [
            "Inconsistent conventions across endpoints",
            "Documentation not detailed enough",
            "Too many endpoints",
            "Response times too slow"
          ],
          "correct": 0,
          "explanation": "Inconsistency is a common usability killer. If some endpoints use camelCase and others snake_case, or patterns vary, developers can't build intuition.",
          "detailedExplanation": "Inconsistency is a common usability killer. If some endpoints use camelCase and others snake_case, or patterns vary, developers can't build intuition. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "How should you identify and fix the inconsistencies?",
          "options": [
            "Audit against style guide, fix in next major version",
            "Ask developers to specify issues",
            "Automated linting of OpenAPI spec",
            "Ignore—different endpoints have different needs"
          ],
          "correct": 2,
          "explanation": "Automated linting against a style guide catches inconsistencies systematically. Fix issues in the next appropriate release.",
          "detailedExplanation": "Automated linting against a style guide catches inconsistencies systematically. Fix issues in the next appropriate release. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-070",
      "type": "multiple-choice",
      "question": "Your API has grown to 200+ endpoints. How should they be organized for discoverability?",
      "options": [
        "Logical grouping by resource/domain in documentation",
        "Alphabetical listing",
        "By HTTP method",
        "Single long page"
      ],
      "correct": 0,
      "explanation": "Group endpoints by domain/resource (Users, Orders, Products). Include overview pages explaining the domain model and common workflows.",
      "detailedExplanation": "Group endpoints by domain/resource (Users, Orders, Products). Include overview pages explaining the domain model and common workflows. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-071",
      "type": "two-stage",
      "question": "You need to add caching to your REST API to reduce database load.",
      "stages": [
        {
          "question": "What HTTP caching headers should you implement?",
          "options": [
            "Cache-Control with max-age, ETag for validation",
            "Only Expires header",
            "Custom X-Cache headers",
            "No headers—rely on CDN configuration"
          ],
          "correct": 0,
          "explanation": "Cache-Control directs caching behavior, ETag enables conditional requests for revalidation. Together they enable efficient client and CDN caching.",
          "detailedExplanation": "Cache-Control directs caching behavior, ETag enables conditional requests for revalidation. Together they enable efficient client and CDN caching. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "How should the API handle personalized responses that shouldn't be cached by shared caches?",
          "options": [
            "Cache-Control: private",
            "Cache-Control: no-cache",
            "Cache-Control: no-store",
            "Don't return personalized data"
          ],
          "correct": 0,
          "explanation": "Cache-Control: private allows browser caching but prevents shared caches (CDNs, proxies) from storing the personalized response.",
          "detailedExplanation": "Cache-Control: private allows browser caching but prevents shared caches (CDNs, proxies) from storing the personalized response. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ]
    },
    {
      "id": "api-072",
      "type": "multi-select",
      "question": "Which responses typically SHOULD be cached in a REST API?",
      "options": [
        "GET requests for static resources",
        "GET requests for public, rarely-changing data",
        "User profile GET requests",
        "POST/PUT/DELETE responses"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "Static resources and rarely-changing data should be cached. User profiles can be cached with private directive. Mutations (POST/PUT/DELETE) typically shouldn't be cached.",
      "detailedExplanation": "Static resources and rarely-changing data should be cached. User profiles can be cached with private directive. Mutations (POST/PUT/DELETE) typically shouldn't be cached. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-073",
      "type": "two-stage",
      "question": "You're designing an API for a gaming platform. Players can challenge others to matches.",
      "stages": [
        {
          "question": "How should challenge creation be modeled?",
          "options": [
            "POST /challenges with challenger and opponent",
            "POST to both /users/{id}/sent-challenges and /users/{id}/received-challenges",
            "PUT /matches/{id} with status: pending",
            "POST /users/{challengerId}/challenge/{opponentId}"
          ],
          "correct": 0,
          "explanation": "POST to a challenges collection is clean REST. Include both parties in the request body. The resource exists independently of either user.",
          "detailedExplanation": "POST to a challenges collection is clean REST. Include both parties in the request body. The resource exists independently of either user. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "How should the opponent accept/decline?",
          "options": [
            "POST /challenges/{id}/accept or /challenges/{id}/decline",
            "DELETE challenge to decline, PATCH status to accept",
            "PUT /challenges/{id} with new status",
            "Separate endpoints per outcome"
          ],
          "correct": 0,
          "explanation": "Action-based endpoints make intent clear. Accept and decline are distinct business actions, not just state changes.",
          "detailedExplanation": "Action-based endpoints make intent clear. Accept and decline are distinct business actions, not just state changes. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-074",
      "type": "ordering",
      "question": "Order these steps for API performance troubleshooting:",
      "items": [
        "Identify slow endpoints from metrics",
        "Profile to find bottlenecks (DB, network, CPU)",
        "Implement targeted optimizations",
        "Verify improvement with benchmarks",
        "Monitor for regression"
      ],
      "correctOrder": [0, 1, 2, 3, 4],
      "explanation": "Start with metrics to find problems, profile to understand causes, implement fixes, verify they worked, then monitor ongoing performance.",
      "detailedExplanation": "Start with metrics to find problems, profile to understand causes, implement fixes, verify they worked, then monitor ongoing performance. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-075",
      "type": "two-stage",
      "question": "Your API's p99 latency spiked from 200ms to 2 seconds after a deployment.",
      "stages": [
        {
          "question": "What's the first step to diagnose?",
          "options": [
            "Compare traces/logs before and after deployment",
            "Rollback immediately",
            "Scale up servers",
            "Wait to see if it resolves"
          ],
          "correct": 0,
          "explanation": "Compare what changed. Look at distributed traces, error rates, and database query times before and after. Identify what's different.",
          "detailedExplanation": "Compare what changed. Look at distributed traces, error rates, and database query times before and after. Identify what's different. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "Traces show a new N+1 query pattern. What's the fix?",
          "options": [
            "Batch the queries (DataLoader pattern) or eager load",
            "Add more database replicas",
            "Increase query timeout",
            "Cache all responses"
          ],
          "correct": 0,
          "explanation": "N+1 queries should be batched or the data should be eager-loaded in the initial query. More replicas just spread the problem.",
          "detailedExplanation": "N+1 queries should be batched or the data should be eager-loaded in the initial query. More replicas just spread the problem. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Convert targets into concrete counts and time budgets first, then reason about whether incident frequency and recovery time can satisfy them.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Percentile",
          "url": "https://en.wikipedia.org/wiki/Percentile"
        }
      ]
    },
    {
      "id": "api-076",
      "type": "multi-select",
      "question": "Your API performance metrics should include:",
      "options": [
        "Response time percentiles (p50, p95, p99)",
        "Error rates by endpoint and status code",
        "Request volume/throughput",
        "Database query counts per request"
      ],
      "correctIndices": [0, 1, 2, 3],
      "explanation": "All are essential: latency percentiles (not just averages), error breakdown, volume for capacity planning, and query counts to detect N+1 issues.",
      "detailedExplanation": "All are essential: latency percentiles (not just averages), error breakdown, volume for capacity planning, and query counts to detect N+1 issues. Convert targets into concrete counts and time budgets first, then reason about whether incident frequency and recovery time can satisfy them.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ]
    },
    {
      "id": "api-077",
      "type": "two-stage",
      "question": "You're designing a comments API for a news site. Articles can have thousands of comments.",
      "stages": [
        {
          "question": "How should top-level comments be paginated?",
          "options": [
            "Cursor-based, sorted by newest or most upvoted",
            "Load all comments",
            "Fixed pages of 20",
            "Nested inside article response"
          ],
          "correct": 0,
          "explanation": "Cursor-based pagination for large comment sets. Allow sorting options (newest, popular) to match user preferences.",
          "detailedExplanation": "Cursor-based pagination for large comment sets. Allow sorting options (newest, popular) to match user preferences. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "How should nested replies be handled?",
          "options": [
            "Separate endpoint to load replies for a comment",
            "Include all replies inline (risks huge responses)",
            "Limit nesting depth, link to full thread",
            "Flat list with parent IDs"
          ],
          "correct": 0,
          "explanation": "Lazy-load replies: return top-level comments with reply count, let clients fetch replies for expanded threads. Prevents massive initial payloads.",
          "detailedExplanation": "Lazy-load replies: return top-level comments with reply count, let clients fetch replies for expanded threads. Prevents massive initial payloads. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-078",
      "type": "multiple-choice",
      "question": "A comment tree can be 10 levels deep. How should the API represent this?",
      "options": [
        "Flat list with parent_id, client builds tree",
        "Deeply nested JSON object",
        "Recursive endpoint calls per level",
        "Limit to 3 levels maximum"
      ],
      "correct": 0,
      "explanation": "Return flat list with parent references. Client builds the tree structure. This is efficient to serialize/parse and works regardless of depth.",
      "detailedExplanation": "Return flat list with parent references. Client builds the tree structure. This is efficient to serialize/parse and works regardless of depth. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-079",
      "type": "two-stage",
      "question": "Your API needs to support batch operations—create 100 users in one request.",
      "stages": [
        {
          "question": "How should the batch endpoint be designed?",
          "options": [
            "POST /users/batch with array of users in body",
            "100 parallel POST /users requests",
            "CSV upload endpoint",
            "PUT /users with all users"
          ],
          "correct": 0,
          "explanation": "A dedicated batch endpoint accepts an array and processes efficiently. Separate from single-item creation for different validation and response handling.",
          "detailedExplanation": "A dedicated batch endpoint accepts an array and processes efficiently. Separate from single-item creation for different validation and response handling. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "If 3 out of 100 users fail validation, what should the response be?",
          "options": [
            "200 with per-item results showing successes and failures",
            "400 with all errors (no users created)",
            "201 with partial results",
            "Transaction: all or nothing"
          ],
          "correct": 0,
          "explanation": "Return 200 with detailed per-item status. Clients can identify which items failed and why. Whether to use all-or-nothing depends on use case.",
          "detailedExplanation": "Return 200 with detailed per-item status. Clients can identify which items failed and why. Whether to use all-or-nothing depends on use case. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-080",
      "type": "ordering",
      "question": "Order batch operation strategies by data integrity (highest to lowest):",
      "items": [
        "All-or-nothing transaction",
        "Process all, report all results",
        "Stop at first error",
        "Best effort (ignore errors)"
      ],
      "correctOrder": [0, 2, 1, 3],
      "explanation": "All-or-nothing ensures complete consistency. Stop-on-error prevents further issues after failure. Process-all returns mixed results. Best-effort is least reliable.",
      "detailedExplanation": "All-or-nothing ensures complete consistency. Stop-on-error prevents further issues after failure. Process-all returns mixed results. Best-effort is least reliable. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        }
      ]
    },
    {
      "id": "api-081",
      "type": "two-stage",
      "question": "Your analytics API needs to aggregate data across millions of events.",
      "stages": [
        {
          "question": "How should the API handle queries that take 30+ seconds?",
          "options": [
            "Async query with job ID, poll for results",
            "Synchronous with long timeout",
            "Pre-computed aggregates only",
            "Stream partial results"
          ],
          "correct": 0,
          "explanation": "Long-running analytics queries should be async. Client submits query, receives job ID, polls or gets webhook when results are ready.",
          "detailedExplanation": "Long-running analytics queries should be async. Client submits query, receives job ID, polls or gets webhook when results are ready. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "How can you make common queries faster?",
          "options": [
            "Pre-aggregate popular dimensions, cache results",
            "Faster hardware",
            "Limit query complexity",
            "Require reservations"
          ],
          "correct": 0,
          "explanation": "Pre-compute common aggregations (daily/weekly rollups). Cache query results with appropriate TTL. Reduces computation for frequent queries.",
          "detailedExplanation": "Pre-compute common aggregations (daily/weekly rollups). Cache query results with appropriate TTL. Reduces computation for frequent queries. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-082",
      "type": "multi-select",
      "question": "Your analytics API should protect against expensive queries. What limits should you implement?",
      "options": [
        "Maximum time range for queries",
        "Maximum number of dimensions/groupings",
        "Query cost estimation before execution",
        "Required aggregation (no raw event access)"
      ],
      "correctIndices": [0, 1, 2],
      "explanation": "Limit time ranges and complexity, estimate costs upfront. Raw event access might be needed for debugging—don't always require aggregation.",
      "detailedExplanation": "Limit time ranges and complexity, estimate costs upfront. Raw event access might be needed for debugging—don't always require aggregation. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ]
    },
    {
      "id": "api-083",
      "type": "two-stage",
      "question": "You're designing an API for a calendar application with recurring events.",
      "stages": [
        {
          "question": "How should recurring events be represented?",
          "options": [
            "Store pattern (RRULE), expand instances on query",
            "Pre-generate all instances",
            "Store only next occurrence",
            "Client-side expansion"
          ],
          "correct": 0,
          "explanation": "Store the recurrence pattern (using RRULE standard). Expand to instances within the requested date range at query time.",
          "detailedExplanation": "Store the recurrence pattern (using RRULE standard). Expand to instances within the requested date range at query time. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "How should modifications to a single occurrence be handled?",
          "options": [
            "Exception record that overrides the pattern for that date",
            "Split into two series",
            "Modify the pattern",
            "Store as separate non-recurring event"
          ],
          "correct": 0,
          "explanation": "Store exceptions—instances that differ from the pattern. This preserves the recurring series while allowing individual modifications.",
          "detailedExplanation": "Store exceptions—instances that differ from the pattern. This preserves the recurring series while allowing individual modifications. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-084",
      "type": "multiple-choice",
      "question": "Your calendar API needs to handle timezone changes (user moves, daylight saving). What's the best approach?",
      "options": [
        "Store in UTC with original timezone, convert at display",
        "Store in user's local timezone",
        "Store as floating time (no timezone)",
        "Require all times in UTC"
      ],
      "correct": 0,
      "explanation": "Store UTC timestamp plus the intended timezone. This allows correct display regardless of user's current location and handles DST correctly.",
      "detailedExplanation": "Store UTC timestamp plus the intended timezone. This allows correct display regardless of user's current location and handles DST correctly. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-085",
      "type": "two-stage",
      "question": "Your API serves a mobile app. Users complain about slow startup.",
      "stages": [
        {
          "question": "What API pattern can improve cold start performance?",
          "options": [
            "Bootstrap endpoint returning all initial data in one call",
            "Parallel requests for each data type",
            "Aggressive prefetching",
            "Smaller payloads only"
          ],
          "correct": 0,
          "explanation": "A bootstrap/initialize endpoint returns all data needed for initial render in one request, minimizing round trips during startup.",
          "detailedExplanation": "A bootstrap/initialize endpoint returns all data needed for initial render in one request, minimizing round trips during startup. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "How should you design the bootstrap endpoint?",
          "options": [
            "Configurable sections to include/exclude",
            "Fixed response with everything",
            "GraphQL query",
            "Multiple small bootstrap endpoints"
          ],
          "correct": 0,
          "explanation": "Let clients specify what they need (?include=user,settings,notifications). Different screens might need different initial data.",
          "detailedExplanation": "Let clients specify what they need (?include=user,settings,notifications). Different screens might need different initial data. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-086",
      "type": "ordering",
      "question": "Order these mobile API optimization techniques by impact (highest to lowest):",
      "items": [
        "Reduce round trips (aggregate endpoints)",
        "Compress responses (gzip)",
        "Minimize payload size (needed fields only)",
        "Persistent connections",
        "Binary format (protobuf)"
      ],
      "correctOrder": [0, 2, 1, 3, 4],
      "explanation": "Fewer round trips has biggest impact on mobile latency. Smaller payloads matter most for limited bandwidth. Compression helps. Persistent connections and binary formats provide incremental gains.",
      "detailedExplanation": "Fewer round trips has biggest impact on mobile latency. Smaller payloads matter most for limited bandwidth. Compression helps. Persistent connections and binary formats provide incremental gains. Convert targets into concrete counts and time budgets first, then reason about whether incident frequency and recovery time can satisfy them.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        }
      ]
    },
    {
      "id": "api-087",
      "type": "two-stage",
      "question": "Your mobile app needs offline support. Users edit data while offline and sync when connected.",
      "stages": [
        {
          "question": "How should the sync API handle conflicting edits?",
          "options": [
            "Return conflicts for client resolution, or use last-write-wins with timestamps",
            "Server always wins",
            "Client always wins",
            "Reject all offline edits"
          ],
          "correct": 0,
          "explanation": "Conflict resolution strategy depends on data type. Some fields can use last-write-wins with timestamps; others need client-side merge UI.",
          "detailedExplanation": "Conflict resolution strategy depends on data type. Some fields can use last-write-wins with timestamps; others need client-side merge UI. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "How should the API communicate sync status?",
          "options": [
            "Return detailed results: synced, conflicted, failed per item",
            "Simple success/failure",
            "Only sync counts",
            "Require client to query each item"
          ],
          "correct": 0,
          "explanation": "Detailed per-item results let clients update local state, show appropriate UI for conflicts, and retry failed items.",
          "detailedExplanation": "Detailed per-item results let clients update local state, show appropriate UI for conflicts, and retry failed items. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-088",
      "type": "multi-select",
      "question": "Your offline-capable sync API should support:",
      "options": [
        "Delta sync (only changes since last sync)",
        "Conflict detection and resolution",
        "Tombstones for deleted items",
        "Full resync capability"
      ],
      "correctIndices": [0, 1, 2, 3],
      "explanation": "Delta sync minimizes data transfer. Conflict handling is essential. Tombstones track deletions. Full resync handles corruption/edge cases.",
      "detailedExplanation": "Delta sync minimizes data transfer. Conflict handling is essential. Tombstones track deletions. Full resync handles corruption/edge cases. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-089",
      "type": "two-stage",
      "question": "You're designing an API for a job board. Employers post jobs, candidates apply.",
      "stages": [
        {
          "question": "How should job applications be modeled?",
          "options": [
            "Application as its own resource linking job and candidate",
            "Nested under jobs: /jobs/{id}/applications",
            "Nested under candidates: /candidates/{id}/applications",
            "No explicit resource—just events"
          ],
          "correct": 0,
          "explanation": "Applications are first-class resources with their own lifecycle (submitted, reviewed, interviewed, offered). Both employers and candidates need access.",
          "detailedExplanation": "Applications are first-class resources with their own lifecycle (submitted, reviewed, interviewed, offered). Both employers and candidates need access. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "How should permissions work for viewing applications?",
          "options": [
            "Employers see applications to their jobs; candidates see their own applications",
            "All applications public",
            "Only candidates see applications",
            "Separate endpoints per role"
          ],
          "correct": 0,
          "explanation": "Filter based on authenticated user's role: employers see applications to jobs they own, candidates see applications they submitted.",
          "detailedExplanation": "Filter based on authenticated user's role: employers see applications to jobs they own, candidates see applications they submitted. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-090",
      "type": "ordering",
      "question": "Order API launch activities (first to last):",
      "items": [
        "Internal alpha testing",
        "Private beta with select partners",
        "Public beta with rate limits",
        "General availability",
        "Deprecate beta endpoints"
      ],
      "correctOrder": [0, 1, 2, 3, 4],
      "explanation": "Test internally, expand to trusted partners, open beta with protections, then GA. Deprecate beta-specific endpoints after migration.",
      "detailedExplanation": "Test internally, expand to trusted partners, open beta with protections, then GA. Deprecate beta-specific endpoints after migration. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-091",
      "type": "two-stage",
      "question": "Your API is launching to the public. You expect significant traffic.",
      "stages": [
        {
          "question": "What should you implement before launch?",
          "options": [
            "Rate limiting, monitoring, and scaling plan",
            "All possible features",
            "GraphQL alongside REST",
            "Beta tags on all endpoints"
          ],
          "correct": 0,
          "explanation": "Protect the API with rate limits, have monitoring to detect issues, and a scaling plan for handling growth. Launch with essential features.",
          "detailedExplanation": "Protect the API with rate limits, have monitoring to detect issues, and a scaling plan for handling growth. Launch with essential features. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "How should you handle the initial traffic uncertainty?",
          "options": [
            "Start with conservative rate limits, increase based on observed behavior",
            "No limits initially to maximize adoption",
            "Very strict limits for everyone",
            "Invite-only access indefinitely"
          ],
          "correct": 0,
          "explanation": "Start conservative to protect infrastructure, then relax limits as you understand usage patterns and validate capacity.",
          "detailedExplanation": "Start conservative to protect infrastructure, then relax limits as you understand usage patterns and validate capacity. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-092",
      "type": "multi-select",
      "question": "Before deprecating an API version, what should you ensure?",
      "options": [
        "Migration path documented",
        "Sufficient notice period given",
        "Usage metrics show most traffic migrated",
        "New version feature parity"
      ],
      "correctIndices": [0, 1, 2, 3],
      "explanation": "All are important: document how to migrate, give adequate warning, verify actual migration progress, and ensure no functionality lost.",
      "detailedExplanation": "All are important: document how to migrate, give adequate warning, verify actual migration progress, and ensure no functionality lost. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-093",
      "type": "two-stage",
      "question": "A partner requests a custom endpoint that doesn't fit your API's resource model.",
      "stages": [
        {
          "question": "How should you evaluate the request?",
          "options": [
            "Assess if it's a general need vs truly custom",
            "Build it immediately to keep the partner happy",
            "Refuse all custom requests",
            "Add to backlog for later"
          ],
          "correct": 0,
          "explanation": "Determine if other clients might benefit. A custom need might reveal a gap in your API. But truly one-off customizations should be avoided.",
          "detailedExplanation": "Determine if other clients might benefit. A custom need might reveal a gap in your API. But truly one-off customizations should be avoided. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "If it's truly partner-specific, what's the best approach?",
          "options": [
            "Partner builds their own aggregation layer over your existing endpoints",
            "Add the custom endpoint",
            "Modify existing endpoints with partner flag",
            "Build separate partner API"
          ],
          "correct": 0,
          "explanation": "Encourage partners to build their own BFF/aggregation over your general-purpose endpoints. Keeps your API consistent.",
          "detailedExplanation": "Encourage partners to build their own BFF/aggregation over your general-purpose endpoints. Keeps your API consistent. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-094",
      "type": "multiple-choice",
      "question": "An enterprise customer requires your API to work within their VPN (no internet access). What's the solution?",
      "options": [
        "On-premise deployment option or API proxy in their network",
        "Require internet access",
        "VPN tunnel to your cloud",
        "Export/import via files"
      ],
      "correct": 0,
      "explanation": "Enterprise scenarios may require on-premise deployment or a proxy component in their network that syncs with your cloud service.",
      "detailedExplanation": "Enterprise scenarios may require on-premise deployment or a proxy component in their network that syncs with your cloud service. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        }
      ]
    },
    {
      "id": "api-095",
      "type": "two-stage",
      "question": "Your API documentation site goes down during a critical partner integration.",
      "stages": [
        {
          "question": "How could this have been prevented?",
          "options": [
            "Static documentation with CDN caching",
            "Separate docs infrastructure from API",
            "Real-time generated docs only",
            "Print backup"
          ],
          "correct": 0,
          "explanation": "Documentation should be highly available—static files served via CDN. Separate from API infrastructure to avoid correlated failures.",
          "detailedExplanation": "Documentation should be highly available—static files served via CDN. Separate from API infrastructure to avoid correlated failures. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "What additional resources should you provide for critical integrations?",
          "options": [
            "Downloadable OpenAPI spec and SDK packages",
            "Phone support only",
            "Video tutorials only",
            "Nothing—website is enough"
          ],
          "correct": 0,
          "explanation": "Downloadable specs, SDKs, and offline docs ensure developers can work even when online resources are unavailable.",
          "detailedExplanation": "Downloadable specs, SDKs, and offline docs ensure developers can work even when online resources are unavailable. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-096",
      "type": "ordering",
      "question": "Order these developer resources by importance for API adoption:",
      "items": [
        "Clear getting started guide",
        "Complete reference documentation",
        "SDKs in popular languages",
        "Code samples for common use cases",
        "Interactive API explorer"
      ],
      "correctOrder": [0, 3, 1, 2, 4],
      "explanation": "Getting started gets developers to first success. Samples show patterns. Reference is essential but intimidating first. SDKs and explorers enhance experience.",
      "detailedExplanation": "Getting started gets developers to first success. Samples show patterns. Reference is essential but intimidating first. SDKs and explorers enhance experience. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-097",
      "type": "two-stage",
      "question": "You're designing an API for a marketplace with auctions.",
      "stages": [
        {
          "question": "How should bid placement be handled?",
          "options": [
            "POST /auctions/{id}/bids with optimistic locking",
            "PUT /auctions/{id}/current-bid",
            "Real-time WebSocket only",
            "Email bids to seller"
          ],
          "correct": 0,
          "explanation": "Bids are resources in a collection. Use optimistic locking (include current price in bid) to handle concurrent bidding fairly.",
          "detailedExplanation": "Bids are resources in a collection. Use optimistic locking (include current price in bid) to handle concurrent bidding fairly. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "How should clients receive outbid notifications?",
          "options": [
            "WebSocket subscription or webhooks based on client preference",
            "Polling only",
            "Email only",
            "Push notification only"
          ],
          "correct": 0,
          "explanation": "Offer multiple channels: WebSocket for real-time apps, webhooks for integrations, push for mobile. Let clients choose their preference.",
          "detailedExplanation": "Offer multiple channels: WebSocket for real-time apps, webhooks for integrations, push for mobile. Let clients choose their preference. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-098",
      "type": "multi-select",
      "question": "You're designing a loyalty points API. What operations need special attention?",
      "options": [
        "Points earning (prevent fraud)",
        "Points redemption (prevent double-spend)",
        "Points expiration (batch processing)",
        "Points transfer between users"
      ],
      "correctIndices": [0, 1, 2, 3],
      "explanation": "All need care: earning needs fraud prevention, redemption needs idempotency, expiration needs efficient batch processing, transfers need atomic operations.",
      "detailedExplanation": "All need care: earning needs fraud prevention, redemption needs idempotency, expiration needs efficient batch processing, transfers need atomic operations. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-099",
      "type": "two-stage",
      "question": "Your API experiences a cascade failure—one slow downstream service causes all requests to fail.",
      "stages": [
        {
          "question": "What pattern should prevent this?",
          "options": [
            "Circuit breaker to isolate failing dependencies",
            "Longer timeouts",
            "More retries",
            "Bigger connection pools"
          ],
          "correct": 0,
          "explanation": "Circuit breakers detect dependency failures and fail fast, preventing the slow service from consuming resources and cascading failures.",
          "detailedExplanation": "Circuit breakers detect dependency failures and fail fast, preventing the slow service from consuming resources and cascading failures. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        },
        {
          "question": "What should happen when the circuit breaker opens?",
          "options": [
            "Return cached data or graceful degradation response",
            "Wait for service to recover",
            "Retry continuously",
            "Error for all endpoints"
          ],
          "correct": 0,
          "explanation": "Graceful degradation: return cached data, default values, or partial responses. Don't fail entirely if only one dependency is down.",
          "detailedExplanation": "Graceful degradation: return cached data, default values, or partial responses. Don't fail entirely if only one dependency is down. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers."
        }
      ],
      "detailedExplanation": "Apply the relevant estimation formula and verify units. Call out compatibility and client impact explicitly; strong API design answers show how the interface evolves without breaking existing consumers.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "api-100",
      "type": "ordering",
      "question": "Order these reliability patterns by when they activate (earliest to latest in a failure scenario):",
      "items": [
        "Timeout",
        "Retry with backoff",
        "Circuit breaker opens",
        "Fallback/degradation",
        "Alert to operations team"
      ],
      "correctOrder": [0, 1, 2, 3, 4],
      "explanation": "Timeout triggers first when a call is slow. Retries attempt recovery. Circuit opens after repeated failures. Fallbacks provide degraded service. Alerts notify humans for investigation.",
      "detailedExplanation": "Timeout triggers first when a call is slow. Retries attempt recovery. Circuit opens after repeated failures. Fallbacks provide degraded service. Alerts notify humans for investigation. Convert targets into concrete counts and time budgets first, then reason about whether incident frequency and recovery time can satisfy them.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        }
      ]
    }
  ]
}
