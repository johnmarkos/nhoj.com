{
  "unit": 8,
  "unitTitle": "Consistency & Coordination",
  "chapter": 3,
  "chapterTitle": "Time, Ordering & Causality",
  "chapterDescription": "Modeling distributed event order under clock skew, reordering, and concurrency using logical clocks and causal metadata.",
  "problems": [
    {
      "id": "cc-tc-001",
      "type": "multiple-choice",
      "question": "A multi-device messaging feed is experiencing clock skew between regions. Which time/ordering strategy is strongest? Recent incident analysis links user-visible regressions to ordering assumptions.",
      "options": [
        "Use causal metadata (vector clocks/causal context) where dependent event order matters.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally."
      ],
      "correct": 0,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A multi-device messaging feed is experiencing clock skew between regions, this option best addresses the stated constraints in Time, Ordering & Causality.",
      "detailedExplanation": "The key clue in this question is \"multi-device messaging feed is experiencing clock skew between regions\". Eliminate answers that do not directly address the failure mode, recovery path, or blast radius. Tie the decision to concrete operational outcomes, not abstract reliability language. Common pitfall: meeting average goals while missing tail-risk.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-002",
      "type": "multiple-choice",
      "question": "A collaborative document editor is experiencing out-of-order event arrival. Which time/ordering strategy is strongest? The team needs a low-blast-radius first mitigation.",
      "options": [
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Separate wall-clock display time from correctness ordering logic using logical clocks."
      ],
      "correct": 3,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A collaborative document editor is experiencing out-of-order event arrival, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "Read this as a scenario about \"collaborative document editor is experiencing out-of-order event arrival\". Prefer the choice that keeps ordering/acknowledgment behavior predictable under failure. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. Common pitfall: ordering loss during partition or replay changes.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-003",
      "type": "multiple-choice",
      "question": "An inventory event processor is experiencing causal dependency not preserved. Which time/ordering strategy is strongest? Cross-region skew increased during the latest outage drill.",
      "options": [
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Use Lamport/logical sequence for deterministic processing order when real-time order is unreliable.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions."
      ],
      "correct": 2,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For an inventory event processor is experiencing causal dependency not preserved, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality.",
      "detailedExplanation": "The decision turns on \"inventory event processor is experiencing causal dependency not preserved\". Prefer the choice that keeps ordering/acknowledgment behavior predictable under failure. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. Common pitfall: assuming exactly-once without idempotency.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-004",
      "type": "multiple-choice",
      "question": "A payment reconciliation pipeline is experiencing concurrent writes from multiple clients. Which time/ordering strategy is strongest? Concurrent client updates now occur more frequently.",
      "options": [
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Define merge/conflict policy for concurrent updates and preserve causality where required.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions."
      ],
      "correct": 1,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A payment reconciliation pipeline is experiencing concurrent writes from multiple clients, this response is the most defensible call for Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "This prompt is really about \"payment reconciliation pipeline is experiencing concurrent writes from multiple clients\". Prefer the option that preserves correctness guarantees for the stated consistency boundary. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-005",
      "type": "multiple-choice",
      "question": "A ride dispatch event stream is experiencing late-arriving updates after retries. Which time/ordering strategy is strongest? Replay traffic after retries is higher than expected.",
      "options": [
        "Treat physical timestamps as hints; validate order with causal/version metadata.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally."
      ],
      "correct": 0,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A ride dispatch event stream is experiencing late-arriving updates after retries, this option best addresses the stated constraints in Time, Ordering & Causality.",
      "detailedExplanation": "Use \"ride dispatch event stream is experiencing late-arriving updates after retries\" as your starting point, then verify tradeoffs carefully. Eliminate options that ignore delivery semantics or backpressure behavior. A good message-system answer defines guarantees clearly for both producer and consumer paths. Common pitfall: consumer lag growth under burst traffic.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-006",
      "type": "multiple-choice",
      "question": "A support ticket workflow service is experiencing NTP drift under partial network issues. Which time/ordering strategy is strongest? Current logic mixes display time with correctness ordering.",
      "options": [
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Add per-entity monotonic version checks to reject stale reordered writes."
      ],
      "correct": 3,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A support ticket workflow service is experiencing NTP drift under partial network issues, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "The core signal here is \"support ticket workflow service is experiencing NTP drift under partial network issues\". Eliminate approaches that hand-wave conflict resolution or quorum behavior. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-007",
      "type": "multiple-choice",
      "question": "A notification timeline service is experiencing event timestamp collisions. Which time/ordering strategy is strongest? Anomaly alerts spike during failover and backlog recovery.",
      "options": [
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Use idempotent replay handling with causal guards for delayed events.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions."
      ],
      "correct": 2,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A notification timeline service is experiencing event timestamp collisions, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality.",
      "detailedExplanation": "If you keep \"notification timeline service is experiencing event timestamp collisions\" in view, the correct answer separates faster. Prioritize the option that best protects the reliability objective under the stated failure conditions. Tie the decision to concrete operational outcomes, not abstract reliability language. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-008",
      "type": "multiple-choice",
      "question": "An order lifecycle event bus is experiencing reordered queue delivery after failover. Which time/ordering strategy is strongest? The fix must preserve throughput on non-critical streams.",
      "options": [
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Partition ordering-sensitive streams and avoid cross-partition total-order assumptions.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions."
      ],
      "correct": 1,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For an order lifecycle event bus is experiencing reordered queue delivery after failover, this response is the most defensible call for Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "Start from \"order lifecycle event bus is experiencing reordered queue delivery after failover\", then pressure-test the result against the options. Reject choices that sound good generally but do not reduce the concrete reliability risk in this scenario. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-009",
      "type": "multiple-choice",
      "question": "A social comment thread backend is experiencing duplicate event replay with old timestamps. Which time/ordering strategy is strongest? Causal dependencies are not explicitly encoded today.",
      "options": [
        "Expose uncertainty when causal order cannot be established from available metadata.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally."
      ],
      "correct": 0,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A social comment thread backend is experiencing duplicate event replay with old timestamps, this option best addresses the stated constraints in Time, Ordering & Causality.",
      "detailedExplanation": "The key clue in this question is \"social comment thread backend is experiencing duplicate event replay with old timestamps\". Prefer the choice that keeps ordering/acknowledgment behavior predictable under failure. A good message-system answer defines guarantees clearly for both producer and consumer paths. Common pitfall: consumer lag growth under burst traffic.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-010",
      "type": "multiple-choice",
      "question": "A feature-flag propagation service is experiencing mixed wall-clock and logical ordering assumptions. Which time/ordering strategy is strongest? Support reports timeline reversals across devices.",
      "options": [
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Instrument skew and reordering metrics; gate critical workflows when ordering confidence drops."
      ],
      "correct": 3,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A feature-flag propagation service is experiencing mixed wall-clock and logical ordering assumptions, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "The decision turns on \"feature-flag propagation service is experiencing mixed wall-clock and logical ordering\". Prefer the option that preserves correctness guarantees for the stated consistency boundary. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-011",
      "type": "multiple-choice",
      "question": "A profile update event system is experiencing clock skew between regions. Which time/ordering strategy is strongest? The service recently moved to multi-region active-active mode.",
      "options": [
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Use causal metadata (vector clocks/causal context) where dependent event order matters.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions."
      ],
      "correct": 2,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A profile update event system is experiencing clock skew between regions, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality.",
      "detailedExplanation": "Read this as a scenario about \"profile update event system is experiencing clock skew between regions\". Prefer the choice that keeps ordering/acknowledgment behavior predictable under failure. Throughput is only one part; replay behavior and consumer lag handling matter equally. Common pitfall: ordering loss during partition or replay changes.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-012",
      "type": "multiple-choice",
      "question": "A moderation review queue is experiencing out-of-order event arrival. Which time/ordering strategy is strongest? Queue guarantees differ across partitions and brokers.",
      "options": [
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Separate wall-clock display time from correctness ordering logic using logical clocks.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions."
      ],
      "correct": 1,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A moderation review queue is experiencing out-of-order event arrival, this response is the most defensible call for Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "The key clue in this question is \"moderation review queue is experiencing out-of-order event arrival\". Eliminate options that ignore delivery semantics or backpressure behavior. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. Common pitfall: consumer lag growth under burst traffic.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-013",
      "type": "multiple-choice",
      "question": "A chat read-receipt service is experiencing causal dependency not preserved. Which time/ordering strategy is strongest? Schema changes introduced metadata compatibility risk.",
      "options": [
        "Use Lamport/logical sequence for deterministic processing order when real-time order is unreliable.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally."
      ],
      "correct": 0,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A chat read-receipt service is experiencing causal dependency not preserved, this option best addresses the stated constraints in Time, Ordering & Causality.",
      "detailedExplanation": "Start from \"chat read-receipt service is experiencing causal dependency not preserved\", then pressure-test the result against the options. Discard choices that violate required invariants during concurrent or failed states. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-014",
      "type": "multiple-choice",
      "question": "An ad campaign state projector is experiencing concurrent writes from multiple clients. Which time/ordering strategy is strongest? Conflict handling policy is currently under-specified.",
      "options": [
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Define merge/conflict policy for concurrent updates and preserve causality where required."
      ],
      "correct": 3,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For an ad campaign state projector is experiencing concurrent writes from multiple clients, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "If you keep \"ad campaign state projector is experiencing concurrent writes from multiple clients\" in view, the correct answer separates faster. Prefer the option that preserves correctness guarantees for the stated consistency boundary. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-015",
      "type": "multiple-choice",
      "question": "A shipment tracking event feed is experiencing late-arriving updates after retries. Which time/ordering strategy is strongest? Leadership requested explicit ordering guarantees per workflow.",
      "options": [
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Treat physical timestamps as hints; validate order with causal/version metadata.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions."
      ],
      "correct": 2,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A shipment tracking event feed is experiencing late-arriving updates after retries, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality.",
      "detailedExplanation": "The core signal here is \"shipment tracking event feed is experiencing late-arriving updates after retries\". Eliminate options that ignore delivery semantics or backpressure behavior. Throughput is only one part; replay behavior and consumer lag handling matter equally. Common pitfall: assuming exactly-once without idempotency.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-016",
      "type": "multiple-choice",
      "question": "A device sync service is experiencing NTP drift under partial network issues. Which time/ordering strategy is strongest? Strict global order is too expensive for all paths.",
      "options": [
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Add per-entity monotonic version checks to reject stale reordered writes.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions."
      ],
      "correct": 1,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A device sync service is experiencing NTP drift under partial network issues, this response is the most defensible call for Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "Use \"device sync service is experiencing NTP drift under partial network issues\" as your starting point, then verify tradeoffs carefully. Prefer the option that preserves correctness guarantees for the stated consistency boundary. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-017",
      "type": "multiple-choice",
      "question": "An analytics event enricher is experiencing event timestamp collisions. Which time/ordering strategy is strongest? The path includes both ordered and commutative updates.",
      "options": [
        "Use idempotent replay handling with causal guards for delayed events.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally."
      ],
      "correct": 0,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For an analytics event enricher is experiencing event timestamp collisions, this option best addresses the stated constraints in Time, Ordering & Causality.",
      "detailedExplanation": "This prompt is really about \"analytics event enricher is experiencing event timestamp collisions\". Reject designs that improve throughput while weakening reliability guarantees. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. Common pitfall: ordering loss during partition or replay changes.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-018",
      "type": "multiple-choice",
      "question": "A fraud alert pipeline is experiencing reordered queue delivery after failover. Which time/ordering strategy is strongest? Read-side projections lag behind event ingestion bursts.",
      "options": [
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Partition ordering-sensitive streams and avoid cross-partition total-order assumptions."
      ],
      "correct": 3,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A fraud alert pipeline is experiencing reordered queue delivery after failover, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "The decision turns on \"fraud alert pipeline is experiencing reordered queue delivery after failover\". Reject choices that sound good generally but do not reduce the concrete reliability risk in this scenario. The strongest answer explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-019",
      "type": "multiple-choice",
      "question": "A catalog update fanout service is experiencing duplicate event replay with old timestamps. Which time/ordering strategy is strongest? Team needs clearer causal debugging telemetry.",
      "options": [
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Expose uncertainty when causal order cannot be established from available metadata.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions."
      ],
      "correct": 2,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A catalog update fanout service is experiencing duplicate event replay with old timestamps, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality.",
      "detailedExplanation": "Read this as a scenario about \"catalog update fanout service is experiencing duplicate event replay with old timestamps\". Eliminate options that ignore delivery semantics or backpressure behavior. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. Common pitfall: consumer lag growth under burst traffic.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-020",
      "type": "multiple-choice",
      "question": "A identity claim replication pipeline is experiencing mixed wall-clock and logical ordering assumptions. Which time/ordering strategy is strongest? Recovery workflows require deterministic replay behavior.",
      "options": [
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Instrument skew and reordering metrics; gate critical workflows when ordering confidence drops.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions."
      ],
      "correct": 1,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A identity claim replication pipeline is experiencing mixed wall-clock and logical ordering assumptions, this response is the most defensible call for Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "Read this as a scenario about \"identity claim replication pipeline is experiencing mixed wall-clock and logical\". Reject choices that sound good generally but do not reduce the concrete reliability risk in this scenario. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-021",
      "type": "multiple-choice",
      "question": "A multi-device messaging feed is experiencing clock skew between regions. Which time/ordering strategy is strongest? The incident repeats when delayed events arrive late.",
      "options": [
        "Use causal metadata (vector clocks/causal context) where dependent event order matters.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally."
      ],
      "correct": 0,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A multi-device messaging feed is experiencing clock skew between regions, this option best addresses the stated constraints in Time, Ordering & Causality.",
      "detailedExplanation": "The decision turns on \"multi-device messaging feed is experiencing clock skew between regions\". Prioritize the option that best protects the reliability objective under the stated failure conditions. The strongest answer explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-022",
      "type": "multiple-choice",
      "question": "A collaborative document editor is experiencing out-of-order event arrival. Which time/ordering strategy is strongest? System behavior differs by tenant under heavy concurrency.",
      "options": [
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Separate wall-clock display time from correctness ordering logic using logical clocks."
      ],
      "correct": 3,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A collaborative document editor is experiencing out-of-order event arrival, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "Start from \"collaborative document editor is experiencing out-of-order event arrival\", then pressure-test the result against the options. Reject designs that improve throughput while weakening reliability guarantees. A good message-system answer defines guarantees clearly for both producer and consumer paths. Common pitfall: consumer lag growth under burst traffic.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-023",
      "type": "multiple-choice",
      "question": "An inventory event processor is experiencing causal dependency not preserved. Which time/ordering strategy is strongest? Clock synchronization confidence is temporarily degraded.",
      "options": [
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Use Lamport/logical sequence for deterministic processing order when real-time order is unreliable.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions."
      ],
      "correct": 2,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For an inventory event processor is experiencing causal dependency not preserved, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality.",
      "detailedExplanation": "The key clue in this question is \"inventory event processor is experiencing causal dependency not preserved\". Reject designs that improve throughput while weakening reliability guarantees. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. Common pitfall: ordering loss during partition or replay changes.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-024",
      "type": "multiple-choice",
      "question": "A payment reconciliation pipeline is experiencing concurrent writes from multiple clients. Which time/ordering strategy is strongest? Some workflows can tolerate eventual ordering if explicit.",
      "options": [
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Define merge/conflict policy for concurrent updates and preserve causality where required.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions."
      ],
      "correct": 1,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A payment reconciliation pipeline is experiencing concurrent writes from multiple clients, this response is the most defensible call for Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "The core signal here is \"payment reconciliation pipeline is experiencing concurrent writes from multiple clients\". Eliminate approaches that hand-wave conflict resolution or quorum behavior. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-025",
      "type": "multiple-choice",
      "question": "A ride dispatch event stream is experiencing late-arriving updates after retries. Which time/ordering strategy is strongest? Critical workflows require clear happened-before semantics.",
      "options": [
        "Treat physical timestamps as hints; validate order with causal/version metadata.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally."
      ],
      "correct": 0,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A ride dispatch event stream is experiencing late-arriving updates after retries, this option best addresses the stated constraints in Time, Ordering & Causality.",
      "detailedExplanation": "If you keep \"ride dispatch event stream is experiencing late-arriving updates after retries\" in view, the correct answer separates faster. Reject designs that improve throughput while weakening reliability guarantees. A good message-system answer defines guarantees clearly for both producer and consumer paths. Common pitfall: ordering loss during partition or replay changes.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-026",
      "type": "multiple-choice",
      "question": "A support ticket workflow service is experiencing NTP drift under partial network issues. Which time/ordering strategy is strongest? Operational runbooks currently ignore causal metadata health.",
      "options": [
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Add per-entity monotonic version checks to reject stale reordered writes."
      ],
      "correct": 3,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A support ticket workflow service is experiencing NTP drift under partial network issues, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "This prompt is really about \"support ticket workflow service is experiencing NTP drift under partial network issues\". Prefer the option that preserves correctness guarantees for the stated consistency boundary. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-027",
      "type": "multiple-choice",
      "question": "A notification timeline service is experiencing event timestamp collisions. Which time/ordering strategy is strongest? Downstream consumers assume stronger ordering than provided.",
      "options": [
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Use idempotent replay handling with causal guards for delayed events.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions."
      ],
      "correct": 2,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A notification timeline service is experiencing event timestamp collisions, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality.",
      "detailedExplanation": "Use \"notification timeline service is experiencing event timestamp collisions\" as your starting point, then verify tradeoffs carefully. Eliminate options that ignore delivery semantics or backpressure behavior. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. Common pitfall: consumer lag growth under burst traffic.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-028",
      "type": "multiple-choice",
      "question": "An order lifecycle event bus is experiencing reordered queue delivery after failover. Which time/ordering strategy is strongest? Backpressure caused reorder spikes in one partition group.",
      "options": [
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Partition ordering-sensitive streams and avoid cross-partition total-order assumptions.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions."
      ],
      "correct": 1,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For an order lifecycle event bus is experiencing reordered queue delivery after failover, this response is the most defensible call for Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "Read this as a scenario about \"order lifecycle event bus is experiencing reordered queue delivery after failover\". Prioritize the option that best protects the reliability objective under the stated failure conditions. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: meeting average goals while missing tail-risk.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-029",
      "type": "multiple-choice",
      "question": "A social comment thread backend is experiencing duplicate event replay with old timestamps. Which time/ordering strategy is strongest? Product requirements now include monotonic timeline UX.",
      "options": [
        "Expose uncertainty when causal order cannot be established from available metadata.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally."
      ],
      "correct": 0,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A social comment thread backend is experiencing duplicate event replay with old timestamps, this option best addresses the stated constraints in Time, Ordering & Causality.",
      "detailedExplanation": "The decision turns on \"social comment thread backend is experiencing duplicate event replay with old timestamps\". Reject designs that improve throughput while weakening reliability guarantees. Throughput is only one part; replay behavior and consumer lag handling matter equally. Common pitfall: consumer lag growth under burst traffic.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-030",
      "type": "multiple-choice",
      "question": "A feature-flag propagation service is experiencing mixed wall-clock and logical ordering assumptions. Which time/ordering strategy is strongest? Engineering wants endpoint-level ordering contracts.",
      "options": [
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Instrument skew and reordering metrics; gate critical workflows when ordering confidence drops."
      ],
      "correct": 3,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A feature-flag propagation service is experiencing mixed wall-clock and logical ordering assumptions, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "Use \"feature-flag propagation service is experiencing mixed wall-clock and logical ordering\" as your starting point, then verify tradeoffs carefully. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-031",
      "type": "multiple-choice",
      "question": "A profile update event system is experiencing clock skew between regions. Which time/ordering strategy is strongest? Retry dedupe currently lacks version monotonic guards.",
      "options": [
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Use causal metadata (vector clocks/causal context) where dependent event order matters.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions."
      ],
      "correct": 2,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A profile update event system is experiencing clock skew between regions, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality.",
      "detailedExplanation": "This prompt is really about \"profile update event system is experiencing clock skew between regions\". Reject choices that sound good generally but do not reduce the concrete reliability risk in this scenario. The strongest answer explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-032",
      "type": "multiple-choice",
      "question": "A moderation review queue is experiencing out-of-order event arrival. Which time/ordering strategy is strongest? A canary rollout is required before broad policy changes.",
      "options": [
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Separate wall-clock display time from correctness ordering logic using logical clocks.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions."
      ],
      "correct": 1,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A moderation review queue is experiencing out-of-order event arrival, this response is the most defensible call for Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "If you keep \"moderation review queue is experiencing out-of-order event arrival\" in view, the correct answer separates faster. Eliminate options that ignore delivery semantics or backpressure behavior. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. Common pitfall: consumer lag growth under burst traffic.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-033",
      "type": "multiple-choice",
      "question": "A chat read-receipt service is experiencing causal dependency not preserved. Which time/ordering strategy is strongest? The team must minimize additional coordination latency.",
      "options": [
        "Use Lamport/logical sequence for deterministic processing order when real-time order is unreliable.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally."
      ],
      "correct": 0,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A chat read-receipt service is experiencing causal dependency not preserved, this option best addresses the stated constraints in Time, Ordering & Causality.",
      "detailedExplanation": "The core signal here is \"chat read-receipt service is experiencing causal dependency not preserved\". Discard choices that violate required invariants during concurrent or failed states. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-034",
      "type": "multiple-choice",
      "question": "An ad campaign state projector is experiencing concurrent writes from multiple clients. Which time/ordering strategy is strongest? Audit paths need reproducible processing order evidence.",
      "options": [
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Define merge/conflict policy for concurrent updates and preserve causality where required."
      ],
      "correct": 3,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For an ad campaign state projector is experiencing concurrent writes from multiple clients, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "The key clue in this question is \"ad campaign state projector is experiencing concurrent writes from multiple clients\". Discard choices that violate required invariants during concurrent or failed states. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-035",
      "type": "multiple-choice",
      "question": "A shipment tracking event feed is experiencing late-arriving updates after retries. Which time/ordering strategy is strongest? Post-incident prevention is required with measurable SLOs.",
      "options": [
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Treat physical timestamps as hints; validate order with causal/version metadata.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions."
      ],
      "correct": 2,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A shipment tracking event feed is experiencing late-arriving updates after retries, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality.",
      "detailedExplanation": "Start from \"shipment tracking event feed is experiencing late-arriving updates after retries\", then pressure-test the result against the options. Eliminate answers that do not directly address the failure mode, recovery path, or blast radius. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-036",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: payment reconciliation pipeline reports failures related to causal dependency not preserved. What is the primary diagnosis?",
          "options": [
            "Ordering bugs in payment reconciliation pipeline indicate mismatch between causal requirements and current timestamp/queue assumptions around causal dependency not preserved.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths."
          ],
          "correct": 0,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For payment reconciliation pipeline reports failures related to causal dependency not preserved, this response is the most defensible call for Time, Ordering & Causality.",
          "detailedExplanation": "Use \"scenario: payment reconciliation pipeline reports failures related to causal dependency\" as your starting point, then verify tradeoffs carefully. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. The strongest answer explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: assuming recovery speed without operational proof."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while preserving low-latency reads?",
          "options": [
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Treat physical timestamps as hints; validate order with causal/version metadata."
          ],
          "correct": 3,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision while preserving low-latency reads, this option best addresses the stated constraints in Time, Ordering & Causality.",
          "detailedExplanation": "The core signal here is \"after confirming diagnosis, what is the strongest next change while preserving\". Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "The decision turns on \"time, Ordering & Causality\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-037",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: ride dispatch event stream reports failures related to concurrent writes from multiple clients. What is the primary diagnosis?",
          "options": [
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in ride dispatch event stream indicate mismatch between causal requirements and current timestamp/queue assumptions around concurrent writes from multiple clients."
          ],
          "correct": 3,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For ride dispatch event stream reports failures related to concurrent writes from multiple clients, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Read this as a scenario about \"scenario: ride dispatch event stream reports failures related to concurrent writes from\". Do not reset assumptions between stages; carry forward prior constraints directly. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: assuming recovery speed without operational proof."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under regional clock skew?",
          "options": [
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Add per-entity monotonic version checks to reject stale reordered writes.",
            "Force one global synchronized timestamp source for every service write path."
          ],
          "correct": 2,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision under regional clock skew, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "The key clue in this question is \"after confirming diagnosis, what is the strongest next change under regional clock skew\". Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "Read this as a scenario about \"time, Ordering & Causality\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-038",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: support ticket workflow service reports failures related to late-arriving updates after retries. What is the primary diagnosis?",
          "options": [
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in support ticket workflow service indicate mismatch between causal requirements and current timestamp/queue assumptions around late-arriving updates after retries.",
            "Physical clocks are always sufficient for strict correctness ordering."
          ],
          "correct": 2,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For support ticket workflow service reports failures related to late-arriving updates after retries, this response is the most defensible call for Time, Ordering & Causality.",
          "detailedExplanation": "The decision turns on \"scenario: support ticket workflow service reports failures related to late-arriving\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Tie the decision to concrete operational outcomes, not abstract reliability language. Common pitfall: retry storms during partial failure."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change during replay/retry storms?",
          "options": [
            "Avoid metadata changes and accept occasional causal violations.",
            "Use idempotent replay handling with causal guards for delayed events.",
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance."
          ],
          "correct": 1,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision during replay/retry storms, this option best addresses the stated constraints in Time, Ordering & Causality.",
          "detailedExplanation": "Start from \"after confirming diagnosis, what is the strongest next change during replay/retry storms\", then pressure-test the result against the options. Do not reset assumptions between stages; carry forward prior constraints directly. Tie the decision to concrete operational outcomes, not abstract reliability language. Common pitfall: meeting average goals while missing tail-risk."
        }
      ],
      "detailedExplanation": "Use \"time, Ordering & Causality\" as your starting point, then verify tradeoffs carefully. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-039",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: notification timeline service reports failures related to NTP drift under partial network issues. What is the primary diagnosis?",
          "options": [
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in notification timeline service indicate mismatch between causal requirements and current timestamp/queue assumptions around NTP drift under partial network issues.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled."
          ],
          "correct": 1,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For notification timeline service reports failures related to NTP drift under partial network issues, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Start from \"scenario: notification timeline service reports failures related to NTP drift under\", then pressure-test the result against the options. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. The strongest answer explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: meeting average goals while missing tail-risk."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change without forcing global total order?",
          "options": [
            "Partition ordering-sensitive streams and avoid cross-partition total-order assumptions.",
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations."
          ],
          "correct": 0,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision without forcing global total order, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "The decision turns on \"after confirming diagnosis, what is the strongest next change without forcing global\". Solve this as chained reasoning where stage two must respect stage one assumptions. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "This prompt is really about \"time, Ordering & Causality\". Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-040",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: order lifecycle event bus reports failures related to event timestamp collisions. What is the primary diagnosis?",
          "options": [
            "Ordering bugs in order lifecycle event bus indicate mismatch between causal requirements and current timestamp/queue assumptions around event timestamp collisions.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths."
          ],
          "correct": 0,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For order lifecycle event bus reports failures related to event timestamp collisions, this response is the most defensible call for Time, Ordering & Causality.",
          "detailedExplanation": "Start from \"scenario: order lifecycle event bus reports failures related to event timestamp\", then pressure-test the result against the options. Solve this as chained reasoning where stage two must respect stage one assumptions. Tie the decision to concrete operational outcomes, not abstract reliability language. Common pitfall: meeting average goals while missing tail-risk."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with cross-device concurrency?",
          "options": [
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Expose uncertainty when causal order cannot be established from available metadata."
          ],
          "correct": 3,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision with cross-device concurrency, this option best addresses the stated constraints in Time, Ordering & Causality.",
          "detailedExplanation": "The decision turns on \"after confirming diagnosis, what is the strongest next change with cross-device\". Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "This prompt is really about \"time, Ordering & Causality\". Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-041",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: social comment thread backend reports failures related to reordered queue delivery after failover. What is the primary diagnosis?",
          "options": [
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in social comment thread backend indicate mismatch between causal requirements and current timestamp/queue assumptions around reordered queue delivery after failover."
          ],
          "correct": 3,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For social comment thread backend reports failures related to reordered queue delivery after failover, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "The decision turns on \"scenario: social comment thread backend reports failures related to reordered queue\". Solve this as chained reasoning where stage two must respect stage one assumptions. Tie the decision to concrete operational outcomes, not abstract reliability language. Common pitfall: retry storms during partial failure."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under partitioned delivery paths?",
          "options": [
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Instrument skew and reordering metrics; gate critical workflows when ordering confidence drops.",
            "Force one global synchronized timestamp source for every service write path."
          ],
          "correct": 2,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision under partitioned delivery paths, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Start from \"after confirming diagnosis, what is the strongest next change under partitioned\", then pressure-test the result against the options. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "Use \"time, Ordering & Causality\" as your starting point, then verify tradeoffs carefully. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-042",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: feature-flag propagation service reports failures related to duplicate event replay with old timestamps. What is the primary diagnosis?",
          "options": [
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in feature-flag propagation service indicate mismatch between causal requirements and current timestamp/queue assumptions around duplicate event replay with old timestamps.",
            "Physical clocks are always sufficient for strict correctness ordering."
          ],
          "correct": 2,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For feature-flag propagation service reports failures related to duplicate event replay with old timestamps, this response is the most defensible call for Time, Ordering & Causality.",
          "detailedExplanation": "The core signal here is \"scenario: feature-flag propagation service reports failures related to duplicate event\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Tie the decision to concrete operational outcomes, not abstract reliability language. Common pitfall: meeting average goals while missing tail-risk."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while keeping idempotent handlers simple?",
          "options": [
            "Avoid metadata changes and accept occasional causal violations.",
            "Use causal metadata (vector clocks/causal context) where dependent event order matters.",
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance."
          ],
          "correct": 1,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision while keeping idempotent handlers simple, this option best addresses the stated constraints in Time, Ordering & Causality.",
          "detailedExplanation": "Use \"after confirming diagnosis, what is the strongest next change while keeping idempotent\" as your starting point, then verify tradeoffs carefully. Solve this as chained reasoning where stage two must respect stage one assumptions. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: interface design coupled too tightly to internal implementation."
        }
      ],
      "detailedExplanation": "The core signal here is \"time, Ordering & Causality\". Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-043",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: profile update event system reports failures related to mixed wall-clock and logical ordering assumptions. What is the primary diagnosis?",
          "options": [
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in profile update event system indicate mismatch between causal requirements and current timestamp/queue assumptions around mixed wall-clock and logical ordering assumptions.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled."
          ],
          "correct": 1,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For profile update event system reports failures related to mixed wall-clock and logical ordering assumptions, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "The key clue in this question is \"scenario: profile update event system reports failures related to mixed wall-clock and\". Do not reset assumptions between stages; carry forward prior constraints directly. The strongest answer explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: retry storms during partial failure."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change during failover recovery?",
          "options": [
            "Separate wall-clock display time from correctness ordering logic using logical clocks.",
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations."
          ],
          "correct": 0,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision during failover recovery, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Read this as a scenario about \"after confirming diagnosis, what is the strongest next change during failover recovery\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Tie the decision to concrete operational outcomes, not abstract reliability language. Common pitfall: meeting average goals while missing tail-risk."
        }
      ],
      "detailedExplanation": "If you keep \"time, Ordering & Causality\" in view, the correct answer separates faster. Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-044",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: moderation review queue reports failures related to clock skew between regions. What is the primary diagnosis?",
          "options": [
            "Ordering bugs in moderation review queue indicate mismatch between causal requirements and current timestamp/queue assumptions around clock skew between regions.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths."
          ],
          "correct": 0,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For moderation review queue reports failures related to clock skew between regions, this response is the most defensible call for Time, Ordering & Causality.",
          "detailedExplanation": "This prompt is really about \"scenario: moderation review queue reports failures related to clock skew between regions\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: retry storms during partial failure."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with mixed ordered/unordered streams?",
          "options": [
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Use Lamport/logical sequence for deterministic processing order when real-time order is unreliable."
          ],
          "correct": 3,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision with mixed ordered/unordered streams, this option best addresses the stated constraints in Time, Ordering & Causality.",
          "detailedExplanation": "If you keep \"after confirming diagnosis, what is the strongest next change with mixed\" in view, the correct answer separates faster. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "Start from \"time, Ordering & Causality\", then pressure-test the result against the options. Solve this as chained reasoning where stage two must respect stage one assumptions. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-045",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: chat read-receipt service reports failures related to out-of-order event arrival. What is the primary diagnosis?",
          "options": [
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in chat read-receipt service indicate mismatch between causal requirements and current timestamp/queue assumptions around out-of-order event arrival."
          ],
          "correct": 3,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For chat read-receipt service reports failures related to out-of-order event arrival, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "If you keep \"scenario: chat read-receipt service reports failures related to out-of-order event\" in view, the correct answer separates faster. Do not reset assumptions between stages; carry forward prior constraints directly. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: meeting average goals while missing tail-risk."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change before broad rollout?",
          "options": [
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Define merge/conflict policy for concurrent updates and preserve causality where required.",
            "Force one global synchronized timestamp source for every service write path."
          ],
          "correct": 2,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision before broad rollout, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "This prompt is really about \"after confirming diagnosis, what is the strongest next change before broad rollout\". Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "The key clue in this question is \"time, Ordering & Causality\". Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-046",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: ad campaign state projector reports failures related to causal dependency not preserved. What is the primary diagnosis?",
          "options": [
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in ad campaign state projector indicate mismatch between causal requirements and current timestamp/queue assumptions around causal dependency not preserved.",
            "Physical clocks are always sufficient for strict correctness ordering."
          ],
          "correct": 2,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For ad campaign state projector reports failures related to causal dependency not preserved, this response is the most defensible call for Time, Ordering & Causality.",
          "detailedExplanation": "Read this as a scenario about \"scenario: ad campaign state projector reports failures related to causal dependency not\". Solve this as chained reasoning where stage two must respect stage one assumptions. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: assuming recovery speed without operational proof."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while minimizing user-visible regressions?",
          "options": [
            "Avoid metadata changes and accept occasional causal violations.",
            "Treat physical timestamps as hints; validate order with causal/version metadata.",
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance."
          ],
          "correct": 1,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision while minimizing user-visible regressions, this option best addresses the stated constraints in Time, Ordering & Causality.",
          "detailedExplanation": "The key clue in this question is \"after confirming diagnosis, what is the strongest next change while minimizing\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "Read this as a scenario about \"time, Ordering & Causality\". Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-047",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: shipment tracking event feed reports failures related to concurrent writes from multiple clients. What is the primary diagnosis?",
          "options": [
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in shipment tracking event feed indicate mismatch between causal requirements and current timestamp/queue assumptions around concurrent writes from multiple clients.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled."
          ],
          "correct": 1,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For shipment tracking event feed reports failures related to concurrent writes from multiple clients, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Use \"scenario: shipment tracking event feed reports failures related to concurrent writes\" as your starting point, then verify tradeoffs carefully. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Tie the decision to concrete operational outcomes, not abstract reliability language. Common pitfall: retry storms during partial failure."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under sustained traffic bursts?",
          "options": [
            "Add per-entity monotonic version checks to reject stale reordered writes.",
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations."
          ],
          "correct": 0,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision under sustained traffic bursts, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "The core signal here is \"after confirming diagnosis, what is the strongest next change under sustained traffic\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "The decision turns on \"time, Ordering & Causality\". Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-048",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: device sync service reports failures related to late-arriving updates after retries. What is the primary diagnosis?",
          "options": [
            "Ordering bugs in device sync service indicate mismatch between causal requirements and current timestamp/queue assumptions around late-arriving updates after retries.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths."
          ],
          "correct": 0,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For device sync service reports failures related to late-arriving updates after retries, this response is the most defensible call for Time, Ordering & Causality.",
          "detailedExplanation": "Start from \"scenario: device sync service reports failures related to late-arriving updates after\", then pressure-test the result against the options. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Tie the decision to concrete operational outcomes, not abstract reliability language. Common pitfall: assuming recovery speed without operational proof."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with constrained control-plane confidence?",
          "options": [
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Use idempotent replay handling with causal guards for delayed events."
          ],
          "correct": 3,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision with constrained control-plane confidence, this option best addresses the stated constraints in Time, Ordering & Causality.",
          "detailedExplanation": "The decision turns on \"after confirming diagnosis, what is the strongest next change with constrained\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "This prompt is really about \"time, Ordering & Causality\". Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-049",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: analytics event enricher reports failures related to NTP drift under partial network issues. What is the primary diagnosis?",
          "options": [
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in analytics event enricher indicate mismatch between causal requirements and current timestamp/queue assumptions around NTP drift under partial network issues."
          ],
          "correct": 3,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For analytics event enricher reports failures related to NTP drift under partial network issues, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "The decision turns on \"scenario: analytics event enricher reports failures related to NTP drift under partial\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: retry storms during partial failure."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while protecting invariant checks?",
          "options": [
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Partition ordering-sensitive streams and avoid cross-partition total-order assumptions.",
            "Force one global synchronized timestamp source for every service write path."
          ],
          "correct": 2,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision while protecting invariant checks, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Start from \"after confirming diagnosis, what is the strongest next change while protecting\", then pressure-test the result against the options. Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "Use \"time, Ordering & Causality\" as your starting point, then verify tradeoffs carefully. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-050",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: fraud alert pipeline reports failures related to event timestamp collisions. What is the primary diagnosis?",
          "options": [
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in fraud alert pipeline indicate mismatch between causal requirements and current timestamp/queue assumptions around event timestamp collisions.",
            "Physical clocks are always sufficient for strict correctness ordering."
          ],
          "correct": 2,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For fraud alert pipeline reports failures related to event timestamp collisions, this response is the most defensible call for Time, Ordering & Causality.",
          "detailedExplanation": "The key clue in this question is \"scenario: fraud alert pipeline reports failures related to event timestamp collisions\". Solve this as chained reasoning where stage two must respect stage one assumptions. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: meeting average goals while missing tail-risk."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change during metadata format migration?",
          "options": [
            "Avoid metadata changes and accept occasional causal violations.",
            "Expose uncertainty when causal order cannot be established from available metadata.",
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance."
          ],
          "correct": 1,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision during metadata format migration, this option best addresses the stated constraints in Time, Ordering & Causality.",
          "detailedExplanation": "Read this as a scenario about \"after confirming diagnosis, what is the strongest next change during metadata format\". Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "If you keep \"time, Ordering & Causality\" in view, the correct answer separates faster. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-051",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: catalog update fanout service reports failures related to reordered queue delivery after failover. What is the primary diagnosis?",
          "options": [
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in catalog update fanout service indicate mismatch between causal requirements and current timestamp/queue assumptions around reordered queue delivery after failover.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled."
          ],
          "correct": 1,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For catalog update fanout service reports failures related to reordered queue delivery after failover, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "The core signal here is \"scenario: catalog update fanout service reports failures related to reordered queue\". Solve this as chained reasoning where stage two must respect stage one assumptions. The strongest answer explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: assuming recovery speed without operational proof."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under partial message loss?",
          "options": [
            "Instrument skew and reordering metrics; gate critical workflows when ordering confidence drops.",
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations."
          ],
          "correct": 0,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision under partial message loss, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Use \"after confirming diagnosis, what is the strongest next change under partial message loss\" as your starting point, then verify tradeoffs carefully. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "The core signal here is \"time, Ordering & Causality\". Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-052",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: identity claim replication pipeline reports failures related to duplicate event replay with old timestamps. What is the primary diagnosis?",
          "options": [
            "Ordering bugs in identity claim replication pipeline indicate mismatch between causal requirements and current timestamp/queue assumptions around duplicate event replay with old timestamps.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths."
          ],
          "correct": 0,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For identity claim replication pipeline reports failures related to duplicate event replay with old timestamps, this response is the most defensible call for Time, Ordering & Causality.",
          "detailedExplanation": "The decision turns on \"scenario: identity claim replication pipeline reports failures related to duplicate\". Solve this as chained reasoning where stage two must respect stage one assumptions. The strongest answer explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: meeting average goals while missing tail-risk."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while preserving throughput targets?",
          "options": [
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Use causal metadata (vector clocks/causal context) where dependent event order matters."
          ],
          "correct": 3,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision while preserving throughput targets, this option best addresses the stated constraints in Time, Ordering & Causality.",
          "detailedExplanation": "Start from \"after confirming diagnosis, what is the strongest next change while preserving\", then pressure-test the result against the options. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "Use \"time, Ordering & Causality\" as your starting point, then verify tradeoffs carefully. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-053",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: multi-device messaging feed reports failures related to mixed wall-clock and logical ordering assumptions. What is the primary diagnosis?",
          "options": [
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in multi-device messaging feed indicate mismatch between causal requirements and current timestamp/queue assumptions around mixed wall-clock and logical ordering assumptions."
          ],
          "correct": 3,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For multi-device messaging feed reports failures related to mixed wall-clock and logical ordering assumptions, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Start from \"scenario: multi-device messaging feed reports failures related to mixed wall-clock and\", then pressure-test the result against the options. Do not reset assumptions between stages; carry forward prior constraints directly. Tie the decision to concrete operational outcomes, not abstract reliability language. Common pitfall: assuming recovery speed without operational proof."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with clear degraded semantics?",
          "options": [
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Separate wall-clock display time from correctness ordering logic using logical clocks.",
            "Force one global synchronized timestamp source for every service write path."
          ],
          "correct": 2,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision with clear degraded semantics, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "The decision turns on \"after confirming diagnosis, what is the strongest next change with clear degraded\". Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "This prompt is really about \"time, Ordering & Causality\". Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-054",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: collaborative document editor reports failures related to clock skew between regions. What is the primary diagnosis?",
          "options": [
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in collaborative document editor indicate mismatch between causal requirements and current timestamp/queue assumptions around clock skew between regions.",
            "Physical clocks are always sufficient for strict correctness ordering."
          ],
          "correct": 2,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For collaborative document editor reports failures related to clock skew between regions, this response is the most defensible call for Time, Ordering & Causality.",
          "detailedExplanation": "Use \"scenario: collaborative document editor reports failures related to clock skew between\" as your starting point, then verify tradeoffs carefully. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Tie the decision to concrete operational outcomes, not abstract reliability language. Common pitfall: meeting average goals while missing tail-risk."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change during dependency brownouts?",
          "options": [
            "Avoid metadata changes and accept occasional causal violations.",
            "Use Lamport/logical sequence for deterministic processing order when real-time order is unreliable.",
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance."
          ],
          "correct": 1,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision during dependency brownouts, this option best addresses the stated constraints in Time, Ordering & Causality.",
          "detailedExplanation": "The core signal here is \"after confirming diagnosis, what is the strongest next change during dependency\". Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "The decision turns on \"time, Ordering & Causality\". Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-055",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: inventory event processor reports failures related to out-of-order event arrival. What is the primary diagnosis?",
          "options": [
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in inventory event processor indicate mismatch between causal requirements and current timestamp/queue assumptions around out-of-order event arrival.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled."
          ],
          "correct": 1,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For inventory event processor reports failures related to out-of-order event arrival, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Read this as a scenario about \"scenario: inventory event processor reports failures related to out-of-order event\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: meeting average goals while missing tail-risk."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with strict audit traceability?",
          "options": [
            "Define merge/conflict policy for concurrent updates and preserve causality where required.",
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations."
          ],
          "correct": 0,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision with strict audit traceability, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "The key clue in this question is \"after confirming diagnosis, what is the strongest next change with strict audit\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "Read this as a scenario about \"time, Ordering & Causality\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-056",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: payment reconciliation pipeline reports failures related to causal dependency not preserved. What is the primary diagnosis?",
          "options": [
            "Ordering bugs in payment reconciliation pipeline indicate mismatch between causal requirements and current timestamp/queue assumptions around causal dependency not preserved.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths."
          ],
          "correct": 0,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For payment reconciliation pipeline reports failures related to causal dependency not preserved, this response is the most defensible call for Time, Ordering & Causality.",
          "detailedExplanation": "If you keep \"scenario: payment reconciliation pipeline reports failures related to causal dependency\" in view, the correct answer separates faster. Solve this as chained reasoning where stage two must respect stage one assumptions. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: retry storms during partial failure."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under delayed regional replication?",
          "options": [
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Treat physical timestamps as hints; validate order with causal/version metadata."
          ],
          "correct": 3,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision under delayed regional replication, this option best addresses the stated constraints in Time, Ordering & Causality.",
          "detailedExplanation": "This prompt is really about \"after confirming diagnosis, what is the strongest next change under delayed regional\". Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "The key clue in this question is \"time, Ordering & Causality\". Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-057",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: ride dispatch event stream reports failures related to concurrent writes from multiple clients. What is the primary diagnosis?",
          "options": [
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in ride dispatch event stream indicate mismatch between causal requirements and current timestamp/queue assumptions around concurrent writes from multiple clients."
          ],
          "correct": 3,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For ride dispatch event stream reports failures related to concurrent writes from multiple clients, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "This prompt is really about \"scenario: ride dispatch event stream reports failures related to concurrent writes from\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Tie the decision to concrete operational outcomes, not abstract reliability language. Common pitfall: meeting average goals while missing tail-risk."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while limiting merge complexity?",
          "options": [
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Add per-entity monotonic version checks to reject stale reordered writes.",
            "Force one global synchronized timestamp source for every service write path."
          ],
          "correct": 2,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision while limiting merge complexity, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "If you keep \"after confirming diagnosis, what is the strongest next change while limiting merge\" in view, the correct answer separates faster. Solve this as chained reasoning where stage two must respect stage one assumptions. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "Start from \"time, Ordering & Causality\", then pressure-test the result against the options. Solve this as chained reasoning where stage two must respect stage one assumptions. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-058",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: support ticket workflow service reports failures related to late-arriving updates after retries. What is the primary diagnosis?",
          "options": [
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in support ticket workflow service indicate mismatch between causal requirements and current timestamp/queue assumptions around late-arriving updates after retries.",
            "Physical clocks are always sufficient for strict correctness ordering."
          ],
          "correct": 2,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For support ticket workflow service reports failures related to late-arriving updates after retries, this response is the most defensible call for Time, Ordering & Causality.",
          "detailedExplanation": "The key clue in this question is \"scenario: support ticket workflow service reports failures related to late-arriving\". Solve this as chained reasoning where stage two must respect stage one assumptions. The strongest answer explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: assuming recovery speed without operational proof."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with existing schema compatibility constraints?",
          "options": [
            "Avoid metadata changes and accept occasional causal violations.",
            "Use idempotent replay handling with causal guards for delayed events.",
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance."
          ],
          "correct": 1,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision with existing schema compatibility constraints, this option best addresses the stated constraints in Time, Ordering & Causality.",
          "detailedExplanation": "Read this as a scenario about \"after confirming diagnosis, what is the strongest next change with existing schema\". Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "If you keep \"time, Ordering & Causality\" in view, the correct answer separates faster. Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-059",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: notification timeline service reports failures related to NTP drift under partial network issues. What is the primary diagnosis?",
          "options": [
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in notification timeline service indicate mismatch between causal requirements and current timestamp/queue assumptions around NTP drift under partial network issues.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled."
          ],
          "correct": 1,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For notification timeline service reports failures related to NTP drift under partial network issues, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "The core signal here is \"scenario: notification timeline service reports failures related to NTP drift under\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Tie the decision to concrete operational outcomes, not abstract reliability language. Common pitfall: meeting average goals while missing tail-risk."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change during backlog drain?",
          "options": [
            "Partition ordering-sensitive streams and avoid cross-partition total-order assumptions.",
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations."
          ],
          "correct": 0,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision during backlog drain, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Use \"after confirming diagnosis, what is the strongest next change during backlog drain\" as your starting point, then verify tradeoffs carefully. Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "The core signal here is \"time, Ordering & Causality\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-060",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: order lifecycle event bus reports failures related to event timestamp collisions. What is the primary diagnosis?",
          "options": [
            "Ordering bugs in order lifecycle event bus indicate mismatch between causal requirements and current timestamp/queue assumptions around event timestamp collisions.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths."
          ],
          "correct": 0,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For order lifecycle event bus reports failures related to event timestamp collisions, this response is the most defensible call for Time, Ordering & Causality.",
          "detailedExplanation": "The core signal here is \"scenario: order lifecycle event bus reports failures related to event timestamp\". Solve this as chained reasoning where stage two must respect stage one assumptions. The strongest answer explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: retry storms during partial failure."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with explicit anomaly alerts enabled?",
          "options": [
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Expose uncertainty when causal order cannot be established from available metadata."
          ],
          "correct": 3,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision with explicit anomaly alerts enabled, this option best addresses the stated constraints in Time, Ordering & Causality.",
          "detailedExplanation": "Use \"after confirming diagnosis, what is the strongest next change with explicit anomaly\" as your starting point, then verify tradeoffs carefully. Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "The core signal here is \"time, Ordering & Causality\". Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-061",
      "type": "multi-select",
      "question": "Why are wall clocks alone insufficient for distributed ordering? (Select all that apply)",
      "options": [
        "Clock skew/drift exists",
        "Events can be delayed/reordered in transit",
        "NTP guarantees perfect global ordering",
        "Concurrent writes may share similar timestamps"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Physical clocks are imperfect and network effects break naive timestamp ordering assumptions.",
      "detailedExplanation": "If you keep \"wall clocks alone insufficient for distributed ordering? (Select all that apply)\" in view, the correct answer separates faster. Avoid pattern guessing and evaluate each candidate directly against the scenario. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-062",
      "type": "multi-select",
      "question": "Vector clocks are most useful for which? (Select all that apply)",
      "options": [
        "Detecting concurrent updates",
        "Capturing causal relationships",
        "Providing exact real-world event time",
        "Supporting conflict-aware merges"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Vector clocks model causality/concurrency, not real-time precision.",
      "detailedExplanation": "This prompt is really about \"vector clocks are most useful for which? (Select all that apply)\". Validate each option independently; do not select statements that are only partially true. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-063",
      "type": "multi-select",
      "question": "Lamport clocks help with which tasks? (Select all that apply)",
      "options": [
        "Deriving a consistent happened-before-compatible order",
        "Breaking ties for deterministic processing",
        "Detecting exact concurrency in all cases",
        "Reducing dependence on wall-clock synchronization"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Lamport clocks support ordering but cannot fully distinguish all concurrent cases.",
      "detailedExplanation": "Use \"lamport clocks help with which tasks? (Select all that apply)\" as your starting point, then verify tradeoffs carefully. Treat every option as a separate true/false test under the same constraints. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-064",
      "type": "multi-select",
      "question": "Good practices for event reordering tolerance include which? (Select all that apply)",
      "options": [
        "Idempotent handlers",
        "Per-entity version checks",
        "Assuming strict in-order delivery globally",
        "Late-event handling policy"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Robust systems assume delays/reordering and enforce correctness via metadata/policies.",
      "detailedExplanation": "Read this as a scenario about \"good practices for event reordering tolerance include which? (Select all that apply)\". Validate each option independently; do not select statements that are only partially true. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. Common pitfall: ordering loss during partition or replay changes.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-065",
      "type": "multi-select",
      "question": "Causal consistency is especially important when which apply? (Select all that apply)",
      "options": [
        "Reply should not appear before original message",
        "Dependent workflow steps must preserve order",
        "Independent counters only",
        "User sees own actions reflected coherently"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Causal guarantees matter when semantic dependencies exist between operations.",
      "detailedExplanation": "The decision turns on \"causal consistency is especially important when which apply? (Select all that apply)\". Treat every option as a separate true/false test under the same constraints. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-066",
      "type": "multi-select",
      "question": "Which signs indicate ordering assumptions are broken? (Select all that apply)",
      "options": [
        "State appears to revert after newer update",
        "Duplicate replay overwrites newer data",
        "Stable monotonic version progression",
        "Cross-device conflicting timelines"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Reversions and timeline conflicts are classic ordering/causality symptoms.",
      "detailedExplanation": "Start from \"signs indicate ordering assumptions are broken? (Select all that apply)\", then pressure-test the result against the options. Treat every option as a separate true/false test under the same constraints. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-067",
      "type": "multi-select",
      "question": "To separate display time from correctness ordering, which are valid? (Select all that apply)",
      "options": [
        "Store logical/causal version for writes",
        "Use wall-clock only for UI display context",
        "Use display timestamp as sole conflict resolver always",
        "Retain metadata needed for conflict resolution"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Correctness should be metadata-driven; display time can remain user-facing context.",
      "detailedExplanation": "The key clue in this question is \"to separate display time from correctness ordering, which are valid? (Select all that\". Validate each option independently; do not select statements that are only partially true. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-068",
      "type": "multi-select",
      "question": "Which are valid conflict-resolution strategies for concurrent updates? (Select all that apply)",
      "options": [
        "Domain-specific merge rules",
        "User-visible conflict resolution for critical fields",
        "Blind last-arrival-wins everywhere",
        "CRDT-style commutative merges where suitable"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Conflict policy should match domain semantics; naive global last-arrival wins is risky.",
      "detailedExplanation": "The core signal here is \"valid conflict-resolution strategies for concurrent updates? (Select all that apply)\". Avoid pattern guessing and evaluate each candidate directly against the scenario. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-069",
      "type": "multi-select",
      "question": "Useful observability for time/ordering issues includes which? (Select all that apply)",
      "options": [
        "Clock skew distribution",
        "Out-of-order event rate",
        "Only CPU utilization",
        "Version regression counters"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Ordering incidents require direct telemetry on skew/reordering/version regressions.",
      "detailedExplanation": "If you keep \"useful observability for time/ordering issues includes which? (Select all that apply)\" in view, the correct answer separates faster. Avoid pattern guessing and evaluate each candidate directly against the scenario. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-070",
      "type": "multi-select",
      "question": "When can total ordering be overkill? (Select all that apply)",
      "options": [
        "Independent entities that do not interact causally",
        "Workloads where partition-local order is enough",
        "Critical global invariants across all operations",
        "Paths where commutative updates are valid"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Global total order is costly; use it only where truly required.",
      "detailedExplanation": "The key clue in this question is \"total ordering be overkill? (Select all that apply)\". Validate each option independently; do not select statements that are only partially true. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-071",
      "type": "multi-select",
      "question": "Which anti-patterns commonly cause causal bugs? (Select all that apply)",
      "options": [
        "Mixing event-time and processing-time semantics silently",
        "Dropping causal metadata in intermediate services",
        "Maintaining per-entity version history",
        "Assuming retries preserve original order"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Lost metadata and hidden semantic assumptions create ordering failures.",
      "detailedExplanation": "Start from \"anti-patterns commonly cause causal bugs? (Select all that apply)\", then pressure-test the result against the options. Avoid pattern guessing and evaluate each candidate directly against the scenario. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-072",
      "type": "multi-select",
      "question": "For replay pipelines, which controls help preserve correctness? (Select all that apply)",
      "options": [
        "Idempotency keys",
        "Version monotonicity checks",
        "Allow stale replay to overwrite newer writes",
        "Replay windows with dedupe state"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Replay safety depends on idempotency, monotonic guards, and dedupe controls.",
      "detailedExplanation": "The decision turns on \"for replay pipelines, which controls help preserve correctness? (Select all that apply)\". Treat every option as a separate true/false test under the same constraints. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-073",
      "type": "multi-select",
      "question": "Which conditions increase clock-skew risk impact? (Select all that apply)",
      "options": [
        "Cross-region writes with strict timestamp ordering assumptions",
        "NTP instability in isolated networks",
        "Logical versioning on critical writes",
        "Conflict resolution solely by wall time"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Skew is most harmful when correctness logic relies directly on physical time ordering.",
      "detailedExplanation": "Read this as a scenario about \"conditions increase clock-skew risk impact? (Select all that apply)\". Avoid pattern guessing and evaluate each candidate directly against the scenario. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-074",
      "type": "multi-select",
      "question": "When introducing causal metadata, which rollout steps are useful? (Select all that apply)",
      "options": [
        "Dual-write old/new metadata temporarily",
        "Backwards-compatible read logic during migration",
        "Big-bang schema switch with no fallback",
        "Canary validation of ordering anomaly rates"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Compatibility and canarying reduce migration risk.",
      "detailedExplanation": "Use \"introducing causal metadata, which rollout steps are useful? (Select all that apply)\" as your starting point, then verify tradeoffs carefully. Validate each option independently; do not select statements that are only partially true. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-075",
      "type": "multi-select",
      "question": "Which are valid degraded behaviors when causal order is uncertain? (Select all that apply) (Time, Ordering & Causality context)",
      "options": [
        "Delay user-visible apply until dependency confirmed",
        "Show pending sync state",
        "Silently overwrite with uncertain update",
        "Escalate to stronger read path for validation"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Explicit degraded semantics are safer than silent incorrect ordering.",
      "detailedExplanation": "This prompt is really about \"valid degraded behaviors when causal order is uncertain? (Select all that apply)\". Avoid pattern guessing and evaluate each candidate directly against the scenario. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-076",
      "type": "multi-select",
      "question": "Which workloads typically need at least partition-local ordering? (Select all that apply)",
      "options": [
        "Per-account ledger streams",
        "Chat threads with reply ordering",
        "Totally independent telemetry counters",
        "Order-status event progression"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Entity-local workflows often need consistent local sequence semantics.",
      "detailedExplanation": "If you keep \"workloads typically need at least partition-local ordering? (Select all that apply)\" in view, the correct answer separates faster. Validate each option independently; do not select statements that are only partially true. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. Common pitfall: assuming exactly-once without idempotency.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-077",
      "type": "multi-select",
      "question": "What helps prevent newer write overwritten by older replay? (Select all that apply)",
      "options": [
        "Per-entity monotonic version checks",
        "Compare-and-set on expected version",
        "Timestamp-only last-arrival wins policy",
        "Replay dedupe with causal/version metadata"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Version and CAS protections guard against stale replay overwrites.",
      "detailedExplanation": "The core signal here is \"helps prevent newer write overwritten by older replay? (Select all that apply)\". Avoid pattern guessing and evaluate each candidate directly against the scenario. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-078",
      "type": "numeric-input",
      "question": "A stream processes 18,000 events/sec. Out-of-order rate is 0.6%. Out-of-order events/sec?",
      "answer": 108,
      "unit": "events/sec",
      "tolerance": 0.02,
      "explanation": "0.006 * 18,000 = 108.",
      "detailedExplanation": "The key clue in this question is \"stream processes 18,000 events/sec\". Keep every transformation in one unit system and check order of magnitude at the end. A good message-system answer defines guarantees clearly for both producer and consumer paths. Keep quantities like 18,000 and 0.6 in aligned units before selecting an answer. Common pitfall: consumer lag growth under burst traffic.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-079",
      "type": "numeric-input",
      "question": "Clock skew p99 is 420ms, tolerance budget is 150ms. Percent over budget?",
      "answer": 180,
      "unit": "%",
      "tolerance": 0.5,
      "explanation": "(420-150)/150 = 180%.",
      "detailedExplanation": "Start from \"clock skew p99 is 420ms, tolerance budget is 150ms\", then pressure-test the result against the options. Normalize units before computing so conversion mistakes do not propagate. Tie the decision to concrete operational outcomes, not abstract reliability language. If values like 420ms and 150ms appear, convert them into one unit basis before comparison. Common pitfall: meeting average goals while missing tail-risk.",
      "references": [
        {
          "title": "Percentile",
          "url": "https://en.wikipedia.org/wiki/Percentile"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-080",
      "type": "numeric-input",
      "question": "Event replay backlog is 720,000 events. Replayer throughput is 4,000 events/sec. Seconds to drain (no new events)?",
      "answer": 180,
      "unit": "seconds",
      "tolerance": 0,
      "explanation": "720,000 / 4,000 = 180s.",
      "detailedExplanation": "Start from \"event replay backlog is 720,000 events\", then pressure-test the result against the options. Write the unit conversion path explicitly, then calculate, then sanity-check magnitude. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. Numbers such as 720,000 and 4,000 should be normalized first so downstream reasoning stays consistent. Common pitfall: ordering loss during partition or replay changes.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-081",
      "type": "numeric-input",
      "question": "A service sees 2,400,000 updates/day. Concurrent-update conflict rate is 0.35%. Conflicts/day?",
      "answer": 8400,
      "unit": "updates",
      "tolerance": 0.02,
      "explanation": "0.0035 * 2,400,000 = 8,400.",
      "detailedExplanation": "The key clue in this question is \"service sees 2,400,000 updates/day\". Write the unit conversion path explicitly, then calculate, then sanity-check magnitude. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Numbers such as 2,400 and 000 should be normalized first so downstream reasoning stays consistent. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-082",
      "type": "numeric-input",
      "question": "Monotonic-version violation rate is 0.09% across 9,000,000 writes/day. Violations/day?",
      "answer": 8100,
      "unit": "writes",
      "tolerance": 0.03,
      "explanation": "0.0009 * 9,000,000 = 8,100.",
      "detailedExplanation": "Read this as a scenario about \"monotonic-version violation rate is 0\". Keep every transformation in one unit system and check order of magnitude at the end. Interface decisions should be justified by contract stability and client impact over time. Keep quantities like 0.09 and 9,000 in aligned units before selecting an answer. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-083",
      "type": "numeric-input",
      "question": "Causal-metadata payload adds 42 bytes/event at 65,000 events/sec. Extra MB/sec (decimal MB)?",
      "answer": 2.73,
      "unit": "MB/sec",
      "tolerance": 0.08,
      "explanation": "65,000*42 = 2,730,000 bytes/sec  2.73 MB/sec.",
      "detailedExplanation": "The decision turns on \"causal-metadata payload adds 42 bytes/event at 65,000 events/sec\". Write the unit conversion path explicitly, then calculate, then sanity-check magnitude. Interface decisions should be justified by contract stability and client impact over time. Numbers such as 42 and 65,000 should be normalized first so downstream reasoning stays consistent. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-084",
      "type": "numeric-input",
      "question": "Retry replay adds 0.18 extra deliveries per original event. At 30,000 original events/sec, effective deliveries/sec?",
      "answer": 35400,
      "unit": "deliveries/sec",
      "tolerance": 0.02,
      "explanation": "30,000 * 1.18 = 35,400.",
      "detailedExplanation": "This prompt is really about \"retry replay adds 0\". Normalize units before computing so conversion mistakes do not propagate. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. If values like 0.18 and 30,000 appear, convert them into one unit basis before comparison. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Retry pattern",
          "url": "https://learn.microsoft.com/en-us/azure/architecture/patterns/retry"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-085",
      "type": "numeric-input",
      "question": "A per-entity stream has 12 partitions and one hot partition carries 26% traffic. If total is 48,000 events/sec, hot-partition rate?",
      "answer": 12480,
      "unit": "events/sec",
      "tolerance": 0.02,
      "explanation": "0.26 * 48,000 = 12,480.",
      "detailedExplanation": "Use \"per-entity stream has 12 partitions and one hot partition carries 26% traffic\" as your starting point, then verify tradeoffs carefully. Normalize units before computing so conversion mistakes do not propagate. Throughput is only one part; replay behavior and consumer lag handling matter equally. If values like 12 and 26 appear, convert them into one unit basis before comparison. Common pitfall: assuming exactly-once without idempotency.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-086",
      "type": "numeric-input",
      "question": "A timeline merge waits up to 250ms for causal predecessor. Current average pause is 90ms. Remaining budget?",
      "answer": 160,
      "unit": "ms",
      "tolerance": 0,
      "explanation": "250 - 90 = 160ms.",
      "detailedExplanation": "The core signal here is \"timeline merge waits up to 250ms for causal predecessor\". Normalize units before computing so conversion mistakes do not propagate. Consistency decisions should be explicit about which conflicts are acceptable and why. If values like 250ms and 90ms appear, convert them into one unit basis before comparison. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-087",
      "type": "numeric-input",
      "question": "Out-of-order anomaly SLO is <=0.2%. Observed is 0.47%. How many times above SLO is observed?",
      "answer": 2.35,
      "unit": "x",
      "tolerance": 0.05,
      "explanation": "0.47 / 0.2 = 2.35x.",
      "detailedExplanation": "If you keep \"out-of-order anomaly SLO is <=0\" in view, the correct answer separates faster. Normalize units before computing so conversion mistakes do not propagate. Tie the decision to concrete operational outcomes, not abstract reliability language. If values like 0.2 and 0.47 appear, convert them into one unit basis before comparison. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-088",
      "type": "numeric-input",
      "question": "If 15% of operations require causal checks and total ops are 80,000/sec, how many causal-check ops/sec?",
      "answer": 12000,
      "unit": "ops/sec",
      "tolerance": 0.01,
      "explanation": "0.15 * 80,000 = 12,000.",
      "detailedExplanation": "Start from \"if 15% of operations require causal checks and total ops are 80,000/sec, how many\", then pressure-test the result against the options. Write the unit conversion path explicitly, then calculate, then sanity-check magnitude. Consistency decisions should be explicit about which conflicts are acceptable and why. Numbers such as 15 and 80,000 should be normalized first so downstream reasoning stays consistent. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-089",
      "type": "numeric-input",
      "question": "A conflict resolver succeeds automatically for 92% of 50,000 concurrent conflicts/day. Manual conflicts/day?",
      "answer": 4000,
      "unit": "conflicts",
      "tolerance": 0.02,
      "explanation": "8% of 50,000 = 4,000.",
      "detailedExplanation": "The key clue in this question is \"conflict resolver succeeds automatically for 92% of 50,000 concurrent conflicts/day\". Keep every transformation in one unit system and check order of magnitude at the end. Consistency decisions should be explicit about which conflicts are acceptable and why. Keep quantities like 92 and 50,000 in aligned units before selecting an answer. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-090",
      "type": "ordering",
      "question": "Order a robust ordering-bug triage flow.",
      "items": [
        "Confirm anomaly type (skew/reorder/concurrency)",
        "Inspect causal/version metadata path",
        "Apply targeted ordering control",
        "Add regression alert/test coverage"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Classify, diagnose metadata gaps, mitigate, then harden.",
      "detailedExplanation": "The decision turns on \"order a robust ordering-bug triage flow\". Build the rank from biggest differences first, then refine with adjacent checks. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-091",
      "type": "ordering",
      "question": "Order by increasing guarantee strength (typical).",
      "items": [
        "Best-effort eventual order",
        "Partition-local order",
        "Causal order",
        "Global total order"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Stronger ordering guarantees add coordination cost.",
      "detailedExplanation": "Read this as a scenario about \"order by increasing guarantee strength (typical)\". Build the rank from biggest differences first, then refine with adjacent checks. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-092",
      "type": "ordering",
      "question": "Order by likely implementation complexity.",
      "items": [
        "Timestamp-only sort",
        "Lamport-clock ordering",
        "Vector-clock causal tracking",
        "Global total-order broadcast"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Complexity generally increases with stronger/ broader ordering semantics.",
      "detailedExplanation": "The key clue in this question is \"order by likely implementation complexity\". Build the rank from biggest differences first, then refine with adjacent checks. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-093",
      "type": "ordering",
      "question": "Order replay-safety controls from foundational to advanced.",
      "items": [
        "Idempotency key checks",
        "Per-entity version monotonicity guard",
        "Causal dependency validation",
        "Conflict-aware merge with user-visible resolution"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Start with dedupe, then add stronger causal/conflict handling.",
      "detailedExplanation": "Start from \"order replay-safety controls from foundational to advanced\", then pressure-test the result against the options. Order by relative scale and bottleneck effect, then validate neighboring items. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-094",
      "type": "ordering",
      "question": "Order by increasing stale-replay overwrite risk.",
      "items": [
        "CAS with expected version",
        "Version check only",
        "Timestamp compare only",
        "Blind apply on arrival"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Risk grows as version/causal safeguards are removed.",
      "detailedExplanation": "If you keep \"order by increasing stale-replay overwrite risk\" in view, the correct answer separates faster. Build the rank from biggest differences first, then refine with adjacent checks. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-095",
      "type": "ordering",
      "question": "Order rollout safety for new causal metadata.",
      "items": [
        "Dual-read compatibility mode",
        "Canary write path",
        "Measure anomaly deltas",
        "Promote and retire legacy format"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Compatibility and measured canarying reduce migration risk.",
      "detailedExplanation": "The core signal here is \"order rollout safety for new causal metadata\". Build the rank from biggest differences first, then refine with adjacent checks. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-096",
      "type": "ordering",
      "question": "Order by strongest evidence for clock-skew incident diagnosis.",
      "items": [
        "Anecdotal timestamps in logs",
        "Single host clock check",
        "Fleet skew histogram by region",
        "Skew histogram correlated with ordering anomalies"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Correlated telemetry provides highest diagnostic confidence.",
      "detailedExplanation": "Use \"order by strongest evidence for clock-skew incident diagnosis\" as your starting point, then verify tradeoffs carefully. Order by relative scale and bottleneck effect, then validate neighboring items. Map the choice to measurable reliability impact such as error budget burn and recovery behavior. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-097",
      "type": "ordering",
      "question": "Order processing models by throughput potential (typical).",
      "items": [
        "Global total order",
        "Cross-partition causal ordering",
        "Partition-local ordering",
        "Unordered commutative processing"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Throughput generally rises as ordering constraints relax.",
      "detailedExplanation": "This prompt is really about \"order processing models by throughput potential (typical)\". Place obvious extremes first, then sort the middle by pairwise comparison. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-098",
      "type": "ordering",
      "question": "Order degraded responses when causal uncertainty appears. (Time, Ordering & Causality context)",
      "items": [
        "Mark state pending",
        "Escalate to stronger read/validation path",
        "Delay dependent actions",
        "Require manual/compensating resolution for high-risk cases"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Progress from low-cost caution to stronger safeguards for high-risk actions.",
      "detailedExplanation": "The decision turns on \"order degraded responses when causal uncertainty appears\". Place obvious extremes first, then sort the middle by pairwise comparison. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-099",
      "type": "ordering",
      "question": "Order by increasing dependence on synchronized physical clocks.",
      "items": [
        "Pure logical/version ordering",
        "Logical+timestamp tie-break",
        "Timestamp-first with version fallback",
        "Timestamp-only correctness"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Reliance on physical clock synchronization grows along this ordering.",
      "detailedExplanation": "Read this as a scenario about \"order by increasing dependence on synchronized physical clocks\". Order by relative scale and bottleneck effect, then validate neighboring items. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-100",
      "type": "ordering",
      "question": "Order conflict-handling maturity.",
      "items": [
        "Implicit overwrite policy",
        "Static merge rule",
        "Entity-specific merge semantics",
        "Entity-specific semantics with user-visible conflict workflows"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Maturity improves with explicit domain-aware and user-aware conflict handling.",
      "detailedExplanation": "The key clue in this question is \"order conflict-handling maturity\". Place obvious extremes first, then sort the middle by pairwise comparison. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    }
  ]
}
