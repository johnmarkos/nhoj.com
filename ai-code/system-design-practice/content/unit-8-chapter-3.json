{
  "unit": 8,
  "unitTitle": "Consistency & Coordination",
  "chapter": 3,
  "chapterTitle": "Time, Ordering & Causality",
  "chapterDescription": "Modeling distributed event order under clock skew, reordering, and concurrency using logical clocks and causal metadata.",
  "problems": [
    {
      "id": "cc-tc-001",
      "type": "multiple-choice",
      "question": "A multi-device messaging feed is experiencing clock skew between regions. Which time/ordering strategy is strongest? Recent incident analysis links user-visible regressions to ordering assumptions.",
      "options": [
        "Use causal metadata (vector clocks/causal context) where dependent event order matters.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally."
      ],
      "correct": 0,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata.",
      "detailedExplanation": "A practical approach here is to lock down the dominant constraint before comparing answer choices. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-002",
      "type": "multiple-choice",
      "question": "A collaborative document editor is experiencing out-of-order event arrival. Which time/ordering strategy is strongest? The team needs a low-blast-radius first mitigation.",
      "options": [
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Separate wall-clock display time from correctness ordering logic using logical clocks."
      ],
      "correct": 3,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata.",
      "detailedExplanation": "Start by identifying the limiting factor, then rule out options that violate scale or semantics. Message design should specify delivery guarantees, ordering scope, and backpressure behavior under failure, not just happy-path throughput.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-003",
      "type": "multiple-choice",
      "question": "A inventory event processor is experiencing causal dependency not preserved. Which time/ordering strategy is strongest? Cross-region skew increased during the latest outage drill.",
      "options": [
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Use Lamport/logical sequence for deterministic processing order when real-time order is unreliable.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions."
      ],
      "correct": 2,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata.",
      "detailedExplanation": "Lead with the key assumption, then remove options that break units, scale, or architecture constraints. Message design should specify delivery guarantees, ordering scope, and backpressure behavior under failure, not just happy-path throughput.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-004",
      "type": "multiple-choice",
      "question": "A payment reconciliation pipeline is experiencing concurrent writes from multiple clients. Which time/ordering strategy is strongest? Concurrent client updates now occur more frequently.",
      "options": [
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Define merge/conflict policy for concurrent updates and preserve causality where required.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions."
      ],
      "correct": 1,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata.",
      "detailedExplanation": "Frame the problem around the main tradeoff first, then test each option for consistency. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-005",
      "type": "multiple-choice",
      "question": "A ride dispatch event stream is experiencing late-arriving updates after retries. Which time/ordering strategy is strongest? Replay traffic after retries is higher than expected.",
      "options": [
        "Treat physical timestamps as hints; validate order with causal/version metadata.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally."
      ],
      "correct": 0,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata.",
      "detailedExplanation": "Solve this by pinning the governing ratio first and using it to discard impossible answers. Message design should specify delivery guarantees, ordering scope, and backpressure behavior under failure, not just happy-path throughput.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        }
      ]
    },
    {
      "id": "cc-tc-006",
      "type": "multiple-choice",
      "question": "A support ticket workflow service is experiencing NTP drift under partial network issues. Which time/ordering strategy is strongest? Current logic mixes display time with correctness ordering.",
      "options": [
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Add per-entity monotonic version checks to reject stale reordered writes."
      ],
      "correct": 3,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata.",
      "detailedExplanation": "A reliable method is to name the primary boundary condition, then evaluate options against it. Bandwidth planning should normalize units first, then include protocol overhead and peak multipliers to avoid underestimating production load.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-007",
      "type": "multiple-choice",
      "question": "A notification timeline service is experiencing event timestamp collisions. Which time/ordering strategy is strongest? Anomaly alerts spike during failover and backlog recovery.",
      "options": [
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Use idempotent replay handling with causal guards for delayed events.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions."
      ],
      "correct": 2,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata.",
      "detailedExplanation": "The fastest path is to anchor on the core constraint and eliminate implausible options early. Message design should specify delivery guarantees, ordering scope, and backpressure behavior under failure, not just happy-path throughput.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-008",
      "type": "multiple-choice",
      "question": "A order lifecycle event bus is experiencing reordered queue delivery after failover. Which time/ordering strategy is strongest? The fix must preserve throughput on non-critical streams.",
      "options": [
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Partition ordering-sensitive streams and avoid cross-partition total-order assumptions.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions."
      ],
      "correct": 1,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata.",
      "detailedExplanation": "Treat this as a constraint-filtering problem: find the bottleneck first, then narrow the choices. Message design should specify delivery guarantees, ordering scope, and backpressure behavior under failure, not just happy-path throughput.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-009",
      "type": "multiple-choice",
      "question": "A social comment thread backend is experiencing duplicate event replay with old timestamps. Which time/ordering strategy is strongest? Causal dependencies are not explicitly encoded today.",
      "options": [
        "Expose uncertainty when causal order cannot be established from available metadata.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally."
      ],
      "correct": 0,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata.",
      "detailedExplanation": "A practical approach here is to lock down the dominant constraint before comparing answer choices. Message design should specify delivery guarantees, ordering scope, and backpressure behavior under failure, not just happy-path throughput.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ]
    },
    {
      "id": "cc-tc-010",
      "type": "multiple-choice",
      "question": "A feature-flag propagation service is experiencing mixed wall-clock and logical ordering assumptions. Which time/ordering strategy is strongest? Support reports timeline reversals across devices.",
      "options": [
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Instrument skew and reordering metrics; gate critical workflows when ordering confidence drops."
      ],
      "correct": 3,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata.",
      "detailedExplanation": "Lead with the key assumption, then remove options that break units, scale, or architecture constraints. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-011",
      "type": "multiple-choice",
      "question": "A profile update event system is experiencing clock skew between regions. Which time/ordering strategy is strongest? The service recently moved to multi-region active-active mode.",
      "options": [
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Use causal metadata (vector clocks/causal context) where dependent event order matters.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions."
      ],
      "correct": 2,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata.",
      "detailedExplanation": "Start by identifying the limiting factor, then rule out options that violate scale or semantics. Message design should specify delivery guarantees, ordering scope, and backpressure behavior under failure, not just happy-path throughput.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-012",
      "type": "multiple-choice",
      "question": "A moderation review queue is experiencing out-of-order event arrival. Which time/ordering strategy is strongest? Queue guarantees differ across partitions and brokers.",
      "options": [
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Separate wall-clock display time from correctness ordering logic using logical clocks.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions."
      ],
      "correct": 1,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata.",
      "detailedExplanation": "A practical approach here is to lock down the dominant constraint before comparing answer choices. Message design should specify delivery guarantees, ordering scope, and backpressure behavior under failure, not just happy-path throughput.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-013",
      "type": "multiple-choice",
      "question": "A chat read-receipt service is experiencing causal dependency not preserved. Which time/ordering strategy is strongest? Schema changes introduced metadata compatibility risk.",
      "options": [
        "Use Lamport/logical sequence for deterministic processing order when real-time order is unreliable.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally."
      ],
      "correct": 0,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata.",
      "detailedExplanation": "Treat this as a constraint-filtering problem: find the bottleneck first, then narrow the choices. Data model choices are strongest when grounded in query paths, write amplification, and index/storage overhead.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ]
    },
    {
      "id": "cc-tc-014",
      "type": "multiple-choice",
      "question": "A ad campaign state projector is experiencing concurrent writes from multiple clients. Which time/ordering strategy is strongest? Conflict handling policy is currently under-specified.",
      "options": [
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Define merge/conflict policy for concurrent updates and preserve causality where required."
      ],
      "correct": 3,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata.",
      "detailedExplanation": "The fastest path is to anchor on the core constraint and eliminate implausible options early. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-015",
      "type": "multiple-choice",
      "question": "A shipment tracking event feed is experiencing late-arriving updates after retries. Which time/ordering strategy is strongest? Leadership requested explicit ordering guarantees per workflow.",
      "options": [
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Treat physical timestamps as hints; validate order with causal/version metadata.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions."
      ],
      "correct": 2,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata.",
      "detailedExplanation": "A reliable method is to name the primary boundary condition, then evaluate options against it. Message design should specify delivery guarantees, ordering scope, and backpressure behavior under failure, not just happy-path throughput.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-016",
      "type": "multiple-choice",
      "question": "A device sync service is experiencing NTP drift under partial network issues. Which time/ordering strategy is strongest? Strict global order is too expensive for all paths.",
      "options": [
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Add per-entity monotonic version checks to reject stale reordered writes.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions."
      ],
      "correct": 1,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata.",
      "detailedExplanation": "Solve this by pinning the governing ratio first and using it to discard impossible answers. Bandwidth planning should normalize units first, then include protocol overhead and peak multipliers to avoid underestimating production load.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-017",
      "type": "multiple-choice",
      "question": "A analytics event enricher is experiencing event timestamp collisions. Which time/ordering strategy is strongest? The path includes both ordered and commutative updates.",
      "options": [
        "Use idempotent replay handling with causal guards for delayed events.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally."
      ],
      "correct": 0,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata.",
      "detailedExplanation": "Frame the problem around the main tradeoff first, then test each option for consistency. Message design should specify delivery guarantees, ordering scope, and backpressure behavior under failure, not just happy-path throughput.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-018",
      "type": "multiple-choice",
      "question": "A fraud alert pipeline is experiencing reordered queue delivery after failover. Which time/ordering strategy is strongest? Read-side projections lag behind event ingestion bursts.",
      "options": [
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Partition ordering-sensitive streams and avoid cross-partition total-order assumptions."
      ],
      "correct": 3,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata.",
      "detailedExplanation": "Lead with the key assumption, then remove options that break units, scale, or architecture constraints. Message design should specify delivery guarantees, ordering scope, and backpressure behavior under failure, not just happy-path throughput.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-019",
      "type": "multiple-choice",
      "question": "A catalog update fanout service is experiencing duplicate event replay with old timestamps. Which time/ordering strategy is strongest? Team needs clearer causal debugging telemetry.",
      "options": [
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Expose uncertainty when causal order cannot be established from available metadata.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions."
      ],
      "correct": 2,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata.",
      "detailedExplanation": "Start by identifying the limiting factor, then rule out options that violate scale or semantics. Message design should specify delivery guarantees, ordering scope, and backpressure behavior under failure, not just happy-path throughput.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-020",
      "type": "multiple-choice",
      "question": "A identity claim replication pipeline is experiencing mixed wall-clock and logical ordering assumptions. Which time/ordering strategy is strongest? Recovery workflows require deterministic replay behavior.",
      "options": [
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Instrument skew and reordering metrics; gate critical workflows when ordering confidence drops.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions."
      ],
      "correct": 1,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata.",
      "detailedExplanation": "Start by identifying the limiting factor, then rule out options that violate scale or semantics. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-021",
      "type": "multiple-choice",
      "question": "A multi-device messaging feed is experiencing clock skew between regions. Which time/ordering strategy is strongest? The incident repeats when delayed events arrive late.",
      "options": [
        "Use causal metadata (vector clocks/causal context) where dependent event order matters.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally."
      ],
      "correct": 0,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata.",
      "detailedExplanation": "Lead with the key assumption, then remove options that break units, scale, or architecture constraints. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-022",
      "type": "multiple-choice",
      "question": "A collaborative document editor is experiencing out-of-order event arrival. Which time/ordering strategy is strongest? System behavior differs by tenant under heavy concurrency.",
      "options": [
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Separate wall-clock display time from correctness ordering logic using logical clocks."
      ],
      "correct": 3,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata.",
      "detailedExplanation": "Treat this as a constraint-filtering problem: find the bottleneck first, then narrow the choices. Message design should specify delivery guarantees, ordering scope, and backpressure behavior under failure, not just happy-path throughput.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ]
    },
    {
      "id": "cc-tc-023",
      "type": "multiple-choice",
      "question": "A inventory event processor is experiencing causal dependency not preserved. Which time/ordering strategy is strongest? Clock synchronization confidence is temporarily degraded.",
      "options": [
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Use Lamport/logical sequence for deterministic processing order when real-time order is unreliable.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions."
      ],
      "correct": 2,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata.",
      "detailedExplanation": "A practical approach here is to lock down the dominant constraint before comparing answer choices. Message design should specify delivery guarantees, ordering scope, and backpressure behavior under failure, not just happy-path throughput.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-024",
      "type": "multiple-choice",
      "question": "A payment reconciliation pipeline is experiencing concurrent writes from multiple clients. Which time/ordering strategy is strongest? Some workflows can tolerate eventual ordering if explicit.",
      "options": [
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Define merge/conflict policy for concurrent updates and preserve causality where required.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions."
      ],
      "correct": 1,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata.",
      "detailedExplanation": "A reliable method is to name the primary boundary condition, then evaluate options against it. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-025",
      "type": "multiple-choice",
      "question": "A ride dispatch event stream is experiencing late-arriving updates after retries. Which time/ordering strategy is strongest? Critical workflows require clear happened-before semantics.",
      "options": [
        "Treat physical timestamps as hints; validate order with causal/version metadata.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally."
      ],
      "correct": 0,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata.",
      "detailedExplanation": "The fastest path is to anchor on the core constraint and eliminate implausible options early. Message design should specify delivery guarantees, ordering scope, and backpressure behavior under failure, not just happy-path throughput.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        }
      ]
    },
    {
      "id": "cc-tc-026",
      "type": "multiple-choice",
      "question": "A support ticket workflow service is experiencing NTP drift under partial network issues. Which time/ordering strategy is strongest? Operational runbooks currently ignore causal metadata health.",
      "options": [
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Add per-entity monotonic version checks to reject stale reordered writes."
      ],
      "correct": 3,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata.",
      "detailedExplanation": "Frame the problem around the main tradeoff first, then test each option for consistency. Bandwidth planning should normalize units first, then include protocol overhead and peak multipliers to avoid underestimating production load.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-027",
      "type": "multiple-choice",
      "question": "A notification timeline service is experiencing event timestamp collisions. Which time/ordering strategy is strongest? Downstream consumers assume stronger ordering than provided.",
      "options": [
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Use idempotent replay handling with causal guards for delayed events.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions."
      ],
      "correct": 2,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata.",
      "detailedExplanation": "Solve this by pinning the governing ratio first and using it to discard impossible answers. Message design should specify delivery guarantees, ordering scope, and backpressure behavior under failure, not just happy-path throughput.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-028",
      "type": "multiple-choice",
      "question": "A order lifecycle event bus is experiencing reordered queue delivery after failover. Which time/ordering strategy is strongest? Backpressure caused reorder spikes in one partition group.",
      "options": [
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Partition ordering-sensitive streams and avoid cross-partition total-order assumptions.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions."
      ],
      "correct": 1,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata.",
      "detailedExplanation": "Start by identifying the limiting factor, then rule out options that violate scale or semantics. Message design should specify delivery guarantees, ordering scope, and backpressure behavior under failure, not just happy-path throughput.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-029",
      "type": "multiple-choice",
      "question": "A social comment thread backend is experiencing duplicate event replay with old timestamps. Which time/ordering strategy is strongest? Product requirements now include monotonic timeline UX.",
      "options": [
        "Expose uncertainty when causal order cannot be established from available metadata.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally."
      ],
      "correct": 0,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata.",
      "detailedExplanation": "Lead with the key assumption, then remove options that break units, scale, or architecture constraints. Message design should specify delivery guarantees, ordering scope, and backpressure behavior under failure, not just happy-path throughput.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ]
    },
    {
      "id": "cc-tc-030",
      "type": "multiple-choice",
      "question": "A feature-flag propagation service is experiencing mixed wall-clock and logical ordering assumptions. Which time/ordering strategy is strongest? Engineering wants endpoint-level ordering contracts.",
      "options": [
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Instrument skew and reordering metrics; gate critical workflows when ordering confidence drops."
      ],
      "correct": 3,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata.",
      "detailedExplanation": "Solve this by pinning the governing ratio first and using it to discard impossible answers. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-031",
      "type": "multiple-choice",
      "question": "A profile update event system is experiencing clock skew between regions. Which time/ordering strategy is strongest? Retry dedupe currently lacks version monotonic guards.",
      "options": [
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Use causal metadata (vector clocks/causal context) where dependent event order matters.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions."
      ],
      "correct": 2,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata.",
      "detailedExplanation": "Frame the problem around the main tradeoff first, then test each option for consistency. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ]
    },
    {
      "id": "cc-tc-032",
      "type": "multiple-choice",
      "question": "A moderation review queue is experiencing out-of-order event arrival. Which time/ordering strategy is strongest? A canary rollout is required before broad policy changes.",
      "options": [
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Separate wall-clock display time from correctness ordering logic using logical clocks.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions."
      ],
      "correct": 1,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata.",
      "detailedExplanation": "The fastest path is to anchor on the core constraint and eliminate implausible options early. Message design should specify delivery guarantees, ordering scope, and backpressure behavior under failure, not just happy-path throughput.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-033",
      "type": "multiple-choice",
      "question": "A chat read-receipt service is experiencing causal dependency not preserved. Which time/ordering strategy is strongest? The team must minimize additional coordination latency.",
      "options": [
        "Use Lamport/logical sequence for deterministic processing order when real-time order is unreliable.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally."
      ],
      "correct": 0,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata.",
      "detailedExplanation": "A reliable method is to name the primary boundary condition, then evaluate options against it. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-034",
      "type": "multiple-choice",
      "question": "A ad campaign state projector is experiencing concurrent writes from multiple clients. Which time/ordering strategy is strongest? Audit paths need reproducible processing order evidence.",
      "options": [
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions.",
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Define merge/conflict policy for concurrent updates and preserve causality where required."
      ],
      "correct": 3,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata.",
      "detailedExplanation": "A practical approach here is to lock down the dominant constraint before comparing answer choices. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-035",
      "type": "multiple-choice",
      "question": "A shipment tracking event feed is experiencing late-arriving updates after retries. Which time/ordering strategy is strongest? Post-incident prevention is required with measurable SLOs.",
      "options": [
        "Assume queue delivery order always matches causal order across partitions.",
        "Ignore concurrent-update semantics and keep last-arrival-wins globally.",
        "Treat physical timestamps as hints; validate order with causal/version metadata.",
        "Rely solely on wall-clock timestamp comparisons for all correctness decisions."
      ],
      "correct": 2,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata.",
      "detailedExplanation": "Treat this as a constraint-filtering problem: find the bottleneck first, then narrow the choices. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ]
    },
    {
      "id": "cc-tc-036",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: payment reconciliation pipeline reports failures related to causal dependency not preserved. What is the primary diagnosis?",
          "options": [
            "Ordering bugs in payment reconciliation pipeline indicate mismatch between causal requirements and current timestamp/queue assumptions around causal dependency not preserved.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths."
          ],
          "correct": 0,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly.",
          "detailedExplanation": "This stage is best solved by propagating the earlier result and validating edge conditions. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while preserving low-latency reads?",
          "options": [
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Treat physical timestamps as hints; validate order with causal/version metadata."
          ],
          "correct": 3,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns.",
          "detailedExplanation": "Keep the previous conclusion fixed, then test this stage for consistency and scale. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them."
        }
      ],
      "detailedExplanation": "Anchor on the base formula, preserve unit integrity, and then run a reasonableness check. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-037",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: ride dispatch event stream reports failures related to concurrent writes from multiple clients. What is the primary diagnosis?",
          "options": [
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in ride dispatch event stream indicate mismatch between causal requirements and current timestamp/queue assumptions around concurrent writes from multiple clients."
          ],
          "correct": 3,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly.",
          "detailedExplanation": "Carry the prior stage assumptions forward and revalidate units before making the next decision. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under regional clock skew?",
          "options": [
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Add per-entity monotonic version checks to reject stale reordered writes.",
            "Force one global synchronized timestamp source for every service write path."
          ],
          "correct": 2,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns.",
          "detailedExplanation": "Translate the prior stage outcome into an operational check before selecting the next move. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Follow the canonical calculation path and check both units and magnitude before finalizing. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-038",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: support ticket workflow service reports failures related to late-arriving updates after retries. What is the primary diagnosis?",
          "options": [
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in support ticket workflow service indicate mismatch between causal requirements and current timestamp/queue assumptions around late-arriving updates after retries.",
            "Physical clocks are always sufficient for strict correctness ordering."
          ],
          "correct": 2,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly.",
          "detailedExplanation": "Use the result from the previous step as a hard constraint, then evaluate this stage against it. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change during replay/retry storms?",
          "options": [
            "Avoid metadata changes and accept occasional causal violations.",
            "Use idempotent replay handling with causal guards for delayed events.",
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance."
          ],
          "correct": 1,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns.",
          "detailedExplanation": "Use the earlier stage as the boundary condition and solve this step under that constraint. Message design should specify delivery guarantees, ordering scope, and backpressure behavior under failure, not just happy-path throughput."
        }
      ],
      "detailedExplanation": "Use a formula-first approach with explicit units to avoid hidden conversion mistakes. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-039",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: notification timeline service reports failures related to NTP drift under partial network issues. What is the primary diagnosis?",
          "options": [
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in notification timeline service indicate mismatch between causal requirements and current timestamp/queue assumptions around NTP drift under partial network issues.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled."
          ],
          "correct": 1,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly.",
          "detailedExplanation": "Use the earlier stage as the boundary condition and solve this step under that constraint. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change without forcing global total order?",
          "options": [
            "Partition ordering-sensitive streams and avoid cross-partition total-order assumptions.",
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations."
          ],
          "correct": 0,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns.",
          "detailedExplanation": "Use the result from the previous step as a hard constraint, then evaluate this stage against it. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Compute from the primary formula first, then sanity-check the scale of the result. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-040",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: order lifecycle event bus reports failures related to event timestamp collisions. What is the primary diagnosis?",
          "options": [
            "Ordering bugs in order lifecycle event bus indicate mismatch between causal requirements and current timestamp/queue assumptions around event timestamp collisions.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths."
          ],
          "correct": 0,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly.",
          "detailedExplanation": "Use the earlier stage as the boundary condition and solve this step under that constraint. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with cross-device concurrency?",
          "options": [
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Expose uncertainty when causal order cannot be established from available metadata."
          ],
          "correct": 3,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns.",
          "detailedExplanation": "Use the result from the previous step as a hard constraint, then evaluate this stage against it. Compute sizing should distinguish average vs peak demand and map both to per-node limits and scaling triggers."
        }
      ],
      "detailedExplanation": "Compute from the primary formula first, then sanity-check the scale of the result. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-041",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: social comment thread backend reports failures related to reordered queue delivery after failover. What is the primary diagnosis?",
          "options": [
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in social comment thread backend indicate mismatch between causal requirements and current timestamp/queue assumptions around reordered queue delivery after failover."
          ],
          "correct": 3,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly.",
          "detailedExplanation": "Use the result from the previous step as a hard constraint, then evaluate this stage against it. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under partitioned delivery paths?",
          "options": [
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Instrument skew and reordering metrics; gate critical workflows when ordering confidence drops.",
            "Force one global synchronized timestamp source for every service write path."
          ],
          "correct": 2,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns.",
          "detailedExplanation": "Use the earlier stage as the boundary condition and solve this step under that constraint. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Use a formula-first approach with explicit units to avoid hidden conversion mistakes. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-042",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: feature-flag propagation service reports failures related to duplicate event replay with old timestamps. What is the primary diagnosis?",
          "options": [
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in feature-flag propagation service indicate mismatch between causal requirements and current timestamp/queue assumptions around duplicate event replay with old timestamps.",
            "Physical clocks are always sufficient for strict correctness ordering."
          ],
          "correct": 2,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly.",
          "detailedExplanation": "Keep the previous conclusion fixed, then test this stage for consistency and scale. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while keeping idempotent handlers simple?",
          "options": [
            "Avoid metadata changes and accept occasional causal violations.",
            "Use causal metadata (vector clocks/causal context) where dependent event order matters.",
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance."
          ],
          "correct": 1,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns.",
          "detailedExplanation": "This stage is best solved by propagating the earlier result and validating edge conditions. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly."
        }
      ],
      "detailedExplanation": "Start from the governing formula, keep units visible, and validate the final magnitude. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-043",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: profile update event system reports failures related to mixed wall-clock and logical ordering assumptions. What is the primary diagnosis?",
          "options": [
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in profile update event system indicate mismatch between causal requirements and current timestamp/queue assumptions around mixed wall-clock and logical ordering assumptions.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled."
          ],
          "correct": 1,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly.",
          "detailedExplanation": "Translate the prior stage outcome into an operational check before selecting the next move. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change during failover recovery?",
          "options": [
            "Separate wall-clock display time from correctness ordering logic using logical clocks.",
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations."
          ],
          "correct": 0,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns.",
          "detailedExplanation": "Carry the prior stage assumptions forward and revalidate units before making the next decision. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Apply the main relationship stepwise and verify unit consistency at each step. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-044",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: moderation review queue reports failures related to clock skew between regions. What is the primary diagnosis?",
          "options": [
            "Ordering bugs in moderation review queue indicate mismatch between causal requirements and current timestamp/queue assumptions around clock skew between regions.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths."
          ],
          "correct": 0,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly.",
          "detailedExplanation": "Treat this as a continuation step: preserve earlier constraints and recheck feasibility. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with mixed ordered/unordered streams?",
          "options": [
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Use Lamport/logical sequence for deterministic processing order when real-time order is unreliable."
          ],
          "correct": 3,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns.",
          "detailedExplanation": "Advance from the first-stage output, then verify that this decision still respects the same limits. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Work through the core math with unit labels attached, then verify scale plausibility. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-045",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: chat read-receipt service reports failures related to out-of-order event arrival. What is the primary diagnosis?",
          "options": [
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in chat read-receipt service indicate mismatch between causal requirements and current timestamp/queue assumptions around out-of-order event arrival."
          ],
          "correct": 3,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly.",
          "detailedExplanation": "Advance from the first-stage output, then verify that this decision still respects the same limits. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change before broad rollout?",
          "options": [
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Define merge/conflict policy for concurrent updates and preserve causality where required.",
            "Force one global synchronized timestamp source for every service write path."
          ],
          "correct": 2,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns.",
          "detailedExplanation": "Treat this as a continuation step: preserve earlier constraints and recheck feasibility. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Use the core equation with explicit unit tracking before committing to an answer. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-046",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: ad campaign state projector reports failures related to causal dependency not preserved. What is the primary diagnosis?",
          "options": [
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in ad campaign state projector indicate mismatch between causal requirements and current timestamp/queue assumptions around causal dependency not preserved.",
            "Physical clocks are always sufficient for strict correctness ordering."
          ],
          "correct": 2,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly.",
          "detailedExplanation": "Carry the prior stage assumptions forward and revalidate units before making the next decision. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while minimizing user-visible regressions?",
          "options": [
            "Avoid metadata changes and accept occasional causal violations.",
            "Treat physical timestamps as hints; validate order with causal/version metadata.",
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance."
          ],
          "correct": 1,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns.",
          "detailedExplanation": "Translate the prior stage outcome into an operational check before selecting the next move. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Follow the canonical calculation path and check both units and magnitude before finalizing. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-047",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: shipment tracking event feed reports failures related to concurrent writes from multiple clients. What is the primary diagnosis?",
          "options": [
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in shipment tracking event feed indicate mismatch between causal requirements and current timestamp/queue assumptions around concurrent writes from multiple clients.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled."
          ],
          "correct": 1,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly.",
          "detailedExplanation": "This stage is best solved by propagating the earlier result and validating edge conditions. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under sustained traffic bursts?",
          "options": [
            "Add per-entity monotonic version checks to reject stale reordered writes.",
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations."
          ],
          "correct": 0,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns.",
          "detailedExplanation": "Keep the previous conclusion fixed, then test this stage for consistency and scale. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Anchor on the base formula, preserve unit integrity, and then run a reasonableness check. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-048",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: device sync service reports failures related to late-arriving updates after retries. What is the primary diagnosis?",
          "options": [
            "Ordering bugs in device sync service indicate mismatch between causal requirements and current timestamp/queue assumptions around late-arriving updates after retries.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths."
          ],
          "correct": 0,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly.",
          "detailedExplanation": "Use the earlier stage as the boundary condition and solve this step under that constraint. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with constrained control-plane confidence?",
          "options": [
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Use idempotent replay handling with causal guards for delayed events."
          ],
          "correct": 3,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns.",
          "detailedExplanation": "Use the result from the previous step as a hard constraint, then evaluate this stage against it. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Compute from the primary formula first, then sanity-check the scale of the result. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-049",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: analytics event enricher reports failures related to NTP drift under partial network issues. What is the primary diagnosis?",
          "options": [
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in analytics event enricher indicate mismatch between causal requirements and current timestamp/queue assumptions around NTP drift under partial network issues."
          ],
          "correct": 3,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly.",
          "detailedExplanation": "Use the result from the previous step as a hard constraint, then evaluate this stage against it. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while protecting invariant checks?",
          "options": [
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Partition ordering-sensitive streams and avoid cross-partition total-order assumptions.",
            "Force one global synchronized timestamp source for every service write path."
          ],
          "correct": 2,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns.",
          "detailedExplanation": "Use the earlier stage as the boundary condition and solve this step under that constraint. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Use a formula-first approach with explicit units to avoid hidden conversion mistakes. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-050",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: fraud alert pipeline reports failures related to event timestamp collisions. What is the primary diagnosis?",
          "options": [
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in fraud alert pipeline indicate mismatch between causal requirements and current timestamp/queue assumptions around event timestamp collisions.",
            "Physical clocks are always sufficient for strict correctness ordering."
          ],
          "correct": 2,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly.",
          "detailedExplanation": "Translate the prior stage outcome into an operational check before selecting the next move. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change during metadata format migration?",
          "options": [
            "Avoid metadata changes and accept occasional causal violations.",
            "Expose uncertainty when causal order cannot be established from available metadata.",
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance."
          ],
          "correct": 1,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns.",
          "detailedExplanation": "Carry the prior stage assumptions forward and revalidate units before making the next decision. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Apply the main relationship stepwise and verify unit consistency at each step. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-051",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: catalog update fanout service reports failures related to reordered queue delivery after failover. What is the primary diagnosis?",
          "options": [
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in catalog update fanout service indicate mismatch between causal requirements and current timestamp/queue assumptions around reordered queue delivery after failover.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled."
          ],
          "correct": 1,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly.",
          "detailedExplanation": "Keep the previous conclusion fixed, then test this stage for consistency and scale. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under partial message loss?",
          "options": [
            "Instrument skew and reordering metrics; gate critical workflows when ordering confidence drops.",
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations."
          ],
          "correct": 0,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns.",
          "detailedExplanation": "This stage is best solved by propagating the earlier result and validating edge conditions. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Start from the governing formula, keep units visible, and validate the final magnitude. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-052",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: identity claim replication pipeline reports failures related to duplicate event replay with old timestamps. What is the primary diagnosis?",
          "options": [
            "Ordering bugs in identity claim replication pipeline indicate mismatch between causal requirements and current timestamp/queue assumptions around duplicate event replay with old timestamps.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths."
          ],
          "correct": 0,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly.",
          "detailedExplanation": "Use the result from the previous step as a hard constraint, then evaluate this stage against it. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while preserving throughput targets?",
          "options": [
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Use causal metadata (vector clocks/causal context) where dependent event order matters."
          ],
          "correct": 3,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns.",
          "detailedExplanation": "Use the earlier stage as the boundary condition and solve this step under that constraint. Storage estimates should separate raw data, replication, and retention horizon so capacity and cost risk are visible early."
        }
      ],
      "detailedExplanation": "Use a formula-first approach with explicit units to avoid hidden conversion mistakes. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-053",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: multi-device messaging feed reports failures related to mixed wall-clock and logical ordering assumptions. What is the primary diagnosis?",
          "options": [
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in multi-device messaging feed indicate mismatch between causal requirements and current timestamp/queue assumptions around mixed wall-clock and logical ordering assumptions."
          ],
          "correct": 3,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly.",
          "detailedExplanation": "Use the earlier stage as the boundary condition and solve this step under that constraint. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with clear degraded semantics?",
          "options": [
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Separate wall-clock display time from correctness ordering logic using logical clocks.",
            "Force one global synchronized timestamp source for every service write path."
          ],
          "correct": 2,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns.",
          "detailedExplanation": "Use the result from the previous step as a hard constraint, then evaluate this stage against it. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Compute from the primary formula first, then sanity-check the scale of the result. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-054",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: collaborative document editor reports failures related to clock skew between regions. What is the primary diagnosis?",
          "options": [
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in collaborative document editor indicate mismatch between causal requirements and current timestamp/queue assumptions around clock skew between regions.",
            "Physical clocks are always sufficient for strict correctness ordering."
          ],
          "correct": 2,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly.",
          "detailedExplanation": "This stage is best solved by propagating the earlier result and validating edge conditions. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change during dependency brownouts?",
          "options": [
            "Avoid metadata changes and accept occasional causal violations.",
            "Use Lamport/logical sequence for deterministic processing order when real-time order is unreliable.",
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance."
          ],
          "correct": 1,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns.",
          "detailedExplanation": "Keep the previous conclusion fixed, then test this stage for consistency and scale. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Anchor on the base formula, preserve unit integrity, and then run a reasonableness check. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-055",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: inventory event processor reports failures related to out-of-order event arrival. What is the primary diagnosis?",
          "options": [
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in inventory event processor indicate mismatch between causal requirements and current timestamp/queue assumptions around out-of-order event arrival.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled."
          ],
          "correct": 1,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly.",
          "detailedExplanation": "Carry the prior stage assumptions forward and revalidate units before making the next decision. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with strict audit traceability?",
          "options": [
            "Define merge/conflict policy for concurrent updates and preserve causality where required.",
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations."
          ],
          "correct": 0,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns.",
          "detailedExplanation": "Translate the prior stage outcome into an operational check before selecting the next move. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Follow the canonical calculation path and check both units and magnitude before finalizing. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-056",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: payment reconciliation pipeline reports failures related to causal dependency not preserved. What is the primary diagnosis?",
          "options": [
            "Ordering bugs in payment reconciliation pipeline indicate mismatch between causal requirements and current timestamp/queue assumptions around causal dependency not preserved.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths."
          ],
          "correct": 0,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly.",
          "detailedExplanation": "Advance from the first-stage output, then verify that this decision still respects the same limits. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under delayed regional replication?",
          "options": [
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Treat physical timestamps as hints; validate order with causal/version metadata."
          ],
          "correct": 3,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns.",
          "detailedExplanation": "Treat this as a continuation step: preserve earlier constraints and recheck feasibility. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Use the core equation with explicit unit tracking before committing to an answer. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-057",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: ride dispatch event stream reports failures related to concurrent writes from multiple clients. What is the primary diagnosis?",
          "options": [
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in ride dispatch event stream indicate mismatch between causal requirements and current timestamp/queue assumptions around concurrent writes from multiple clients."
          ],
          "correct": 3,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly.",
          "detailedExplanation": "Treat this as a continuation step: preserve earlier constraints and recheck feasibility. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while limiting merge complexity?",
          "options": [
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Add per-entity monotonic version checks to reject stale reordered writes.",
            "Force one global synchronized timestamp source for every service write path."
          ],
          "correct": 2,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns.",
          "detailedExplanation": "Advance from the first-stage output, then verify that this decision still respects the same limits. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Work through the core math with unit labels attached, then verify scale plausibility. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-058",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: support ticket workflow service reports failures related to late-arriving updates after retries. What is the primary diagnosis?",
          "options": [
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in support ticket workflow service indicate mismatch between causal requirements and current timestamp/queue assumptions around late-arriving updates after retries.",
            "Physical clocks are always sufficient for strict correctness ordering."
          ],
          "correct": 2,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly.",
          "detailedExplanation": "Translate the prior stage outcome into an operational check before selecting the next move. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with existing schema compatibility constraints?",
          "options": [
            "Avoid metadata changes and accept occasional causal violations.",
            "Use idempotent replay handling with causal guards for delayed events.",
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance."
          ],
          "correct": 1,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns.",
          "detailedExplanation": "Carry the prior stage assumptions forward and revalidate units before making the next decision. Data model choices are strongest when grounded in query paths, write amplification, and index/storage overhead."
        }
      ],
      "detailedExplanation": "Apply the main relationship stepwise and verify unit consistency at each step. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-059",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: notification timeline service reports failures related to NTP drift under partial network issues. What is the primary diagnosis?",
          "options": [
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in notification timeline service indicate mismatch between causal requirements and current timestamp/queue assumptions around NTP drift under partial network issues.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled."
          ],
          "correct": 1,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly.",
          "detailedExplanation": "Keep the previous conclusion fixed, then test this stage for consistency and scale. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change during backlog drain?",
          "options": [
            "Partition ordering-sensitive streams and avoid cross-partition total-order assumptions.",
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations."
          ],
          "correct": 0,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns.",
          "detailedExplanation": "This stage is best solved by propagating the earlier result and validating edge conditions. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Start from the governing formula, keep units visible, and validate the final magnitude. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-060",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: order lifecycle event bus reports failures related to event timestamp collisions. What is the primary diagnosis?",
          "options": [
            "Ordering bugs in order lifecycle event bus indicate mismatch between causal requirements and current timestamp/queue assumptions around event timestamp collisions.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths."
          ],
          "correct": 0,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly.",
          "detailedExplanation": "Keep the previous conclusion fixed, then test this stage for consistency and scale. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with explicit anomaly alerts enabled?",
          "options": [
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Expose uncertainty when causal order cannot be established from available metadata."
          ],
          "correct": 3,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns.",
          "detailedExplanation": "This stage is best solved by propagating the earlier result and validating edge conditions. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost."
        }
      ],
      "detailedExplanation": "Start from the governing formula, keep units visible, and validate the final magnitude. Consistency decisions should be anchored to required invariants and failure modes, then balanced against latency and availability costs.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-061",
      "type": "multi-select",
      "question": "Why are wall clocks alone insufficient for distributed ordering? (Select all that apply)",
      "options": [
        "Clock skew/drift exists",
        "Events can be delayed/reordered in transit",
        "NTP guarantees perfect global ordering",
        "Concurrent writes may share similar timestamps"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Physical clocks are imperfect and network effects break naive timestamp ordering assumptions.",
      "detailedExplanation": "Treat each candidate as a separate true/false check against the same governing requirement. Bandwidth planning should normalize units first, then include protocol overhead and peak multipliers to avoid underestimating production load.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-062",
      "type": "multi-select",
      "question": "Vector clocks are most useful for which? (Select all that apply)",
      "options": [
        "Detecting concurrent updates",
        "Capturing causal relationships",
        "Providing exact real-world event time",
        "Supporting conflict-aware merges"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Vector clocks model causality/concurrency, not real-time precision.",
      "detailedExplanation": "Run a one-by-one validity check and discard options that depend on unstated conditions. Compute sizing should distinguish average vs peak demand and map both to per-node limits and scaling triggers.",
      "references": [
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-063",
      "type": "multi-select",
      "question": "Lamport clocks help with which tasks? (Select all that apply)",
      "options": [
        "Deriving a consistent happened-before-compatible order",
        "Breaking ties for deterministic processing",
        "Detecting exact concurrency in all cases",
        "Reducing dependence on wall-clock synchronization"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Lamport clocks support ordering but cannot fully distinguish all concurrent cases.",
      "detailedExplanation": "Avoid grouped guessing: test every option directly against the system boundary condition. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-064",
      "type": "multi-select",
      "question": "Good practices for event reordering tolerance include which? (Select all that apply)",
      "options": [
        "Idempotent handlers",
        "Per-entity version checks",
        "Assuming strict in-order delivery globally",
        "Late-event handling policy"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Robust systems assume delays/reordering and enforce correctness via metadata/policies.",
      "detailedExplanation": "Use independent validation per option to prevent partial truths from slipping into the final set. Message design should specify delivery guarantees, ordering scope, and backpressure behavior under failure, not just happy-path throughput.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-065",
      "type": "multi-select",
      "question": "Causal consistency is especially important when which apply? (Select all that apply)",
      "options": [
        "Reply should not appear before original message",
        "Dependent workflow steps must preserve order",
        "Independent counters only",
        "User sees own actions reflected coherently"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Causal guarantees matter when semantic dependencies exist between operations.",
      "detailedExplanation": "Assess each option separately and keep answers that hold across the full problem context. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-066",
      "type": "multi-select",
      "question": "Which signs indicate ordering assumptions are broken? (Select all that apply)",
      "options": [
        "State appears to revert after newer update",
        "Duplicate replay overwrites newer data",
        "Stable monotonic version progression",
        "Cross-device conflicting timelines"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Reversions and timeline conflicts are classic ordering/causality symptoms.",
      "detailedExplanation": "Check every option on its own merits and reject statements that are only true under hidden assumptions. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-067",
      "type": "multi-select",
      "question": "To separate display time from correctness ordering, which are valid? (Select all that apply)",
      "options": [
        "Store logical/causal version for writes",
        "Use wall-clock only for UI display context",
        "Use display timestamp as sole conflict resolver always",
        "Retain metadata needed for conflict resolution"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Correctness should be metadata-driven; display time can remain user-facing context.",
      "detailedExplanation": "Evaluate each option independently against the constraint instead of looking for a pattern across choices. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-068",
      "type": "multi-select",
      "question": "Which are valid conflict-resolution strategies for concurrent updates? (Select all that apply)",
      "options": [
        "Domain-specific merge rules",
        "User-visible conflict resolution for critical fields",
        "Blind last-arrival-wins everywhere",
        "CRDT-style commutative merges where suitable"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Conflict policy should match domain semantics; naive global last-arrival wins is risky.",
      "detailedExplanation": "Score each option independently and keep only those that remain valid under the stated constraints. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-069",
      "type": "multi-select",
      "question": "Useful observability for time/ordering issues includes which? (Select all that apply)",
      "options": [
        "Clock skew distribution",
        "Out-of-order event rate",
        "Only CPU utilization",
        "Version regression counters"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Ordering incidents require direct telemetry on skew/reordering/version regressions.",
      "detailedExplanation": "Treat each candidate as a separate true/false check against the same governing requirement. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-070",
      "type": "multi-select",
      "question": "When can total ordering be overkill? (Select all that apply)",
      "options": [
        "Independent entities that do not interact causally",
        "Workloads where partition-local order is enough",
        "Critical global invariants across all operations",
        "Paths where commutative updates are valid"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Global total order is costly; use it only where truly required.",
      "detailedExplanation": "Evaluate each option independently against the constraint instead of looking for a pattern across choices. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-071",
      "type": "multi-select",
      "question": "Which anti-patterns commonly cause causal bugs? (Select all that apply)",
      "options": [
        "Mixing event-time and processing-time semantics silently",
        "Dropping causal metadata in intermediate services",
        "Maintaining per-entity version history",
        "Assuming retries preserve original order"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Lost metadata and hidden semantic assumptions create ordering failures.",
      "detailedExplanation": "Check every option on its own merits and reject statements that are only true under hidden assumptions. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-072",
      "type": "multi-select",
      "question": "For replay pipelines, which controls help preserve correctness? (Select all that apply)",
      "options": [
        "Idempotency keys",
        "Version monotonicity checks",
        "Allow stale replay to overwrite newer writes",
        "Replay windows with dedupe state"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Replay safety depends on idempotency, monotonic guards, and dedupe controls.",
      "detailedExplanation": "Assess each option separately and keep answers that hold across the full problem context. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-073",
      "type": "multi-select",
      "question": "Which conditions increase clock-skew risk impact? (Select all that apply)",
      "options": [
        "Cross-region writes with strict timestamp ordering assumptions",
        "NTP instability in isolated networks",
        "Logical versioning on critical writes",
        "Conflict resolution solely by wall time"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Skew is most harmful when correctness logic relies directly on physical time ordering.",
      "detailedExplanation": "Use independent validation per option to prevent partial truths from slipping into the final set. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-074",
      "type": "multi-select",
      "question": "When introducing causal metadata, which rollout steps are useful? (Select all that apply)",
      "options": [
        "Dual-write old/new metadata temporarily",
        "Backwards-compatible read logic during migration",
        "Big-bang schema switch with no fallback",
        "Canary validation of ordering anomaly rates"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Compatibility and canarying reduce migration risk.",
      "detailedExplanation": "Avoid grouped guessing: test every option directly against the system boundary condition. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-075",
      "type": "multi-select",
      "question": "Which are valid degraded behaviors when causal order is uncertain? (Select all that apply)",
      "options": [
        "Delay user-visible apply until dependency confirmed",
        "Show pending sync state",
        "Silently overwrite with uncertain update",
        "Escalate to stronger read path for validation"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Explicit degraded semantics are safer than silent incorrect ordering.",
      "detailedExplanation": "Run a one-by-one validity check and discard options that depend on unstated conditions. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-076",
      "type": "multi-select",
      "question": "Which workloads typically need at least partition-local ordering? (Select all that apply)",
      "options": [
        "Per-account ledger streams",
        "Chat threads with reply ordering",
        "Totally independent telemetry counters",
        "Order-status event progression"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Entity-local workflows often need consistent local sequence semantics.",
      "detailedExplanation": "Treat each candidate as a separate true/false check against the same governing requirement. Message design should specify delivery guarantees, ordering scope, and backpressure behavior under failure, not just happy-path throughput.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-077",
      "type": "multi-select",
      "question": "What helps prevent newer write overwritten by older replay? (Select all that apply)",
      "options": [
        "Per-entity monotonic version checks",
        "Compare-and-set on expected version",
        "Timestamp-only last-arrival wins policy",
        "Replay dedupe with causal/version metadata"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Version and CAS protections guard against stale replay overwrites.",
      "detailedExplanation": "Score each option independently and keep only those that remain valid under the stated constraints. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-078",
      "type": "numeric-input",
      "question": "A stream processes 18,000 events/sec. Out-of-order rate is 0.6%. Out-of-order events/sec?",
      "answer": 108,
      "unit": "events/sec",
      "tolerance": 0.02,
      "explanation": "0.006 * 18,000 = 108.",
      "detailedExplanation": "Do the conversion step first and maintain unit labels to prevent silent math errors. Bandwidth planning should normalize units first, then include protocol overhead and peak multipliers to avoid underestimating production load.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-079",
      "type": "numeric-input",
      "question": "Clock skew p99 is 420ms, tolerance budget is 150ms. Percent over budget?",
      "answer": 180,
      "unit": "%",
      "tolerance": 0.5,
      "explanation": "(420-150)/150 = 180%.",
      "detailedExplanation": "Use base-unit arithmetic plus a magnitude check to keep the estimate robust under time pressure. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them.",
      "references": [
        {
          "title": "Percentile",
          "url": "https://en.wikipedia.org/wiki/Percentile"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-080",
      "type": "numeric-input",
      "question": "Event replay backlog is 720,000 events. Replayer throughput is 4,000 events/sec. Seconds to drain (no new events)?",
      "answer": 180,
      "unit": "seconds",
      "tolerance": 0,
      "explanation": "720,000 / 4,000 = 180s.",
      "detailedExplanation": "Use base-unit arithmetic plus a magnitude check to keep the estimate robust under time pressure. Message design should specify delivery guarantees, ordering scope, and backpressure behavior under failure, not just happy-path throughput.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-081",
      "type": "numeric-input",
      "question": "A service sees 2,400,000 updates/day. Concurrent-update conflict rate is 0.35%. Conflicts/day?",
      "answer": 8400,
      "unit": "updates",
      "tolerance": 0.02,
      "explanation": "0.0035 * 2,400,000 = 8,400.",
      "detailedExplanation": "Do the conversion step first and maintain unit labels to prevent silent math errors. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-082",
      "type": "numeric-input",
      "question": "Monotonic-version violation rate is 0.09% across 9,000,000 writes/day. Violations/day?",
      "answer": 8100,
      "unit": "writes",
      "tolerance": 0.03,
      "explanation": "0.0009 * 9,000,000 = 8,100.",
      "detailedExplanation": "Normalize units before calculating, and keep order-of-magnitude checks explicit throughout. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-083",
      "type": "numeric-input",
      "question": "Causal-metadata payload adds 42 bytes/event at 65,000 events/sec. Extra MB/sec (decimal MB)?",
      "answer": 2.73,
      "unit": "MB/sec",
      "tolerance": 0.08,
      "explanation": "65,000*42 = 2,730,000 bytes/sec  2.73 MB/sec.",
      "detailedExplanation": "Anchor the math in base units and check each transformation to avoid compounding conversion errors. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-084",
      "type": "numeric-input",
      "question": "Retry replay adds 0.18 extra deliveries per original event. At 30,000 original events/sec, effective deliveries/sec?",
      "answer": 35400,
      "unit": "deliveries/sec",
      "tolerance": 0.02,
      "explanation": "30,000 * 1.18 = 35,400.",
      "detailedExplanation": "Start with unit normalization, then verify that the final magnitude passes a quick sanity check. Message design should specify delivery guarantees, ordering scope, and backpressure behavior under failure, not just happy-path throughput.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Retry pattern",
          "url": "https://learn.microsoft.com/en-us/azure/architecture/patterns/retry"
        }
      ]
    },
    {
      "id": "cc-tc-085",
      "type": "numeric-input",
      "question": "A per-entity stream has 12 partitions and one hot partition carries 26% traffic. If total is 48,000 events/sec, hot-partition rate?",
      "answer": 12480,
      "unit": "events/sec",
      "tolerance": 0.02,
      "explanation": "0.26 * 48,000 = 12,480.",
      "detailedExplanation": "Reduce the problem to base units, compute, and sanity-check the output scale before finalizing. Message design should specify delivery guarantees, ordering scope, and backpressure behavior under failure, not just happy-path throughput.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        }
      ]
    },
    {
      "id": "cc-tc-086",
      "type": "numeric-input",
      "question": "A timeline merge waits up to 250ms for causal predecessor. Current average pause is 90ms. Remaining budget?",
      "answer": 160,
      "unit": "ms",
      "tolerance": 0,
      "explanation": "250 - 90 = 160ms.",
      "detailedExplanation": "Make the units explicit at every step, then validate the resulting magnitude against known anchors. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-087",
      "type": "numeric-input",
      "question": "Out-of-order anomaly SLO is <=0.2%. Observed is 0.47%. How many times above SLO is observed?",
      "answer": 2.35,
      "unit": "x",
      "tolerance": 0.05,
      "explanation": "0.47 / 0.2 = 2.35x.",
      "detailedExplanation": "Convert to base units first, then track powers of ten so arithmetic mistakes are easier to catch. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-088",
      "type": "numeric-input",
      "question": "If 15% of operations require causal checks and total ops are 80,000/sec, how many causal-check ops/sec?",
      "answer": 12000,
      "unit": "ops/sec",
      "tolerance": 0.01,
      "explanation": "0.15 * 80,000 = 12,000.",
      "detailedExplanation": "Use base-unit arithmetic plus a magnitude check to keep the estimate robust under time pressure. A good sanity check compares against anchor numbers and names which assumption must change if the result looks implausible.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-089",
      "type": "numeric-input",
      "question": "A conflict resolver succeeds automatically for 92% of 50,000 concurrent conflicts/day. Manual conflicts/day?",
      "answer": 4000,
      "unit": "conflicts",
      "tolerance": 0.02,
      "explanation": "8% of 50,000 = 4,000.",
      "detailedExplanation": "Do the conversion step first and maintain unit labels to prevent silent math errors. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-090",
      "type": "ordering",
      "question": "Order a robust ordering-bug triage flow.",
      "items": [
        "Confirm anomaly type (skew/reorder/concurrency)",
        "Inspect causal/version metadata path",
        "Apply targeted ordering control",
        "Add regression alert/test coverage"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Classify, diagnose metadata gaps, mitigate, then harden.",
      "detailedExplanation": "Use relative magnitude to draft the order and confirm it with local adjacency checks. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-091",
      "type": "ordering",
      "question": "Order by increasing guarantee strength (typical).",
      "items": [
        "Best-effort eventual order",
        "Partition-local order",
        "Causal order",
        "Global total order"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Stronger ordering guarantees add coordination cost.",
      "detailedExplanation": "Establish the extremes first and fill the middle with pairwise comparisons. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-092",
      "type": "ordering",
      "question": "Order by likely implementation complexity.",
      "items": [
        "Timestamp-only sort",
        "Lamport-clock ordering",
        "Vector-clock causal tracking",
        "Global total-order broadcast"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Complexity generally increases with stronger/ broader ordering semantics.",
      "detailedExplanation": "Prioritize ratio-based comparisons and validate each neighboring step to avoid inversion mistakes. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-093",
      "type": "ordering",
      "question": "Order replay-safety controls from foundational to advanced.",
      "items": [
        "Idempotency key checks",
        "Per-entity version monotonicity guard",
        "Causal dependency validation",
        "Conflict-aware merge with user-visible resolution"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Start with dedupe, then add stronger causal/conflict handling.",
      "detailedExplanation": "Start with the clear smallest/largest anchors, then place intermediate items by pairwise checks. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-094",
      "type": "ordering",
      "question": "Order by increasing stale-replay overwrite risk.",
      "items": [
        "CAS with expected version",
        "Version check only",
        "Timestamp compare only",
        "Blind apply on arrival"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Risk grows as version/causal safeguards are removed.",
      "detailedExplanation": "Rank by dominant bottleneck or magnitude, then validate adjacent transitions for consistency. The key API design signal is tradeoff clarity: client ergonomics, backward compatibility, and evolvability should be justified explicitly.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-095",
      "type": "ordering",
      "question": "Order rollout safety for new causal metadata.",
      "items": [
        "Dual-read compatibility mode",
        "Canary write path",
        "Measure anomaly deltas",
        "Promote and retire legacy format"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Compatibility and measured canarying reduce migration risk.",
      "detailedExplanation": "Build the ordering from major scale differences first, then refine with adjacent comparisons. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-096",
      "type": "ordering",
      "question": "Order by strongest evidence for clock-skew incident diagnosis.",
      "items": [
        "Anecdotal timestamps in logs",
        "Single host clock check",
        "Fleet skew histogram by region",
        "Skew histogram correlated with ordering anomalies"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Correlated telemetry provides highest diagnostic confidence.",
      "detailedExplanation": "Order by relative impact rather than exact values, then verify the sequence one boundary at a time. Translate target percentages into concrete time or request budgets, then test whether incident frequency and recovery speed can actually satisfy them.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-097",
      "type": "ordering",
      "question": "Order processing models by throughput potential (typical).",
      "items": [
        "Global total order",
        "Cross-partition causal ordering",
        "Partition-local ordering",
        "Unordered commutative processing"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Throughput generally rises as ordering constraints relax.",
      "detailedExplanation": "Compare relative scale first, then confirm neighboring items pairwise to lock in the order. Storage estimates should separate raw data, replication, and retention horizon so capacity and cost risk are visible early.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-098",
      "type": "ordering",
      "question": "Order degraded responses when causal uncertainty appears.",
      "items": [
        "Mark state pending",
        "Escalate to stronger read/validation path",
        "Delay dependent actions",
        "Require manual/compensating resolution for high-risk cases"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Progress from low-cost caution to stronger safeguards for high-risk actions.",
      "detailedExplanation": "Use relative magnitude to draft the order and confirm it with local adjacency checks. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-099",
      "type": "ordering",
      "question": "Order by increasing dependence on synchronized physical clocks.",
      "items": [
        "Pure logical/version ordering",
        "Logical+timestamp tie-break",
        "Timestamp-first with version fallback",
        "Timestamp-only correctness"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Reliance on physical clock synchronization grows along this ordering.",
      "detailedExplanation": "Establish the extremes first and fill the middle with pairwise comparisons. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    },
    {
      "id": "cc-tc-100",
      "type": "ordering",
      "question": "Order conflict-handling maturity.",
      "items": [
        "Implicit overwrite policy",
        "Static merge rule",
        "Entity-specific merge semantics",
        "Entity-specific semantics with user-visible conflict workflows"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Maturity improves with explicit domain-aware and user-aware conflict handling.",
      "detailedExplanation": "Prioritize ratio-based comparisons and validate each neighboring step to avoid inversion mistakes. Consistency choices should be tied to concrete invariants and failure modes, then balanced against latency and availability cost.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ]
    }
  ]
}
