{
  "unit": 8,
  "unitTitle": "Consistency & Coordination",
  "chapter": 3,
  "chapterTitle": "Time, Ordering & Causality",
  "chapterDescription": "Modeling distributed event order under clock skew, reordering, and concurrency using logical clocks and causal metadata.",
  "problems": [
    {
      "id": "cc-tc-001",
      "type": "multiple-choice",
      "question": "A multi-device messaging feed is experiencing clock skew between regions. Which time/ordering strategy is strongest? Recent incident analysis links user-visible regressions to ordering assumptions.",
      "options": [
        "Use causal metadata (vector clocks/causal context) where dependent event order matters.",
        "Use wall-clock ordering as the primary conflict signal, adding logical clocks only if anomalies persist.",
        "Treat broker delivery order as causally sufficient across partitions unless explicit reordering evidence appears.",
        "Use global last-arrival-wins as the default merge policy and add semantic conflict rules only for high-severity entities."
      ],
      "correct": 0,
      "explanation": "Given the observed bottleneck and guardrails, correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A multi-device messaging feed is experiencing clock skew between regions, this option best addresses the stated constraints in Time, Ordering & Causality.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Prefer approaches that directly address failure mode, recovery path, and blast radius. Tie decisions to concrete operational outcomes, not abstract reliability language. Common pitfall: meeting average goals while missing tail-risk.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-002",
      "type": "multiple-choice",
      "question": "A collaborative document editor is experiencing out-of-order event arrival. Which time/ordering strategy is strongest? The team needs a low-blast-radius first mitigation.",
      "options": [
        "Use wall-clock ordering as the primary conflict signal, adding logical clocks only if anomalies persist.",
        "Treat broker delivery order as causally sufficient across partitions unless explicit reordering evidence appears.",
        "Use global last-arrival-wins as the default merge policy and add semantic conflict rules only for high-severity entities.",
        "Separate wall-clock display time from correctness ordering logic using logical clocks."
      ],
      "correct": 3,
      "explanation": "From an incident-first perspective, correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A collaborative document editor is experiencing out-of-order event arrival, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Prefer the approach that keeps ordering/acknowledgment behavior predictable under failure. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. Common pitfall: ordering loss during partition or replay changes.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-003",
      "type": "multiple-choice",
      "question": "An inventory event processor is experiencing causal dependency not preserved. Which time/ordering strategy is strongest? Cross-region skew increased during the latest outage drill.",
      "options": [
        "Treat broker delivery order as causally sufficient across partitions unless explicit reordering evidence appears.",
        "Use global last-arrival-wins as the default merge policy and add semantic conflict rules only for high-severity entities.",
        "Use Lamport/logical sequence for deterministic processing order when real-time order is unreliable.",
        "Use wall-clock ordering as the primary conflict signal, adding logical clocks only if anomalies persist."
      ],
      "correct": 2,
      "explanation": "Under the stated reliability and cost constraints, correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For an inventory event processor is experiencing causal dependency not preserved, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Prefer the approach that keeps ordering/acknowledgment behavior predictable under failure. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. Common pitfall: assuming exactly-once without idempotency.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-004",
      "type": "multiple-choice",
      "question": "A payment reconciliation pipeline is experiencing concurrent writes from multiple clients. Which time/ordering strategy is strongest? Concurrent client updates now occur more frequently.",
      "options": [
        "Use global last-arrival-wins as the default merge policy and add semantic conflict rules only for high-severity entities.",
        "Define merge/conflict policy for concurrent updates and preserve causality where required.",
        "Use wall-clock ordering as the primary conflict signal, adding logical clocks only if anomalies persist.",
        "Treat broker delivery order as causally sufficient across partitions unless explicit reordering evidence appears."
      ],
      "correct": 1,
      "explanation": "Prioritizing blast-radius reduction first, correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A payment reconciliation pipeline is experiencing concurrent writes from multiple clients, this response is the most defensible call for Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Prefer the approach that preserves correctness guarantees for the stated consistency boundary. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-005",
      "type": "multiple-choice",
      "question": "A ride dispatch event stream is experiencing late-arriving updates after retries. Which time/ordering strategy is strongest? Replay traffic after retries is higher than expected.",
      "options": [
        "Treat physical timestamps as hints; validate order with causal/version metadata.",
        "Use wall-clock ordering as the primary conflict signal, adding logical clocks only if anomalies persist.",
        "Treat broker delivery order as causally sufficient across partitions unless explicit reordering evidence appears.",
        "Use global last-arrival-wins as the default merge policy and add semantic conflict rules only for high-severity entities."
      ],
      "correct": 0,
      "explanation": "With latency and correctness objectives explicit, correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A ride dispatch event stream is experiencing late-arriving updates after retries, this option best addresses the stated constraints in Time, Ordering & Causality.",
      "detailedExplanation": "Generalize from ride dispatch event stream is experiencing late-arriving updates after retries to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Reject approaches that ignore delivery semantics or backpressure behavior. A good message-system answer defines guarantees clearly for both producer and consumer paths. Common pitfall: consumer lag growth under burst traffic.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-006",
      "type": "multiple-choice",
      "question": "A support ticket workflow service is experiencing NTP drift under partial network issues. Which time/ordering strategy is strongest? Current logic mixes display time with correctness ordering.",
      "options": [
        "Use wall-clock ordering as the primary conflict signal, adding logical clocks only if anomalies persist.",
        "Treat broker delivery order as causally sufficient across partitions unless explicit reordering evidence appears.",
        "Use global last-arrival-wins as the default merge policy and add semantic conflict rules only for high-severity entities.",
        "Add per-entity monotonic version checks to reject stale reordered writes."
      ],
      "correct": 3,
      "explanation": "Looking at rollback safety and operational load, correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A support ticket workflow service is experiencing NTP drift under partial network issues, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Eliminate approaches that hand-wave conflict resolution or quorum behavior. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-007",
      "type": "multiple-choice",
      "question": "A notification timeline service is experiencing event timestamp collisions. Which time/ordering strategy is strongest? Anomaly alerts spike during failover and backlog recovery.",
      "options": [
        "Treat broker delivery order as causally sufficient across partitions unless explicit reordering evidence appears.",
        "Use global last-arrival-wins as the default merge policy and add semantic conflict rules only for high-severity entities.",
        "Use idempotent replay handling with causal guards for delayed events.",
        "Use wall-clock ordering as the primary conflict signal, adding logical clocks only if anomalies persist."
      ],
      "correct": 2,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A notification timeline service is experiencing event timestamp collisions, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality.",
      "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Prioritize the approach that best protects reliability objectives under stated failure conditions. Tie decisions to concrete operational outcomes, not abstract reliability language. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-008",
      "type": "multiple-choice",
      "question": "An order lifecycle event bus is experiencing reordered queue delivery after failover. Which time/ordering strategy is strongest? The fix must preserve throughput on non-critical streams.",
      "options": [
        "Use global last-arrival-wins as the default merge policy and add semantic conflict rules only for high-severity entities.",
        "Partition ordering-sensitive streams and avoid cross-partition total-order assumptions.",
        "Use wall-clock ordering as the primary conflict signal, adding logical clocks only if anomalies persist.",
        "Treat broker delivery order as causally sufficient across partitions unless explicit reordering evidence appears."
      ],
      "correct": 1,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For an order lifecycle event bus is experiencing reordered queue delivery after failover, this response is the most defensible call for Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Reject approaches that sound good in general but do not reduce concrete reliability risk. Map the approach to measurable reliability impact such as error-budget burn and recovery behavior. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-009",
      "type": "multiple-choice",
      "question": "A social comment thread backend is experiencing duplicate event replay with old timestamps. Which time/ordering strategy is strongest? Causal dependencies are not explicitly encoded today.",
      "options": [
        "Expose uncertainty when causal order cannot be established from available metadata.",
        "Use wall-clock ordering as the primary conflict signal, adding logical clocks only if anomalies persist.",
        "Treat broker delivery order as causally sufficient across partitions unless explicit reordering evidence appears.",
        "Use global last-arrival-wins as the default merge policy and add semantic conflict rules only for high-severity entities."
      ],
      "correct": 0,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A social comment thread backend is experiencing duplicate event replay with old timestamps, this option best addresses the stated constraints in Time, Ordering & Causality.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Prefer the approach that keeps ordering/acknowledgment behavior predictable under failure. A good message-system answer defines guarantees clearly for both producer and consumer paths. Common pitfall: consumer lag growth under burst traffic.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-010",
      "type": "multiple-choice",
      "question": "A feature-flag propagation service is experiencing mixed wall-clock and logical ordering assumptions. Which time/ordering strategy is strongest? Support reports timeline reversals across devices.",
      "options": [
        "Use wall-clock ordering as the primary conflict signal, adding logical clocks only if anomalies persist.",
        "Treat broker delivery order as causally sufficient across partitions unless explicit reordering evidence appears.",
        "Use global last-arrival-wins as the default merge policy and add semantic conflict rules only for high-severity entities.",
        "Instrument skew and reordering metrics; gate critical workflows when ordering confidence drops."
      ],
      "correct": 3,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A feature-flag propagation service is experiencing mixed wall-clock and logical ordering assumptions, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Prefer the approach that preserves correctness guarantees for the stated consistency boundary. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-011",
      "type": "multiple-choice",
      "question": "A profile update event system is experiencing clock skew between regions. Which time/ordering strategy is strongest? The service recently moved to multi-region active-active mode.",
      "options": [
        "Treat broker delivery order as causally sufficient across partitions unless explicit reordering evidence appears.",
        "Use global last-arrival-wins as the default merge policy and add semantic conflict rules only for high-severity entities.",
        "Use causal metadata (vector clocks/causal context) where dependent event order matters.",
        "Use wall-clock ordering as the primary conflict signal, adding logical clocks only if anomalies persist."
      ],
      "correct": 2,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A profile update event system is experiencing clock skew between regions, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Prefer the approach that keeps ordering/acknowledgment behavior predictable under failure. Throughput is only one part; replay behavior and consumer lag handling matter equally. Common pitfall: ordering loss during partition or replay changes.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-012",
      "type": "multiple-choice",
      "question": "A moderation review queue is experiencing out-of-order event arrival. Which time/ordering strategy is strongest? Queue guarantees differ across partitions and brokers.",
      "options": [
        "Use global last-arrival-wins as the default merge policy and add semantic conflict rules only for high-severity entities.",
        "Separate wall-clock display time from correctness ordering logic using logical clocks.",
        "Use wall-clock ordering as the primary conflict signal, adding logical clocks only if anomalies persist.",
        "Treat broker delivery order as causally sufficient across partitions unless explicit reordering evidence appears."
      ],
      "correct": 1,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A moderation review queue is experiencing out-of-order event arrival, this response is the most defensible call for Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Reject approaches that ignore delivery semantics or backpressure behavior. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. Common pitfall: consumer lag growth under burst traffic.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-013",
      "type": "multiple-choice",
      "question": "A chat read-receipt service is experiencing causal dependency not preserved. Which time/ordering strategy is strongest? Schema changes introduced metadata compatibility risk.",
      "options": [
        "Use Lamport/logical sequence for deterministic processing order when real-time order is unreliable.",
        "Use wall-clock ordering as the primary conflict signal, adding logical clocks only if anomalies persist.",
        "Treat broker delivery order as causally sufficient across partitions unless explicit reordering evidence appears.",
        "Use global last-arrival-wins as the default merge policy and add semantic conflict rules only for high-severity entities."
      ],
      "correct": 0,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A chat read-receipt service is experiencing causal dependency not preserved, this option best addresses the stated constraints in Time, Ordering & Causality.",
      "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Discard choices that violate required invariants during concurrent or failed states. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        },
        {
          "title": "Amazon S3 FAQs",
          "url": "https://aws.amazon.com/s3/faqs/"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-014",
      "type": "multiple-choice",
      "question": "An ad campaign state projector is experiencing concurrent writes from multiple clients. Which time/ordering strategy is strongest? Conflict handling policy is currently under-specified.",
      "options": [
        "Use wall-clock ordering as the primary conflict signal, adding logical clocks only if anomalies persist.",
        "Treat broker delivery order as causally sufficient across partitions unless explicit reordering evidence appears.",
        "Use global last-arrival-wins as the default merge policy and add semantic conflict rules only for high-severity entities.",
        "Define merge/conflict policy for concurrent updates and preserve causality where required."
      ],
      "correct": 3,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For an ad campaign state projector is experiencing concurrent writes from multiple clients, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Prefer the approach that preserves correctness guarantees for the stated consistency boundary. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-015",
      "type": "multiple-choice",
      "question": "A shipment tracking event feed is experiencing late-arriving updates after retries. Which time/ordering strategy is strongest? Leadership requested explicit ordering guarantees per workflow.",
      "options": [
        "Treat broker delivery order as causally sufficient across partitions unless explicit reordering evidence appears.",
        "Use global last-arrival-wins as the default merge policy and add semantic conflict rules only for high-severity entities.",
        "Treat physical timestamps as hints; validate order with causal/version metadata.",
        "Use wall-clock ordering as the primary conflict signal, adding logical clocks only if anomalies persist."
      ],
      "correct": 2,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A shipment tracking event feed is experiencing late-arriving updates after retries, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Reject approaches that ignore delivery semantics or backpressure behavior. Throughput is only one part; replay behavior and consumer lag handling matter equally. Common pitfall: assuming exactly-once without idempotency.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-016",
      "type": "multiple-choice",
      "question": "A device sync service is experiencing NTP drift under partial network issues. Which time/ordering strategy is strongest? Strict global order is too expensive for all paths.",
      "options": [
        "Use global last-arrival-wins as the default merge policy and add semantic conflict rules only for high-severity entities.",
        "Add per-entity monotonic version checks to reject stale reordered writes.",
        "Use wall-clock ordering as the primary conflict signal, adding logical clocks only if anomalies persist.",
        "Treat broker delivery order as causally sufficient across partitions unless explicit reordering evidence appears."
      ],
      "correct": 1,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A device sync service is experiencing NTP drift under partial network issues, this response is the most defensible call for Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "Generalize from device sync service is experiencing NTP drift under partial network issues to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Prefer the approach that preserves correctness guarantees for the stated consistency boundary. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-017",
      "type": "multiple-choice",
      "question": "An analytics event enricher is experiencing event timestamp collisions. Which time/ordering strategy is strongest? The path includes both ordered and commutative updates.",
      "options": [
        "Use idempotent replay handling with causal guards for delayed events.",
        "Use wall-clock ordering as the primary conflict signal, adding logical clocks only if anomalies persist.",
        "Treat broker delivery order as causally sufficient across partitions unless explicit reordering evidence appears.",
        "Use global last-arrival-wins as the default merge policy and add semantic conflict rules only for high-severity entities."
      ],
      "correct": 0,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For an analytics event enricher is experiencing event timestamp collisions, this option best addresses the stated constraints in Time, Ordering & Causality.",
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Reject designs that improve throughput while weakening reliability guarantees. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. Common pitfall: ordering loss during partition or replay changes.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-018",
      "type": "multiple-choice",
      "question": "A fraud alert pipeline is experiencing reordered queue delivery after failover. Which time/ordering strategy is strongest? Read-side projections lag behind event ingestion bursts.",
      "options": [
        "Use wall-clock ordering as the primary conflict signal, adding logical clocks only if anomalies persist.",
        "Treat broker delivery order as causally sufficient across partitions unless explicit reordering evidence appears.",
        "Use global last-arrival-wins as the default merge policy and add semantic conflict rules only for high-severity entities.",
        "Partition ordering-sensitive streams and avoid cross-partition total-order assumptions."
      ],
      "correct": 3,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A fraud alert pipeline is experiencing reordered queue delivery after failover, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Reject approaches that sound good in general but do not reduce concrete reliability risk. A strong real-world approach explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-019",
      "type": "multiple-choice",
      "question": "A catalog update fanout service is experiencing duplicate event replay with old timestamps. Which time/ordering strategy is strongest? Team needs clearer causal debugging telemetry.",
      "options": [
        "Treat broker delivery order as causally sufficient across partitions unless explicit reordering evidence appears.",
        "Use global last-arrival-wins as the default merge policy and add semantic conflict rules only for high-severity entities.",
        "Expose uncertainty when causal order cannot be established from available metadata.",
        "Use wall-clock ordering as the primary conflict signal, adding logical clocks only if anomalies persist."
      ],
      "correct": 2,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A catalog update fanout service is experiencing duplicate event replay with old timestamps, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Reject approaches that ignore delivery semantics or backpressure behavior. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. Common pitfall: consumer lag growth under burst traffic.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-020",
      "type": "multiple-choice",
      "question": "A identity claim replication pipeline is experiencing mixed wall-clock and logical ordering assumptions. Which time/ordering strategy is strongest? Recovery workflows require deterministic replay behavior.",
      "options": [
        "Use global last-arrival-wins as the default merge policy and add semantic conflict rules only for high-severity entities.",
        "Instrument skew and reordering metrics; gate critical workflows when ordering confidence drops.",
        "Use wall-clock ordering as the primary conflict signal, adding logical clocks only if anomalies persist.",
        "Treat broker delivery order as causally sufficient across partitions unless explicit reordering evidence appears."
      ],
      "correct": 1,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A identity claim replication pipeline is experiencing mixed wall-clock and logical ordering assumptions, this response is the most defensible call for Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Reject approaches that sound good in general but do not reduce concrete reliability risk. Map the approach to measurable reliability impact such as error-budget burn and recovery behavior. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-021",
      "type": "multiple-choice",
      "question": "A multi-device messaging feed is experiencing clock skew between regions. Which time/ordering strategy is strongest? The incident repeats when delayed events arrive late.",
      "options": [
        "Use causal metadata (vector clocks/causal context) where dependent event order matters.",
        "Use wall-clock ordering as the primary conflict signal, adding logical clocks only if anomalies persist.",
        "Treat broker delivery order as causally sufficient across partitions unless explicit reordering evidence appears.",
        "Use global last-arrival-wins as the default merge policy and add semantic conflict rules only for high-severity entities."
      ],
      "correct": 0,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A multi-device messaging feed is experiencing clock skew between regions, this option best addresses the stated constraints in Time, Ordering & Causality.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Prioritize the approach that best protects reliability objectives under stated failure conditions. A strong real-world approach explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-022",
      "type": "multiple-choice",
      "question": "A collaborative document editor is experiencing out-of-order event arrival. Which time/ordering strategy is strongest? System behavior differs by tenant under heavy concurrency.",
      "options": [
        "Use wall-clock ordering as the primary conflict signal, adding logical clocks only if anomalies persist.",
        "Treat broker delivery order as causally sufficient across partitions unless explicit reordering evidence appears.",
        "Use global last-arrival-wins as the default merge policy and add semantic conflict rules only for high-severity entities.",
        "Separate wall-clock display time from correctness ordering logic using logical clocks."
      ],
      "correct": 3,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A collaborative document editor is experiencing out-of-order event arrival, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Reject designs that improve throughput while weakening reliability guarantees. A good message-system answer defines guarantees clearly for both producer and consumer paths. Common pitfall: consumer lag growth under burst traffic.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-023",
      "type": "multiple-choice",
      "question": "An inventory event processor is experiencing causal dependency not preserved. Which time/ordering strategy is strongest? Clock synchronization confidence is temporarily degraded.",
      "options": [
        "Treat broker delivery order as causally sufficient across partitions unless explicit reordering evidence appears.",
        "Use global last-arrival-wins as the default merge policy and add semantic conflict rules only for high-severity entities.",
        "Use Lamport/logical sequence for deterministic processing order when real-time order is unreliable.",
        "Use wall-clock ordering as the primary conflict signal, adding logical clocks only if anomalies persist."
      ],
      "correct": 2,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For an inventory event processor is experiencing causal dependency not preserved, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Reject designs that improve throughput while weakening reliability guarantees. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. Common pitfall: ordering loss during partition or replay changes.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-024",
      "type": "multiple-choice",
      "question": "A payment reconciliation pipeline is experiencing concurrent writes from multiple clients. Which time/ordering strategy is strongest? Some workflows can tolerate eventual ordering if explicit.",
      "options": [
        "Use global last-arrival-wins as the default merge policy and add semantic conflict rules only for high-severity entities.",
        "Define merge/conflict policy for concurrent updates and preserve causality where required.",
        "Use wall-clock ordering as the primary conflict signal, adding logical clocks only if anomalies persist.",
        "Treat broker delivery order as causally sufficient across partitions unless explicit reordering evidence appears."
      ],
      "correct": 1,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A payment reconciliation pipeline is experiencing concurrent writes from multiple clients, this response is the most defensible call for Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Eliminate approaches that hand-wave conflict resolution or quorum behavior. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-025",
      "type": "multiple-choice",
      "question": "A ride dispatch event stream is experiencing late-arriving updates after retries. Which time/ordering strategy is strongest? Critical workflows require clear happened-before semantics.",
      "options": [
        "Treat physical timestamps as hints; validate order with causal/version metadata.",
        "Use wall-clock ordering as the primary conflict signal, adding logical clocks only if anomalies persist.",
        "Treat broker delivery order as causally sufficient across partitions unless explicit reordering evidence appears.",
        "Use global last-arrival-wins as the default merge policy and add semantic conflict rules only for high-severity entities."
      ],
      "correct": 0,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A ride dispatch event stream is experiencing late-arriving updates after retries, this option best addresses the stated constraints in Time, Ordering & Causality.",
      "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Reject designs that improve throughput while weakening reliability guarantees. A good message-system answer defines guarantees clearly for both producer and consumer paths. Common pitfall: ordering loss during partition or replay changes.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-026",
      "type": "multiple-choice",
      "question": "A support ticket workflow service is experiencing NTP drift under partial network issues. Which time/ordering strategy is strongest? Operational runbooks currently ignore causal metadata health.",
      "options": [
        "Use wall-clock ordering as the primary conflict signal, adding logical clocks only if anomalies persist.",
        "Treat broker delivery order as causally sufficient across partitions unless explicit reordering evidence appears.",
        "Use global last-arrival-wins as the default merge policy and add semantic conflict rules only for high-severity entities.",
        "Add per-entity monotonic version checks to reject stale reordered writes."
      ],
      "correct": 3,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A support ticket workflow service is experiencing NTP drift under partial network issues, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Prefer the approach that preserves correctness guarantees for the stated consistency boundary. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-027",
      "type": "multiple-choice",
      "question": "A notification timeline service is experiencing event timestamp collisions. Which time/ordering strategy is strongest? Downstream consumers assume stronger ordering than provided.",
      "options": [
        "Treat broker delivery order as causally sufficient across partitions unless explicit reordering evidence appears.",
        "Use global last-arrival-wins as the default merge policy and add semantic conflict rules only for high-severity entities.",
        "Use idempotent replay handling with causal guards for delayed events.",
        "Use wall-clock ordering as the primary conflict signal, adding logical clocks only if anomalies persist."
      ],
      "correct": 2,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A notification timeline service is experiencing event timestamp collisions, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality.",
      "detailedExplanation": "Generalize from notification timeline service is experiencing event timestamp collisions to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Reject approaches that ignore delivery semantics or backpressure behavior. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. Common pitfall: consumer lag growth under burst traffic.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-028",
      "type": "multiple-choice",
      "question": "An order lifecycle event bus is experiencing reordered queue delivery after failover. Which time/ordering strategy is strongest? Backpressure caused reorder spikes in one partition group.",
      "options": [
        "Use global last-arrival-wins as the default merge policy and add semantic conflict rules only for high-severity entities.",
        "Partition ordering-sensitive streams and avoid cross-partition total-order assumptions.",
        "Use wall-clock ordering as the primary conflict signal, adding logical clocks only if anomalies persist.",
        "Treat broker delivery order as causally sufficient across partitions unless explicit reordering evidence appears."
      ],
      "correct": 1,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For an order lifecycle event bus is experiencing reordered queue delivery after failover, this response is the most defensible call for Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Prioritize the approach that best protects reliability objectives under stated failure conditions. Map the approach to measurable reliability impact such as error-budget burn and recovery behavior. Common pitfall: meeting average goals while missing tail-risk.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-029",
      "type": "multiple-choice",
      "question": "A social comment thread backend is experiencing duplicate event replay with old timestamps. Which time/ordering strategy is strongest? Product requirements now include monotonic timeline UX.",
      "options": [
        "Expose uncertainty when causal order cannot be established from available metadata.",
        "Use wall-clock ordering as the primary conflict signal, adding logical clocks only if anomalies persist.",
        "Treat broker delivery order as causally sufficient across partitions unless explicit reordering evidence appears.",
        "Use global last-arrival-wins as the default merge policy and add semantic conflict rules only for high-severity entities."
      ],
      "correct": 0,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A social comment thread backend is experiencing duplicate event replay with old timestamps, this option best addresses the stated constraints in Time, Ordering & Causality.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Reject designs that improve throughput while weakening reliability guarantees. Throughput is only one part; replay behavior and consumer lag handling matter equally. Common pitfall: consumer lag growth under burst traffic.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-030",
      "type": "multiple-choice",
      "question": "A feature-flag propagation service is experiencing mixed wall-clock and logical ordering assumptions. Which time/ordering strategy is strongest? Engineering wants endpoint-level ordering contracts.",
      "options": [
        "Use wall-clock ordering as the primary conflict signal, adding logical clocks only if anomalies persist.",
        "Treat broker delivery order as causally sufficient across partitions unless explicit reordering evidence appears.",
        "Use global last-arrival-wins as the default merge policy and add semantic conflict rules only for high-severity entities.",
        "Instrument skew and reordering metrics; gate critical workflows when ordering confidence drops."
      ],
      "correct": 3,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A feature-flag propagation service is experiencing mixed wall-clock and logical ordering assumptions, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "Generalize from feature-flag propagation service is experiencing mixed wall-clock and logical ordering to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Eliminate designs that create ambiguous API semantics or brittle versioning paths. Prioritize explicit semantics and upgrade safety, not just short-term convenience. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-031",
      "type": "multiple-choice",
      "question": "A profile update event system is experiencing clock skew between regions. Which time/ordering strategy is strongest? Retry dedupe currently lacks version monotonic guards.",
      "options": [
        "Treat broker delivery order as causally sufficient across partitions unless explicit reordering evidence appears.",
        "Use global last-arrival-wins as the default merge policy and add semantic conflict rules only for high-severity entities.",
        "Use causal metadata (vector clocks/causal context) where dependent event order matters.",
        "Use wall-clock ordering as the primary conflict signal, adding logical clocks only if anomalies persist."
      ],
      "correct": 2,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A profile update event system is experiencing clock skew between regions, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality.",
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Reject approaches that sound good in general but do not reduce concrete reliability risk. A strong real-world approach explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-032",
      "type": "multiple-choice",
      "question": "A moderation review queue is experiencing out-of-order event arrival. Which time/ordering strategy is strongest? A canary rollout is required before broad policy changes.",
      "options": [
        "Use global last-arrival-wins as the default merge policy and add semantic conflict rules only for high-severity entities.",
        "Separate wall-clock display time from correctness ordering logic using logical clocks.",
        "Use wall-clock ordering as the primary conflict signal, adding logical clocks only if anomalies persist.",
        "Treat broker delivery order as causally sufficient across partitions unless explicit reordering evidence appears."
      ],
      "correct": 1,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A moderation review queue is experiencing out-of-order event arrival, this response is the most defensible call for Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Reject approaches that ignore delivery semantics or backpressure behavior. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. Common pitfall: consumer lag growth under burst traffic.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-033",
      "type": "multiple-choice",
      "question": "A chat read-receipt service is experiencing causal dependency not preserved. Which time/ordering strategy is strongest? The team must minimize additional coordination latency.",
      "options": [
        "Use Lamport/logical sequence for deterministic processing order when real-time order is unreliable.",
        "Use wall-clock ordering as the primary conflict signal, adding logical clocks only if anomalies persist.",
        "Treat broker delivery order as causally sufficient across partitions unless explicit reordering evidence appears.",
        "Use global last-arrival-wins as the default merge policy and add semantic conflict rules only for high-severity entities."
      ],
      "correct": 0,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A chat read-receipt service is experiencing causal dependency not preserved, this option best addresses the stated constraints in Time, Ordering & Causality.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Discard choices that violate required invariants during concurrent or failed states. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-034",
      "type": "multiple-choice",
      "question": "An ad campaign state projector is experiencing concurrent writes from multiple clients. Which time/ordering strategy is strongest? Audit paths need reproducible processing order evidence.",
      "options": [
        "Use wall-clock ordering as the primary conflict signal, adding logical clocks only if anomalies persist.",
        "Treat broker delivery order as causally sufficient across partitions unless explicit reordering evidence appears.",
        "Use global last-arrival-wins as the default merge policy and add semantic conflict rules only for high-severity entities.",
        "Define merge/conflict policy for concurrent updates and preserve causality where required."
      ],
      "correct": 3,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For an ad campaign state projector is experiencing concurrent writes from multiple clients, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Discard choices that violate required invariants during concurrent or failed states. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-035",
      "type": "multiple-choice",
      "question": "A shipment tracking event feed is experiencing late-arriving updates after retries. Which time/ordering strategy is strongest? Post-incident prevention is required with measurable SLOs.",
      "options": [
        "Treat broker delivery order as causally sufficient across partitions unless explicit reordering evidence appears.",
        "Use global last-arrival-wins as the default merge policy and add semantic conflict rules only for high-severity entities.",
        "Treat physical timestamps as hints; validate order with causal/version metadata.",
        "Use wall-clock ordering as the primary conflict signal, adding logical clocks only if anomalies persist."
      ],
      "correct": 2,
      "explanation": "Correctness should rely on causal/logical ordering signals, with physical clocks treated as imperfect metadata. For A shipment tracking event feed is experiencing late-arriving updates after retries, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality.",
      "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Prefer approaches that directly address failure mode, recovery path, and blast radius. Map the approach to measurable reliability impact such as error-budget burn and recovery behavior. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-036",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: payment reconciliation pipeline reports failures related to causal dependency not preserved. What is the primary diagnosis?",
          "options": [
            "Ordering bugs in payment reconciliation pipeline indicate mismatch between causal requirements and current timestamp/queue assumptions around causal dependency not preserved.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths."
          ],
          "correct": 0,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For payment reconciliation pipeline reports failures related to causal dependency not preserved, this response is the most defensible call for Time, Ordering & Causality.",
          "detailedExplanation": "Generalize from scenario: payment reconciliation pipeline reports failures related to causal dependency to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. A strong real-world approach explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: assuming recovery speed without operational proof."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while preserving low-latency reads?",
          "options": [
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Treat physical timestamps as hints; validate order with causal/version metadata."
          ],
          "correct": 3,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision while preserving low-latency reads, this option best addresses the stated constraints in Time, Ordering & Causality.",
          "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-037",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: ride dispatch event stream reports failures related to concurrent writes from multiple clients. What is the primary diagnosis?",
          "options": [
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in ride dispatch event stream indicate mismatch between causal requirements and current timestamp/queue assumptions around concurrent writes from multiple clients."
          ],
          "correct": 3,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For ride dispatch event stream reports failures related to concurrent writes from multiple clients, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Do not reset assumptions between stages; carry forward prior constraints directly. Map the approach to measurable reliability impact such as error-budget burn and recovery behavior. Common pitfall: assuming recovery speed without operational proof."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under regional clock skew?",
          "options": [
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Add per-entity monotonic version checks to reject stale reordered writes.",
            "Force one global synchronized timestamp source for every service write path."
          ],
          "correct": 2,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision under regional clock skew, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-038",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: support ticket workflow service reports failures related to late-arriving updates after retries. What is the primary diagnosis?",
          "options": [
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in support ticket workflow service indicate mismatch between causal requirements and current timestamp/queue assumptions around late-arriving updates after retries.",
            "Physical clocks are always sufficient for strict correctness ordering."
          ],
          "correct": 2,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For support ticket workflow service reports failures related to late-arriving updates after retries, this response is the most defensible call for Time, Ordering & Causality.",
          "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Tie decisions to concrete operational outcomes, not abstract reliability language. Common pitfall: retry storms during partial failure."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change during replay/retry storms?",
          "options": [
            "Avoid metadata changes and accept occasional causal violations.",
            "Use idempotent replay handling with causal guards for delayed events.",
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance."
          ],
          "correct": 1,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision during replay/retry storms, this option best addresses the stated constraints in Time, Ordering & Causality.",
          "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Do not reset assumptions between stages; carry forward prior constraints directly. Tie decisions to concrete operational outcomes, not abstract reliability language. Common pitfall: meeting average goals while missing tail-risk."
        }
      ],
      "detailedExplanation": "Generalize from time, Ordering & Causality to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-039",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: notification timeline service reports failures related to NTP drift under partial network issues. What is the primary diagnosis?",
          "options": [
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in notification timeline service indicate mismatch between causal requirements and current timestamp/queue assumptions around NTP drift under partial network issues.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled."
          ],
          "correct": 1,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For notification timeline service reports failures related to NTP drift under partial network issues, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. A strong real-world approach explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: meeting average goals while missing tail-risk."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change without forcing global total order?",
          "options": [
            "Partition ordering-sensitive streams and avoid cross-partition total-order assumptions.",
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations."
          ],
          "correct": 0,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision without forcing global total order, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Solve this as chained reasoning where stage two must respect stage one assumptions. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-040",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: order lifecycle event bus reports failures related to event timestamp collisions. What is the primary diagnosis?",
          "options": [
            "Ordering bugs in order lifecycle event bus indicate mismatch between causal requirements and current timestamp/queue assumptions around event timestamp collisions.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths."
          ],
          "correct": 0,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For order lifecycle event bus reports failures related to event timestamp collisions, this response is the most defensible call for Time, Ordering & Causality.",
          "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Solve this as chained reasoning where stage two must respect stage one assumptions. Tie decisions to concrete operational outcomes, not abstract reliability language. Common pitfall: meeting average goals while missing tail-risk."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with cross-device concurrency?",
          "options": [
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Expose uncertainty when causal order cannot be established from available metadata."
          ],
          "correct": 3,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision with cross-device concurrency, this option best addresses the stated constraints in Time, Ordering & Causality.",
          "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-041",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: social comment thread backend reports failures related to reordered queue delivery after failover. What is the primary diagnosis?",
          "options": [
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in social comment thread backend indicate mismatch between causal requirements and current timestamp/queue assumptions around reordered queue delivery after failover."
          ],
          "correct": 3,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For social comment thread backend reports failures related to reordered queue delivery after failover, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Solve this as chained reasoning where stage two must respect stage one assumptions. Tie decisions to concrete operational outcomes, not abstract reliability language. Common pitfall: retry storms during partial failure."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under partitioned delivery paths?",
          "options": [
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Instrument skew and reordering metrics; gate critical workflows when ordering confidence drops.",
            "Force one global synchronized timestamp source for every service write path."
          ],
          "correct": 2,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision under partitioned delivery paths, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "Generalize from time, Ordering & Causality to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-042",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: feature-flag propagation service reports failures related to duplicate event replay with old timestamps. What is the primary diagnosis?",
          "options": [
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in feature-flag propagation service indicate mismatch between causal requirements and current timestamp/queue assumptions around duplicate event replay with old timestamps.",
            "Physical clocks are always sufficient for strict correctness ordering."
          ],
          "correct": 2,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For feature-flag propagation service reports failures related to duplicate event replay with old timestamps, this response is the most defensible call for Time, Ordering & Causality.",
          "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Tie decisions to concrete operational outcomes, not abstract reliability language. Common pitfall: meeting average goals while missing tail-risk."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while keeping idempotent handlers simple?",
          "options": [
            "Avoid metadata changes and accept occasional causal violations.",
            "Use causal metadata (vector clocks/causal context) where dependent event order matters.",
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance."
          ],
          "correct": 1,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision while keeping idempotent handlers simple, this option best addresses the stated constraints in Time, Ordering & Causality.",
          "detailedExplanation": "Generalize from after confirming diagnosis, what is the strongest next change while keeping idempotent to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Solve this as chained reasoning where stage two must respect stage one assumptions. Interface decisions should be justified by contract stability and client impact over time. Common pitfall: interface design coupled too tightly to internal implementation."
        }
      ],
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-043",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: profile update event system reports failures related to mixed wall-clock and logical ordering assumptions. What is the primary diagnosis?",
          "options": [
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in profile update event system indicate mismatch between causal requirements and current timestamp/queue assumptions around mixed wall-clock and logical ordering assumptions.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled."
          ],
          "correct": 1,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For profile update event system reports failures related to mixed wall-clock and logical ordering assumptions, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Do not reset assumptions between stages; carry forward prior constraints directly. A strong real-world approach explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: retry storms during partial failure."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change during failover recovery?",
          "options": [
            "Separate wall-clock display time from correctness ordering logic using logical clocks.",
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations."
          ],
          "correct": 0,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision during failover recovery, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Tie decisions to concrete operational outcomes, not abstract reliability language. Common pitfall: meeting average goals while missing tail-risk."
        }
      ],
      "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-044",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: moderation review queue reports failures related to clock skew between regions. What is the primary diagnosis?",
          "options": [
            "Ordering bugs in moderation review queue indicate mismatch between causal requirements and current timestamp/queue assumptions around clock skew between regions.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths."
          ],
          "correct": 0,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For moderation review queue reports failures related to clock skew between regions, this response is the most defensible call for Time, Ordering & Causality.",
          "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Map the approach to measurable reliability impact such as error-budget burn and recovery behavior. Common pitfall: retry storms during partial failure."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with mixed ordered/unordered streams?",
          "options": [
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Use Lamport/logical sequence for deterministic processing order when real-time order is unreliable."
          ],
          "correct": 3,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision with mixed ordered/unordered streams, this option best addresses the stated constraints in Time, Ordering & Causality.",
          "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Solve this as chained reasoning where stage two must respect stage one assumptions. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-045",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: chat read-receipt service reports failures related to out-of-order event arrival. What is the primary diagnosis?",
          "options": [
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in chat read-receipt service indicate mismatch between causal requirements and current timestamp/queue assumptions around out-of-order event arrival."
          ],
          "correct": 3,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For chat read-receipt service reports failures related to out-of-order event arrival, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Do not reset assumptions between stages; carry forward prior constraints directly. Map the approach to measurable reliability impact such as error-budget burn and recovery behavior. Common pitfall: meeting average goals while missing tail-risk."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change before broad rollout?",
          "options": [
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Define merge/conflict policy for concurrent updates and preserve causality where required.",
            "Force one global synchronized timestamp source for every service write path."
          ],
          "correct": 2,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision before broad rollout, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-046",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: ad campaign state projector reports failures related to causal dependency not preserved. What is the primary diagnosis?",
          "options": [
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in ad campaign state projector indicate mismatch between causal requirements and current timestamp/queue assumptions around causal dependency not preserved.",
            "Physical clocks are always sufficient for strict correctness ordering."
          ],
          "correct": 2,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For ad campaign state projector reports failures related to causal dependency not preserved, this response is the most defensible call for Time, Ordering & Causality.",
          "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Solve this as chained reasoning where stage two must respect stage one assumptions. Map the approach to measurable reliability impact such as error-budget burn and recovery behavior. Common pitfall: assuming recovery speed without operational proof."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while minimizing user-visible regressions?",
          "options": [
            "Avoid metadata changes and accept occasional causal violations.",
            "Treat physical timestamps as hints; validate order with causal/version metadata.",
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance."
          ],
          "correct": 1,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision while minimizing user-visible regressions, this option best addresses the stated constraints in Time, Ordering & Causality.",
          "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-047",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: shipment tracking event feed reports failures related to concurrent writes from multiple clients. What is the primary diagnosis?",
          "options": [
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in shipment tracking event feed indicate mismatch between causal requirements and current timestamp/queue assumptions around concurrent writes from multiple clients.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled."
          ],
          "correct": 1,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For shipment tracking event feed reports failures related to concurrent writes from multiple clients, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Generalize from scenario: shipment tracking event feed reports failures related to concurrent writes to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Tie decisions to concrete operational outcomes, not abstract reliability language. Common pitfall: retry storms during partial failure."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under sustained traffic bursts?",
          "options": [
            "Add per-entity monotonic version checks to reject stale reordered writes.",
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations."
          ],
          "correct": 0,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision under sustained traffic bursts, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-048",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: device sync service reports failures related to late-arriving updates after retries. What is the primary diagnosis?",
          "options": [
            "Ordering bugs in device sync service indicate mismatch between causal requirements and current timestamp/queue assumptions around late-arriving updates after retries.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths."
          ],
          "correct": 0,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For device sync service reports failures related to late-arriving updates after retries, this response is the most defensible call for Time, Ordering & Causality.",
          "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Tie decisions to concrete operational outcomes, not abstract reliability language. Common pitfall: assuming recovery speed without operational proof."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with constrained control-plane confidence?",
          "options": [
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Use idempotent replay handling with causal guards for delayed events."
          ],
          "correct": 3,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision with constrained control-plane confidence, this option best addresses the stated constraints in Time, Ordering & Causality.",
          "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-049",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: analytics event enricher reports failures related to NTP drift under partial network issues. What is the primary diagnosis?",
          "options": [
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in analytics event enricher indicate mismatch between causal requirements and current timestamp/queue assumptions around NTP drift under partial network issues."
          ],
          "correct": 3,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For analytics event enricher reports failures related to NTP drift under partial network issues, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Map the approach to measurable reliability impact such as error-budget burn and recovery behavior. Common pitfall: retry storms during partial failure."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while protecting invariant checks?",
          "options": [
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Partition ordering-sensitive streams and avoid cross-partition total-order assumptions.",
            "Force one global synchronized timestamp source for every service write path."
          ],
          "correct": 2,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision while protecting invariant checks, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "Generalize from time, Ordering & Causality to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-050",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: fraud alert pipeline reports failures related to event timestamp collisions. What is the primary diagnosis?",
          "options": [
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in fraud alert pipeline indicate mismatch between causal requirements and current timestamp/queue assumptions around event timestamp collisions.",
            "Physical clocks are always sufficient for strict correctness ordering."
          ],
          "correct": 2,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For fraud alert pipeline reports failures related to event timestamp collisions, this response is the most defensible call for Time, Ordering & Causality.",
          "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Solve this as chained reasoning where stage two must respect stage one assumptions. Map the approach to measurable reliability impact such as error-budget burn and recovery behavior. Common pitfall: meeting average goals while missing tail-risk."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change during metadata format migration?",
          "options": [
            "Avoid metadata changes and accept occasional causal violations.",
            "Expose uncertainty when causal order cannot be established from available metadata.",
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance."
          ],
          "correct": 1,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision during metadata format migration, this option best addresses the stated constraints in Time, Ordering & Causality.",
          "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Solve this as chained reasoning where stage two must respect stage one assumptions. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-051",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: catalog update fanout service reports failures related to reordered queue delivery after failover. What is the primary diagnosis?",
          "options": [
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in catalog update fanout service indicate mismatch between causal requirements and current timestamp/queue assumptions around reordered queue delivery after failover.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled."
          ],
          "correct": 1,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For catalog update fanout service reports failures related to reordered queue delivery after failover, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Solve this as chained reasoning where stage two must respect stage one assumptions. A strong real-world approach explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: assuming recovery speed without operational proof."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under partial message loss?",
          "options": [
            "Instrument skew and reordering metrics; gate critical workflows when ordering confidence drops.",
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations."
          ],
          "correct": 0,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision under partial message loss, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Generalize from after confirming diagnosis, what is the strongest next change under partial message loss to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-052",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: identity claim replication pipeline reports failures related to duplicate event replay with old timestamps. What is the primary diagnosis?",
          "options": [
            "Ordering bugs in identity claim replication pipeline indicate mismatch between causal requirements and current timestamp/queue assumptions around duplicate event replay with old timestamps.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths."
          ],
          "correct": 0,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For identity claim replication pipeline reports failures related to duplicate event replay with old timestamps, this response is the most defensible call for Time, Ordering & Causality.",
          "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Solve this as chained reasoning where stage two must respect stage one assumptions. A strong real-world approach explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: meeting average goals while missing tail-risk."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while preserving throughput targets?",
          "options": [
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Use causal metadata (vector clocks/causal context) where dependent event order matters."
          ],
          "correct": 3,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision while preserving throughput targets, this option best addresses the stated constraints in Time, Ordering & Causality.",
          "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "Generalize from time, Ordering & Causality to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-053",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: multi-device messaging feed reports failures related to mixed wall-clock and logical ordering assumptions. What is the primary diagnosis?",
          "options": [
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in multi-device messaging feed indicate mismatch between causal requirements and current timestamp/queue assumptions around mixed wall-clock and logical ordering assumptions."
          ],
          "correct": 3,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For multi-device messaging feed reports failures related to mixed wall-clock and logical ordering assumptions, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Do not reset assumptions between stages; carry forward prior constraints directly. Tie decisions to concrete operational outcomes, not abstract reliability language. Common pitfall: assuming recovery speed without operational proof."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with clear degraded semantics?",
          "options": [
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Separate wall-clock display time from correctness ordering logic using logical clocks.",
            "Force one global synchronized timestamp source for every service write path."
          ],
          "correct": 2,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision with clear degraded semantics, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-054",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: collaborative document editor reports failures related to clock skew between regions. What is the primary diagnosis?",
          "options": [
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in collaborative document editor indicate mismatch between causal requirements and current timestamp/queue assumptions around clock skew between regions.",
            "Physical clocks are always sufficient for strict correctness ordering."
          ],
          "correct": 2,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For collaborative document editor reports failures related to clock skew between regions, this response is the most defensible call for Time, Ordering & Causality.",
          "detailedExplanation": "Generalize from scenario: collaborative document editor reports failures related to clock skew between to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Tie decisions to concrete operational outcomes, not abstract reliability language. Common pitfall: meeting average goals while missing tail-risk."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change during dependency brownouts?",
          "options": [
            "Avoid metadata changes and accept occasional causal violations.",
            "Use Lamport/logical sequence for deterministic processing order when real-time order is unreliable.",
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance."
          ],
          "correct": 1,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision during dependency brownouts, this option best addresses the stated constraints in Time, Ordering & Causality.",
          "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Do not reset assumptions between stages; carry forward prior constraints directly. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-055",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: inventory event processor reports failures related to out-of-order event arrival. What is the primary diagnosis?",
          "options": [
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in inventory event processor indicate mismatch between causal requirements and current timestamp/queue assumptions around out-of-order event arrival.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled."
          ],
          "correct": 1,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For inventory event processor reports failures related to out-of-order event arrival, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Map the approach to measurable reliability impact such as error-budget burn and recovery behavior. Common pitfall: meeting average goals while missing tail-risk."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with strict audit traceability?",
          "options": [
            "Define merge/conflict policy for concurrent updates and preserve causality where required.",
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations."
          ],
          "correct": 0,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision with strict audit traceability, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-056",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: payment reconciliation pipeline reports failures related to causal dependency not preserved. What is the primary diagnosis?",
          "options": [
            "Ordering bugs in payment reconciliation pipeline indicate mismatch between causal requirements and current timestamp/queue assumptions around causal dependency not preserved.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths."
          ],
          "correct": 0,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For payment reconciliation pipeline reports failures related to causal dependency not preserved, this response is the most defensible call for Time, Ordering & Causality.",
          "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Solve this as chained reasoning where stage two must respect stage one assumptions. Map the approach to measurable reliability impact such as error-budget burn and recovery behavior. Common pitfall: retry storms during partial failure."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change under delayed regional replication?",
          "options": [
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Treat physical timestamps as hints; validate order with causal/version metadata."
          ],
          "correct": 3,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision under delayed regional replication, this option best addresses the stated constraints in Time, Ordering & Causality.",
          "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-057",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: ride dispatch event stream reports failures related to concurrent writes from multiple clients. What is the primary diagnosis?",
          "options": [
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in ride dispatch event stream indicate mismatch between causal requirements and current timestamp/queue assumptions around concurrent writes from multiple clients."
          ],
          "correct": 3,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For ride dispatch event stream reports failures related to concurrent writes from multiple clients, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Tie decisions to concrete operational outcomes, not abstract reliability language. Common pitfall: meeting average goals while missing tail-risk."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change while limiting merge complexity?",
          "options": [
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Add per-entity monotonic version checks to reject stale reordered writes.",
            "Force one global synchronized timestamp source for every service write path."
          ],
          "correct": 2,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision while limiting merge complexity, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Solve this as chained reasoning where stage two must respect stage one assumptions. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Solve this as chained reasoning where stage two must respect stage one assumptions. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-058",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: support ticket workflow service reports failures related to late-arriving updates after retries. What is the primary diagnosis?",
          "options": [
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in support ticket workflow service indicate mismatch between causal requirements and current timestamp/queue assumptions around late-arriving updates after retries.",
            "Physical clocks are always sufficient for strict correctness ordering."
          ],
          "correct": 2,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For support ticket workflow service reports failures related to late-arriving updates after retries, this response is the most defensible call for Time, Ordering & Causality.",
          "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Solve this as chained reasoning where stage two must respect stage one assumptions. A strong real-world approach explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: assuming recovery speed without operational proof."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with existing schema compatibility constraints?",
          "options": [
            "Avoid metadata changes and accept occasional causal violations.",
            "Use idempotent replay handling with causal guards for delayed events.",
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance."
          ],
          "correct": 1,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision with existing schema compatibility constraints, this option best addresses the stated constraints in Time, Ordering & Causality.",
          "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: ignoring conflict resolution behavior."
        }
      ],
      "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Solve this as chained reasoning where stage two must respect stage one assumptions. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-059",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: notification timeline service reports failures related to NTP drift under partial network issues. What is the primary diagnosis?",
          "options": [
            "Event-time and processing-time can be treated as identical in distributed paths.",
            "Ordering bugs in notification timeline service indicate mismatch between causal requirements and current timestamp/queue assumptions around NTP drift under partial network issues.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled."
          ],
          "correct": 1,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For notification timeline service reports failures related to NTP drift under partial network issues, this choice most directly resolves the stated failure mode in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Tie decisions to concrete operational outcomes, not abstract reliability language. Common pitfall: meeting average goals while missing tail-risk."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change during backlog drain?",
          "options": [
            "Partition ordering-sensitive streams and avoid cross-partition total-order assumptions.",
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations."
          ],
          "correct": 0,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision during backlog drain, this mitigation aligns best with the scenario constraints in Time, Ordering & Causality. Keep mitigation tied to the stated constraints.",
          "detailedExplanation": "Generalize from after confirming diagnosis, what is the strongest next change during backlog drain to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Do not reset assumptions between stages; carry forward prior constraints directly. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants."
        }
      ],
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-060",
      "type": "two-stage",
      "stages": [
        {
          "question": "Scenario: order lifecycle event bus reports failures related to event timestamp collisions. What is the primary diagnosis?",
          "options": [
            "Ordering bugs in order lifecycle event bus indicate mismatch between causal requirements and current timestamp/queue assumptions around event timestamp collisions.",
            "Physical clocks are always sufficient for strict correctness ordering.",
            "Concurrent write conflicts disappear if retries are enabled.",
            "Event-time and processing-time can be treated as identical in distributed paths."
          ],
          "correct": 0,
          "explanation": "The incident points to incorrect ordering assumptions: causal dependencies are not represented/enforced correctly. For order lifecycle event bus reports failures related to event timestamp collisions, this response is the most defensible call for Time, Ordering & Causality.",
          "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Solve this as chained reasoning where stage two must respect stage one assumptions. A strong real-world approach explains how failure mode, mitigation speed, and blast radius interact. Common pitfall: retry storms during partial failure."
        },
        {
          "question": "After confirming diagnosis, what is the strongest next change with explicit anomaly alerts enabled?",
          "options": [
            "Force one global synchronized timestamp source for every service write path.",
            "Drop delayed events silently to preserve local order appearance.",
            "Avoid metadata changes and accept occasional causal violations.",
            "Expose uncertainty when causal order cannot be established from available metadata."
          ],
          "correct": 3,
          "explanation": "Adopt explicit causal/logical ordering controls before tuning secondary concerns. For the follow-up change decision with explicit anomaly alerts enabled, this option best addresses the stated constraints in Time, Ordering & Causality.",
          "detailedExplanation": "Generalize from after confirming diagnosis, what is the strongest next change with explicit anomaly to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Do not reset assumptions between stages; carry forward prior constraints directly. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: misreading quorum behavior during failures."
        }
      ],
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Keep stage continuity explicit: the first-step outcome is a hard input to the next step. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-061",
      "type": "multi-select",
      "question": "Why are wall clocks alone insufficient for distributed ordering? (Select all that apply)",
      "options": [
        "Clock skew/drift exists",
        "Events can be delayed/reordered in transit",
        "NTP guarantees perfect global ordering",
        "Concurrent writes may share similar timestamps"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Physical clocks are imperfect and network effects break naive timestamp ordering assumptions.",
      "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Anchor decisions in explicit constraints, invariants, and observable failure signals rather than intuition. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-062",
      "type": "multi-select",
      "question": "Vector clocks are most useful for which? (Select all that apply)",
      "options": [
        "Detecting concurrent updates",
        "Capturing causal relationships",
        "Providing exact real-world event time",
        "Supporting conflict-aware merges"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Vector clocks model causality/concurrency, not real-time precision.",
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Validate each proposed control independently and avoid partially true claims that fail under realistic load. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "Little's law",
          "url": "https://en.wikipedia.org/wiki/Little%27s_law"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-063",
      "type": "multi-select",
      "question": "Lamport clocks help with which tasks? (Select all that apply)",
      "options": [
        "Deriving a consistent happened-before-compatible order",
        "Breaking ties for deterministic processing",
        "Detecting exact concurrency in all cases",
        "Reducing dependence on wall-clock synchronization"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Lamport clocks support ordering but cannot fully distinguish all concurrent cases.",
      "detailedExplanation": "Generalize from lamport clocks help with which tasks? (Select all that apply) to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Evaluate each candidate approach independently under the same constraints. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-064",
      "type": "multi-select",
      "question": "Good practices for event reordering tolerance include which? (Select all that apply)",
      "options": [
        "Idempotent handlers",
        "Per-entity version checks",
        "Assuming strict in-order delivery globally",
        "Late-event handling policy"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Robust systems assume delays/reordering and enforce correctness via metadata/policies.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Validate each proposed control independently and avoid partially true claims that fail under realistic load. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. Common pitfall: ordering loss during partition or replay changes.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-065",
      "type": "multi-select",
      "question": "Causal consistency is especially important when which apply? (Select all that apply)",
      "options": [
        "Reply should not appear before original message",
        "Dependent workflow steps must preserve order",
        "Independent counters only",
        "User sees own actions reflected coherently"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Causal guarantees matter when semantic dependencies exist between operations.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Evaluate each candidate approach independently under the same constraints. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-066",
      "type": "multi-select",
      "question": "Which signs indicate ordering assumptions are broken? (Select all that apply)",
      "options": [
        "State appears to revert after newer update",
        "Duplicate replay overwrites newer data",
        "Stable monotonic version progression",
        "Cross-device conflicting timelines"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Reversions and timeline conflicts are classic ordering/causality symptoms.",
      "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Evaluate each candidate approach independently under the same constraints. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-067",
      "type": "multi-select",
      "question": "To separate display time from correctness ordering, which are valid? (Select all that apply)",
      "options": [
        "Store logical/causal version for writes",
        "Use wall-clock only for UI display context",
        "Use display timestamp as sole conflict resolver always",
        "Retain metadata needed for conflict resolution"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Correctness should be metadata-driven; display time can remain user-facing context.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Validate each proposed control independently and avoid partially true claims that fail under realistic load. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-068",
      "type": "multi-select",
      "question": "Which are valid conflict-resolution strategies for concurrent updates? (Select all that apply)",
      "options": [
        "Domain-specific merge rules",
        "User-visible conflict resolution for critical fields",
        "Blind last-arrival-wins everywhere",
        "CRDT-style commutative merges where suitable"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Conflict policy should match domain semantics; naive global last-arrival wins is risky.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Anchor decisions in explicit constraints, invariants, and observable failure signals rather than intuition. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-069",
      "type": "multi-select",
      "question": "Useful observability for time/ordering issues includes which? (Select all that apply)",
      "options": [
        "Clock skew distribution",
        "Out-of-order event rate",
        "Only CPU utilization",
        "Version regression counters"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Ordering incidents require direct telemetry on skew/reordering/version regressions.",
      "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Anchor decisions in explicit constraints, invariants, and observable failure signals rather than intuition. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-070",
      "type": "multi-select",
      "question": "When can total ordering be overkill? (Select all that apply)",
      "options": [
        "Independent entities that do not interact causally",
        "Workloads where partition-local order is enough",
        "Critical global invariants across all operations",
        "Paths where commutative updates are valid"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Global total order is costly; use it only where truly required.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Validate each proposed control independently and avoid partially true claims that fail under realistic load. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-071",
      "type": "multi-select",
      "question": "Which anti-patterns commonly cause causal bugs? (Select all that apply)",
      "options": [
        "Mixing event-time and processing-time semantics silently",
        "Dropping causal metadata in intermediate services",
        "Maintaining per-entity version history",
        "Assuming retries preserve original order"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Lost metadata and hidden semantic assumptions create ordering failures.",
      "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Anchor decisions in explicit constraints, invariants, and observable failure signals rather than intuition. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-072",
      "type": "multi-select",
      "question": "For replay pipelines, which controls help preserve correctness? (Select all that apply)",
      "options": [
        "Idempotency keys",
        "Version monotonicity checks",
        "Allow stale replay to overwrite newer writes",
        "Replay windows with dedupe state"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Replay safety depends on idempotency, monotonic guards, and dedupe controls.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Evaluate each candidate approach independently under the same constraints. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-073",
      "type": "multi-select",
      "question": "Which conditions increase clock-skew risk impact? (Select all that apply)",
      "options": [
        "Cross-region writes with strict timestamp ordering assumptions",
        "NTP instability in isolated networks",
        "Logical versioning on critical writes",
        "Conflict resolution solely by wall time"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Skew is most harmful when correctness logic relies directly on physical time ordering.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Anchor decisions in explicit constraints, invariants, and observable failure signals rather than intuition. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-074",
      "type": "multi-select",
      "question": "When introducing causal metadata, which rollout steps are useful? (Select all that apply)",
      "options": [
        "Dual-write old/new metadata temporarily",
        "Backwards-compatible read logic during migration",
        "Big-bang schema switch with no fallback",
        "Canary validation of ordering anomaly rates"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Compatibility and canarying reduce migration risk.",
      "detailedExplanation": "Generalize from introducing causal metadata, which rollout steps are useful? (Select all that apply) to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Validate each proposed control independently and avoid partially true claims that fail under realistic load. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-075",
      "type": "multi-select",
      "question": "Which are valid degraded behaviors when causal order is uncertain? (Select all that apply) (Time, Ordering & Causality context)",
      "options": [
        "Delay user-visible apply until dependency confirmed",
        "Show pending sync state",
        "Silently overwrite with uncertain update",
        "Escalate to stronger read path for validation"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Explicit degraded semantics are safer than silent incorrect ordering.",
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Anchor decisions in explicit constraints, invariants, and observable failure signals rather than intuition. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-076",
      "type": "multi-select",
      "question": "Which workloads typically need at least partition-local ordering? (Select all that apply)",
      "options": [
        "Per-account ledger streams",
        "Chat threads with reply ordering",
        "Totally independent telemetry counters",
        "Order-status event progression"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Entity-local workflows often need consistent local sequence semantics.",
      "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Validate each proposed control independently and avoid partially true claims that fail under realistic load. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. Common pitfall: assuming exactly-once without idempotency.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-077",
      "type": "multi-select",
      "question": "What helps prevent newer write overwritten by older replay? (Select all that apply)",
      "options": [
        "Per-entity monotonic version checks",
        "Compare-and-set on expected version",
        "Timestamp-only last-arrival wins policy",
        "Replay dedupe with causal/version metadata"
      ],
      "correctIndices": [0, 1, 3],
      "explanation": "Version and CAS protections guard against stale replay overwrites.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Anchor decisions in explicit constraints, invariants, and observable failure signals rather than intuition. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-078",
      "type": "numeric-input",
      "question": "A stream processes 18,000 events/sec. Out-of-order rate is 0.6%. Out-of-order events/sec?",
      "answer": 108,
      "unit": "events/sec",
      "tolerance": 0.02,
      "explanation": "0.006 * 18,000 = 108.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Keep every transformation in one unit system and check order of magnitude at the end. A good message-system answer defines guarantees clearly for both producer and consumer paths. Keep quantities like 18,000 and 0.6 in aligned units before deciding on an implementation approach. Common pitfall: consumer lag growth under burst traffic.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "NGINX Load Balancing",
          "url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-079",
      "type": "numeric-input",
      "question": "Clock skew p99 is 420ms, tolerance budget is 150ms. Percent over budget?",
      "answer": 180,
      "unit": "%",
      "tolerance": 0.5,
      "explanation": "(420-150)/150 = 180%.",
      "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Normalize units before computing so conversion mistakes do not propagate. Tie decisions to concrete operational outcomes, not abstract reliability language. If values like 420ms and 150ms appear, convert them into one unit basis before comparison. Common pitfall: meeting average goals while missing tail-risk.",
      "references": [
        {
          "title": "Percentile",
          "url": "https://en.wikipedia.org/wiki/Percentile"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-080",
      "type": "numeric-input",
      "question": "Event replay backlog is 720,000 events. Replayer throughput is 4,000 events/sec. Seconds to drain (no new events)?",
      "answer": 180,
      "unit": "seconds",
      "tolerance": 0,
      "explanation": "720,000 / 4,000 = 180s.",
      "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Write the unit conversion path explicitly, then calculate, then sanity-check magnitude. The important tradeoffs are delivery semantics, ordering scope, and backpressure under failure. Numbers such as 720,000 and 4,000 should be normalized first so downstream reasoning stays consistent. Common pitfall: ordering loss during partition or replay changes.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-081",
      "type": "numeric-input",
      "question": "A service sees 2,400,000 updates/day. Concurrent-update conflict rate is 0.35%. Conflicts/day?",
      "answer": 8400,
      "unit": "updates",
      "tolerance": 0.02,
      "explanation": "0.0035 * 2,400,000 = 8,400.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Write the unit conversion path explicitly, then calculate, then sanity-check magnitude. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Numbers such as 2,400 and 000 should be normalized first so downstream reasoning stays consistent. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-082",
      "type": "numeric-input",
      "question": "Monotonic-version violation rate is 0.09% across 9,000,000 writes/day. Violations/day?",
      "answer": 8100,
      "unit": "writes",
      "tolerance": 0.03,
      "explanation": "0.0009 * 9,000,000 = 8,100.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Keep every transformation in one unit system and check order of magnitude at the end. Interface decisions should be justified by contract stability and client impact over time. Keep quantities like 0.09 and 9,000 in aligned units before deciding on an implementation approach. Common pitfall: breaking clients during version evolution.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-083",
      "type": "numeric-input",
      "question": "Causal-metadata payload adds 42 bytes/event at 65,000 events/sec. Extra MB/sec (decimal MB)?",
      "answer": 2.73,
      "unit": "MB/sec",
      "tolerance": 0.08,
      "explanation": "65,000*42 = 2,730,000 bytes/sec  2.73 MB/sec.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Write the unit conversion path explicitly, then calculate, then sanity-check magnitude. Interface decisions should be justified by contract stability and client impact over time. Numbers such as 42 and 65,000 should be normalized first so downstream reasoning stays consistent. Common pitfall: interface design coupled too tightly to internal implementation.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-084",
      "type": "numeric-input",
      "question": "Retry replay adds 0.18 extra deliveries per original event. At 30,000 original events/sec, effective deliveries/sec?",
      "answer": 35400,
      "unit": "deliveries/sec",
      "tolerance": 0.02,
      "explanation": "30,000 * 1.18 = 35,400.",
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Normalize units before computing so conversion mistakes do not propagate. Map the approach to measurable reliability impact such as error-budget burn and recovery behavior. If values like 0.18 and 30,000 appear, convert them into one unit basis before comparison. Common pitfall: retry storms during partial failure.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "Retry pattern",
          "url": "https://learn.microsoft.com/en-us/azure/architecture/patterns/retry"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-085",
      "type": "numeric-input",
      "question": "A per-entity stream has 12 partitions and one hot partition carries 26% traffic. If total is 48,000 events/sec, hot-partition rate?",
      "answer": 12480,
      "unit": "events/sec",
      "tolerance": 0.02,
      "explanation": "0.26 * 48,000 = 12,480.",
      "detailedExplanation": "Generalize from per-entity stream has 12 partitions and one hot partition carries 26% traffic to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Normalize units before computing so conversion mistakes do not propagate. Throughput is only one part; replay behavior and consumer lag handling matter equally. If values like 12 and 26 appear, convert them into one unit basis before comparison. Common pitfall: assuming exactly-once without idempotency.",
      "references": [
        {
          "title": "Apache Kafka documentation",
          "url": "https://kafka.apache.org/documentation/"
        },
        {
          "title": "RabbitMQ Tutorials",
          "url": "https://www.rabbitmq.com/tutorials"
        },
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-086",
      "type": "numeric-input",
      "question": "A timeline merge waits up to 250ms for causal predecessor. Current average pause is 90ms. Remaining budget?",
      "answer": 160,
      "unit": "ms",
      "tolerance": 0,
      "explanation": "250 - 90 = 160ms.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Normalize units before computing so conversion mistakes do not propagate. Consistency decisions should be explicit about which conflicts are acceptable and why. If values like 250ms and 90ms appear, convert them into one unit basis before comparison. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-087",
      "type": "numeric-input",
      "question": "Out-of-order anomaly SLO is <=0.2%. Observed is 0.47%. How many times above SLO is observed?",
      "answer": 2.35,
      "unit": "x",
      "tolerance": 0.05,
      "explanation": "0.47 / 0.2 = 2.35x.",
      "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Normalize units before computing so conversion mistakes do not propagate. Tie decisions to concrete operational outcomes, not abstract reliability language. If values like 0.2 and 0.47 appear, convert them into one unit basis before comparison. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-088",
      "type": "numeric-input",
      "question": "If 15% of operations require causal checks and total ops are 80,000/sec, how many causal-check ops/sec?",
      "answer": 12000,
      "unit": "ops/sec",
      "tolerance": 0.01,
      "explanation": "0.15 * 80,000 = 12,000.",
      "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Write the unit conversion path explicitly, then calculate, then sanity-check magnitude. Consistency decisions should be explicit about which conflicts are acceptable and why. Numbers such as 15 and 80,000 should be normalized first so downstream reasoning stays consistent. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-089",
      "type": "numeric-input",
      "question": "A conflict resolver succeeds automatically for 92% of 50,000 concurrent conflicts/day. Manual conflicts/day?",
      "answer": 4000,
      "unit": "conflicts",
      "tolerance": 0.02,
      "explanation": "8% of 50,000 = 4,000.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Keep every transformation in one unit system and check order of magnitude at the end. Consistency decisions should be explicit about which conflicts are acceptable and why. Keep quantities like 92 and 50,000 in aligned units before deciding on an implementation approach. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-090",
      "type": "ordering",
      "question": "Order a robust ordering-bug triage flow.",
      "items": [
        "Confirm anomaly type (skew/reorder/concurrency)",
        "Inspect causal/version metadata path",
        "Apply targeted ordering control",
        "Add regression alert/test coverage"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Classify, diagnose metadata gaps, mitigate, then harden.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Build the rank from biggest differences first, then refine with adjacent checks. Pick based on invariants and acceptable anomalies, then justify latency/availability tradeoffs. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-091",
      "type": "ordering",
      "question": "Order by increasing guarantee strength (typical).",
      "items": [
        "Best-effort eventual order",
        "Partition-local order",
        "Causal order",
        "Global total order"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Stronger ordering guarantees add coordination cost.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Build the rank from biggest differences first, then refine with adjacent checks. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-092",
      "type": "ordering",
      "question": "Order by likely implementation complexity.",
      "items": [
        "Timestamp-only sort",
        "Lamport-clock ordering",
        "Vector-clock causal tracking",
        "Global total-order broadcast"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Complexity generally increases with stronger/ broader ordering semantics.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Build the rank from biggest differences first, then refine with adjacent checks. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-093",
      "type": "ordering",
      "question": "Order replay-safety controls from foundational to advanced.",
      "items": [
        "Idempotency key checks",
        "Per-entity version monotonicity guard",
        "Causal dependency validation",
        "Conflict-aware merge with user-visible resolution"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Start with dedupe, then add stronger causal/conflict handling.",
      "detailedExplanation": "Begin by naming the dominant constraint, then pressure-test candidate approaches against reliability, latency, and operability trade-offs. Order by relative scale and bottleneck effect, then validate neighboring items. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-094",
      "type": "ordering",
      "question": "Order by increasing stale-replay overwrite risk.",
      "items": [
        "CAS with expected version",
        "Version check only",
        "Timestamp compare only",
        "Blind apply on arrival"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Risk grows as version/causal safeguards are removed.",
      "detailedExplanation": "Anchor on the dominant constraint and evaluate approaches by blast radius, reversibility, and operational cost. Build the rank from biggest differences first, then refine with adjacent checks. Good API choices balance client ergonomics, compatibility, and long-term evolvability. Common pitfall: ambiguous contracts that hide behavior changes.",
      "references": [
        {
          "title": "RFC 9110: HTTP Semantics",
          "url": "https://www.rfc-editor.org/rfc/rfc9110"
        },
        {
          "title": "gRPC Documentation",
          "url": "https://grpc.io/docs/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-095",
      "type": "ordering",
      "question": "Order rollout safety for new causal metadata.",
      "items": [
        "Dual-read compatibility mode",
        "Canary write path",
        "Measure anomaly deltas",
        "Promote and retire legacy format"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Compatibility and measured canarying reduce migration risk.",
      "detailedExplanation": "For related interview or production problems, distinguish core signal from background noise before selecting mitigations. Build the rank from biggest differences first, then refine with adjacent checks. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-096",
      "type": "ordering",
      "question": "Order by strongest evidence for clock-skew incident diagnosis.",
      "items": [
        "Anecdotal timestamps in logs",
        "Single host clock check",
        "Fleet skew histogram by region",
        "Skew histogram correlated with ordering anomalies"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Correlated telemetry provides highest diagnostic confidence.",
      "detailedExplanation": "Generalize from order by strongest evidence for clock-skew incident diagnosis to the underlying invariant and failure mode, then compare approaches by risk reduction, reversibility, and operational cost. Order by relative scale and bottleneck effect, then validate neighboring items. Map the approach to measurable reliability impact such as error-budget burn and recovery behavior. Common pitfall: assuming recovery speed without operational proof.",
      "references": [
        {
          "title": "Google SRE Book: Service Level Objectives",
          "url": "https://sre.google/sre-book/service-level-objectives/"
        },
        {
          "title": "Google SRE Book: Embracing Risk (Error Budgets)",
          "url": "https://sre.google/sre-book/embracing-risk/"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-097",
      "type": "ordering",
      "question": "Order processing models by throughput potential (typical).",
      "items": [
        "Global total order",
        "Cross-partition causal ordering",
        "Partition-local ordering",
        "Unordered commutative processing"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Throughput generally rises as ordering constraints relax.",
      "detailedExplanation": "Generalize this scenario to the underlying systems skill: identify the invariant to protect, the load/failure pattern, and the first control that changes outcomes. Place obvious extremes first, then sort the middle by pairwise comparison. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: ignoring conflict resolution behavior.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-098",
      "type": "ordering",
      "question": "Order degraded responses when causal uncertainty appears. (Time, Ordering & Causality context)",
      "items": [
        "Mark state pending",
        "Escalate to stronger read/validation path",
        "Delay dependent actions",
        "Require manual/compensating resolution for high-risk cases"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Progress from low-cost caution to stronger safeguards for high-risk actions.",
      "detailedExplanation": "For related interview or production problems, make the decision around the dominant constraint instead of broad platform-wide changes. Place obvious extremes first, then sort the middle by pairwise comparison. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-099",
      "type": "ordering",
      "question": "Order by increasing dependence on synchronized physical clocks.",
      "items": [
        "Pure logical/version ordering",
        "Logical+timestamp tie-break",
        "Timestamp-first with version fallback",
        "Timestamp-only correctness"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Reliance on physical clock synchronization grows along this ordering.",
      "detailedExplanation": "For related interview and production incidents, classify the dominant failure mode first, then choose the earliest intervention that materially reduces user-facing risk. Order by relative scale and bottleneck effect, then validate neighboring items. Strong answers connect quorum/coordination settings to concrete correctness goals. Common pitfall: using weak consistency for strict invariants.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    },
    {
      "id": "cc-tc-100",
      "type": "ordering",
      "question": "Order conflict-handling maturity.",
      "items": [
        "Implicit overwrite policy",
        "Static merge rule",
        "Entity-specific merge semantics",
        "Entity-specific semantics with user-visible conflict workflows"
      ],
      "correctOrder": [0, 1, 2, 3],
      "explanation": "Maturity improves with explicit domain-aware and user-aware conflict handling.",
      "detailedExplanation": "For related interview or production problems, identify the highest-signal symptom early and map it to the smallest high-leverage control change. Place obvious extremes first, then sort the middle by pairwise comparison. Consistency decisions should be explicit about which conflicts are acceptable and why. Common pitfall: misreading quorum behavior during failures.",
      "references": [
        {
          "title": "CAP theorem",
          "url": "https://en.wikipedia.org/wiki/CAP_theorem"
        },
        {
          "title": "In Search of an Understandable Consensus Algorithm (Raft)",
          "url": "https://raft.github.io/raft.pdf"
        },
        {
          "title": "System Design Primer: Back-of-the-envelope estimation",
          "url": "https://github.com/donnemartin/system-design-primer#back-of-the-envelope-estimation"
        }
      ],
      "tags": ["consistency-coordination", "time-ordering-and-causality"],
      "difficulty": "senior"
    }
  ]
}
